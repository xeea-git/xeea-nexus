{"version":3,"sources":["../src/theme.ts","../src/parser.ts","../src/ascii/types.ts","../src/ascii/canvas.ts","../src/ascii/converter.ts","../src/ascii/pathfinder.ts","../src/ascii/edge-routing.ts","../src/ascii/draw.ts","../src/ascii/grid.ts","../src/sequence/parser.ts","../src/ascii/sequence.ts","../src/class/parser.ts","../src/ascii/class-diagram.ts","../src/er/parser.ts","../src/ascii/er-diagram.ts","../src/ascii/index.ts","../src/styles.ts","../src/dagre-adapter.ts","../src/layout.ts","../src/renderer.ts","../src/sequence/layout.ts","../src/sequence/renderer.ts","../src/class/layout.ts","../src/class/renderer.ts","../src/er/layout.ts","../src/er/renderer.ts","../src/index.ts"],"names":["name","type","isStatic","isAbstract","dist","DEFAULTS","dagre","srcShape","tgtShape","g","arrowMarkerDefs","escapeXml","midpoint","detectDiagramType"],"mappings":";;;;;;;;;AAkDO,IAAM,QAAA,GAAiD;AAAA,EAC5D,EAAA,EAAI,SAAA;AAAA,EACJ,EAAA,EAAI;AACN;AAUO,IAAM,GAAA,GAAM;AAAA,EAEH;AAAA;AAAA,EAEd,OAAA,EAAc,EAAA;AAAA;AAAA,EAEd,SAAA,EAAc,EAAA;AAAA;AAAA,EAEd,SAAA,EAAc,EAAA;AAAA;AAAA,EAEd,IAAA,EAAc,EAAA;AAAA;AAAA,EAEd,KAAA,EAAc,EAAA;AAAA;AAAA,EAEd,QAAA,EAAc,CAAA;AAAA;AAAA,EAEd,UAAA,EAAc,EAAA;AAAA;AAAA,EAEd,WAAA,EAAc,CAAA;AAAA;AAAA,EAEd,WAAA,EAAc,EAAA;AAAA;AAAA,EAEd,QAAA,EAAc;AAChB,CAAA;AASO,IAAM,MAAA,GAAwC;AAAA,EACnD,WAAA,EAAa;AAAA,IACX,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI;AAAA,GACrB;AAAA,EACA,aAAA,EAAe;AAAA,IACb,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,mBAAA,EAAqB;AAAA,IACnB,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,mBAAA,EAAqB;AAAA,IACnB,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,kBAAA,EAAoB;AAAA,IAClB,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,kBAAA,EAAoB;AAAA,IAClB,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,MAAA,EAAQ;AAAA,IACN,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,YAAA,EAAc;AAAA,IACZ,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,SAAA,EAAW;AAAA,IACT,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,cAAA,EAAgB;AAAA,IACd,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,aAAA,EAAe;AAAA,IACb,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,iBAAA,EAAmB;AAAA,IACjB,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,gBAAA,EAAkB;AAAA,IAChB,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA,GAC7C;AAAA,EACA,UAAA,EAAY;AAAA,IACV,EAAA,EAAI,SAAA;AAAA,IAAW,EAAA,EAAI,SAAA;AAAA,IACnB,IAAA,EAAM,SAAA;AAAA,IAAW,MAAA,EAAQ,SAAA;AAAA,IAAW,KAAA,EAAO;AAAA;AAE/C;AA+CO,SAAS,eAAe,KAAA,EAAsC;AACnE,EAAA,MAAM,CAAA,GAAI,KAAA,CAAM,MAAA,IAAU,EAAC;AAC3B,EAAA,MAAM,IAAA,GAAO,MAAM,IAAA,KAAS,MAAA;AAG5B,EAAA,MAAM,UAAA,GAAa,CAAC,KAAA,KAClB,KAAA,CAAM,WAAA,EAAa,IAAA;AAAA,IAAK,CAAA,CAAA,KACtB,KAAA,CAAM,OAAA,CAAQ,CAAA,CAAE,KAAK,CAAA,GAAI,CAAA,CAAE,KAAA,CAAM,QAAA,CAAS,KAAK,CAAA,GAAI,CAAA,CAAE,KAAA,KAAU;AAAA,KAC9D,QAAA,EAAU,UAAA;AAEf,EAAA,OAAO;AAAA,IACL,EAAA,EAAI,CAAA,CAAE,mBAAmB,CAAA,KAAM,OAAO,SAAA,GAAY,SAAA,CAAA;AAAA,IAClD,EAAA,EAAI,CAAA,CAAE,mBAAmB,CAAA,KAAM,OAAO,SAAA,GAAY,SAAA,CAAA;AAAA,IAClD,IAAA,EAAS,CAAA,CAAE,6BAA6B,CAAA,IAAK,MAAA;AAAA,IAC7C,QAAS,CAAA,CAAE,aAAa,CAAA,IAAK,UAAA,CAAW,SAAS,CAAA,IAAK,MAAA;AAAA,IACtD,OAAS,UAAA,CAAW,SAAS,CAAA,IAAK,CAAA,CAAE,6BAA6B,CAAA,IAAK,MAAA;AAAA,IACtE,OAAA,EAAS,CAAA,CAAE,4BAA4B,CAAA,IAAK,MAAA;AAAA,IAC5C,MAAA,EAAS,CAAA,CAAE,qBAAqB,CAAA,IAAK;AAAA,GACvC;AACF;AAiBO,SAAS,eAAA,CAAgB,MAAc,WAAA,EAA8B;AAC1E,EAAA,MAAM,WAAA,GAAc;AAAA,IAClB,CAAA,sDAAA,EAAyD,kBAAA,CAAmB,IAAI,CAAC,CAAA,yCAAA,CAAA;AAAA,IACjF,GAAI,WAAA,GACA,CAAC,CAAA,qGAAA,CAAuG,IACxG;AAAC,GACP;AAIA,EAAA,MAAM,WAAA,GAAc;AAAA;AAAA;AAAA,gEAAA,EAG4C,IAAI,OAAO,CAAA;AAAA,gEAAA,EACX,IAAI,SAAS,CAAA;AAAA,mDAAA,EAC1B,IAAI,SAAS,CAAA;AAAA,+DAAA,EACD,IAAI,IAAI,CAAA;AAAA,iEAAA,EACN,IAAI,KAAK,CAAA;AAAA,kEAAA,EACR,IAAI,QAAQ,CAAA;AAAA,iEAAA,EACb,IAAI,UAAU,CAAA;AAAA;AAAA,mDAAA,EAE5B,IAAI,WAAW,CAAA;AAAA,mDAAA,EACf,IAAI,WAAW,CAAA;AAAA,mDAAA,EACf,IAAI,QAAQ,CAAA,cAAA,CAAA;AAE/D,EAAA,OAAO;AAAA,IACL,SAAA;AAAA,IACA,CAAA,EAAA,EAAK,WAAA,CAAY,IAAA,CAAK,MAAM,CAAC,CAAA,CAAA;AAAA,IAC7B,0BAA0B,IAAI,CAAA,2BAAA,CAAA;AAAA,IAC9B,GAAI,WAAA,GAAc,CAAC,CAAA,2FAAA,CAA6F,IAAI,EAAC;AAAA,IACrH,UAAU,WAAW,CAAA,CAAA;AAAA,IACrB,CAAA,GAAA,CAAA;AAAA,IACA;AAAA,GACF,CAAE,KAAK,IAAI,CAAA;AACb;AASO,SAAS,UAAA,CACd,KAAA,EACA,MAAA,EACA,MAAA,EACA,WAAA,EACQ;AAER,EAAA,MAAM,IAAA,GAAO;AAAA,IACX,CAAA,KAAA,EAAQ,OAAO,EAAE,CAAA,CAAA;AAAA,IACjB,CAAA,KAAA,EAAQ,OAAO,EAAE,CAAA,CAAA;AAAA,IACjB,MAAA,CAAO,IAAA,GAAU,CAAA,OAAA,EAAU,MAAA,CAAO,IAAI,CAAA,CAAA,GAAK,EAAA;AAAA,IAC3C,MAAA,CAAO,MAAA,GAAU,CAAA,SAAA,EAAY,MAAA,CAAO,MAAM,CAAA,CAAA,GAAK,EAAA;AAAA,IAC/C,MAAA,CAAO,KAAA,GAAU,CAAA,QAAA,EAAW,MAAA,CAAO,KAAK,CAAA,CAAA,GAAK,EAAA;AAAA,IAC7C,MAAA,CAAO,OAAA,GAAU,CAAA,UAAA,EAAa,MAAA,CAAO,OAAO,CAAA,CAAA,GAAK,EAAA;AAAA,IACjD,MAAA,CAAO,MAAA,GAAU,CAAA,SAAA,EAAY,MAAA,CAAO,MAAM,CAAA,CAAA,GAAK;AAAA,GACjD,CAAE,MAAA,CAAO,OAAO,CAAA,CAAE,KAAK,GAAG,CAAA;AAE1B,EAAA,MAAM,OAAA,GAAU,cAAc,EAAA,GAAK,uBAAA;AAEnC,EAAA,OACE,CAAA,qDAAA,EAAwD,KAAK,CAAA,CAAA,EAAI,MAAM,CAAA,SAAA,EAC7D,KAAK,CAAA,UAAA,EAAa,MAAM,CAAA,SAAA,EAAY,IAAI,CAAA,EAAG,OAAO,CAAA,EAAA,CAAA;AAEhE;;;AC1RO,SAAS,aAAa,IAAA,EAA4B;AACvD,EAAA,MAAM,KAAA,GAAQ,KAAK,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAA,EAAM,EAAE,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,MAAA,GAAS,CAAA,IAAK,CAAC,CAAA,CAAE,UAAA,CAAW,IAAI,CAAC,CAAA;AAEjG,EAAA,IAAI,KAAA,CAAM,WAAW,CAAA,EAAG;AACtB,IAAA,MAAM,IAAI,MAAM,uBAAuB,CAAA;AAAA,EACzC;AAGA,EAAA,MAAM,MAAA,GAAS,MAAM,CAAC,CAAA;AAGtB,EAAA,IAAI,0BAAA,CAA2B,IAAA,CAAK,MAAM,CAAA,EAAG;AAC3C,IAAA,OAAO,kBAAkB,KAAK,CAAA;AAAA,EAChC;AAGA,EAAA,OAAO,eAAe,KAAK,CAAA;AAC7B;AAMA,SAAS,eAAe,KAAA,EAA+B;AACrD,EAAA,MAAM,WAAA,GAAc,KAAA,CAAM,CAAC,CAAA,CAAG,MAAM,8CAA8C,CAAA;AAClF,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAA4B,KAAA,CAAM,CAAC,CAAC,CAAA,+DAAA,CAAiE,CAAA;AAAA,EACvH;AAEA,EAAA,MAAM,SAAA,GAAY,WAAA,CAAY,CAAC,CAAA,CAAG,WAAA,EAAY;AAE9C,EAAA,MAAM,KAAA,GAAsB;AAAA,IAC1B,SAAA;AAAA,IACA,KAAA,sBAAW,GAAA,EAAI;AAAA,IACf,OAAO,EAAC;AAAA,IACR,WAAW,EAAC;AAAA,IACZ,SAAA,sBAAe,GAAA,EAAI;AAAA,IACnB,gBAAA,sBAAsB,GAAA,EAAI;AAAA,IAC1B,UAAA,sBAAgB,GAAA;AAAI,GACtB;AAGA,EAAA,MAAM,gBAAmC,EAAC;AAE1C,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAGpB,IAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,KAAA,CAAM,2BAA2B,CAAA;AAC5D,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,MAAM,IAAA,GAAO,cAAc,CAAC,CAAA;AAC5B,MAAA,MAAM,QAAA,GAAW,cAAc,CAAC,CAAA;AAChC,MAAA,MAAM,KAAA,GAAQ,gBAAgB,QAAQ,CAAA;AACtC,MAAA,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,IAAA,EAAM,KAAK,CAAA;AAC/B,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,KAAA,CAAM,6BAA6B,CAAA;AACjE,IAAA,IAAI,gBAAA,EAAkB;AACpB,MAAA,MAAM,OAAA,GAAU,gBAAA,CAAiB,CAAC,CAAA,CAAG,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,IAAA,EAAM,CAAA;AACjE,MAAA,MAAM,SAAA,GAAY,iBAAiB,CAAC,CAAA;AACpC,MAAA,KAAA,MAAW,MAAM,OAAA,EAAS;AACxB,QAAA,KAAA,CAAM,gBAAA,CAAiB,GAAA,CAAI,EAAA,EAAI,SAAS,CAAA;AAAA,MAC1C;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,KAAA,CAAM,4BAA4B,CAAA;AAC1D,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,MAAM,OAAA,GAAU,UAAA,CAAW,CAAC,CAAA,CAAG,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,IAAA,EAAM,CAAA;AAC3D,MAAA,MAAM,KAAA,GAAQ,eAAA,CAAgB,UAAA,CAAW,CAAC,CAAE,CAAA;AAC5C,MAAA,KAAA,MAAW,MAAM,OAAA,EAAS;AACxB,QAAA,KAAA,CAAM,UAAA,CAAW,GAAA,CAAI,EAAA,EAAI,EAAE,GAAG,KAAA,CAAM,UAAA,CAAW,GAAA,CAAI,EAAE,CAAA,EAAG,GAAG,KAAA,EAAO,CAAA;AAAA,MACpE;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,oCAAoC,CAAA;AAChE,IAAA,IAAI,QAAA,IAAY,aAAA,CAAc,MAAA,GAAS,CAAA,EAAG;AACxC,MAAA,aAAA,CAAc,aAAA,CAAc,SAAS,CAAC,CAAA,CAAG,YAAY,QAAA,CAAS,CAAC,EAAG,WAAA,EAAY;AAC9E,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,KAAA,CAAM,mBAAmB,CAAA;AACpD,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,MAAM,IAAA,GAAO,aAAA,CAAc,CAAC,CAAA,CAAG,IAAA,EAAK;AAGpC,MAAA,MAAM,YAAA,GAAe,IAAA,CAAK,KAAA,CAAM,uBAAuB,CAAA;AACvD,MAAA,IAAI,EAAA;AACJ,MAAA,IAAI,KAAA;AACJ,MAAA,IAAI,YAAA,EAAc;AAChB,QAAA,EAAA,GAAK,aAAa,CAAC,CAAA;AACnB,QAAA,KAAA,GAAQ,aAAa,CAAC,CAAA;AAAA,MACxB,CAAA,MAAO;AAEL,QAAA,KAAA,GAAQ,IAAA;AACR,QAAA,EAAA,GAAK,KAAK,OAAA,CAAQ,MAAA,EAAQ,GAAG,CAAA,CAAE,OAAA,CAAQ,UAAU,EAAE,CAAA;AAAA,MACrD;AACA,MAAA,MAAM,EAAA,GAAsB,EAAE,EAAA,EAAI,KAAA,EAAO,SAAS,EAAC,EAAG,QAAA,EAAU,EAAC,EAAE;AACnE,MAAA,aAAA,CAAc,KAAK,EAAE,CAAA;AACrB,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,SAAS,KAAA,EAAO;AAClB,MAAA,MAAM,SAAA,GAAY,cAAc,GAAA,EAAI;AACpC,MAAA,IAAI,SAAA,EAAW;AACb,QAAA,IAAI,aAAA,CAAc,SAAS,CAAA,EAAG;AAC5B,UAAA,aAAA,CAAc,cAAc,MAAA,GAAS,CAAC,CAAA,CAAG,QAAA,CAAS,KAAK,SAAS,CAAA;AAAA,QAClE,CAAA,MAAO;AACL,UAAA,KAAA,CAAM,SAAA,CAAU,KAAK,SAAS,CAAA;AAAA,QAChC;AAAA,MACF;AACA,MAAA;AAAA,IACF;AAGA,IAAA,aAAA,CAAc,IAAA,EAAM,OAAO,aAAa,CAAA;AAAA,EAC1C;AAEA,EAAA,OAAO,KAAA;AACT;AAiBA,SAAS,kBAAkB,KAAA,EAA+B;AACxD,EAAA,MAAM,KAAA,GAAsB;AAAA,IAC1B,SAAA,EAAW,IAAA;AAAA,IACX,KAAA,sBAAW,GAAA,EAAI;AAAA,IACf,OAAO,EAAC;AAAA,IACR,WAAW,EAAC;AAAA,IACZ,SAAA,sBAAe,GAAA,EAAI;AAAA,IACnB,gBAAA,sBAAsB,GAAA,EAAI;AAAA,IAC1B,UAAA,sBAAgB,GAAA;AAAI,GACtB;AAGA,EAAA,MAAM,iBAAoC,EAAC;AAE3C,EAAA,IAAI,UAAA,GAAa,CAAA;AACjB,EAAA,IAAI,QAAA,GAAW,CAAA;AAEf,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAGpB,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,oCAAoC,CAAA;AAChE,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,QAAA,cAAA,CAAe,cAAA,CAAe,SAAS,CAAC,CAAA,CAAG,YAAY,QAAA,CAAS,CAAC,EAAG,WAAA,EAAY;AAAA,MAClF,CAAA,MAAO;AACL,QAAA,KAAA,CAAM,SAAA,GAAY,QAAA,CAAS,CAAC,CAAA,CAAG,WAAA,EAAY;AAAA,MAC7C;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,KAAA,CAAM,4CAA4C,CAAA;AAC9E,IAAA,IAAI,cAAA,EAAgB;AAClB,MAAA,MAAM,KAAA,GAAQ,cAAA,CAAe,CAAC,CAAA,IAAK,eAAe,CAAC,CAAA;AACnD,MAAA,MAAM,EAAA,GAAK,eAAe,CAAC,CAAA;AAC3B,MAAA,MAAM,EAAA,GAAsB,EAAE,EAAA,EAAI,KAAA,EAAO,SAAS,EAAC,EAAG,QAAA,EAAU,EAAC,EAAE;AACnE,MAAA,cAAA,CAAe,KAAK,EAAE,CAAA;AACtB,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,SAAS,GAAA,EAAK;AAChB,MAAA,MAAM,SAAA,GAAY,eAAe,GAAA,EAAI;AACrC,MAAA,IAAI,SAAA,EAAW;AACb,QAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,UAAA,cAAA,CAAe,eAAe,MAAA,GAAS,CAAC,CAAA,CAAG,QAAA,CAAS,KAAK,SAAS,CAAA;AAAA,QACpE,CAAA,MAAO;AACL,UAAA,KAAA,CAAM,SAAA,CAAU,KAAK,SAAS,CAAA;AAAA,QAChC;AAAA,MACF;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,KAAA,CAAM,qCAAqC,CAAA;AACxE,IAAA,IAAI,eAAA,EAAiB;AACnB,MAAA,MAAM,KAAA,GAAQ,gBAAgB,CAAC,CAAA;AAC/B,MAAA,MAAM,EAAA,GAAK,gBAAgB,CAAC,CAAA;AAC5B,MAAA,iBAAA,CAAkB,OAAO,cAAA,EAAgB,EAAE,IAAI,KAAA,EAAO,KAAA,EAAO,WAAW,CAAA;AACxE,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,KAAA,CAAM,6DAA6D,CAAA;AAChG,IAAA,IAAI,eAAA,EAAiB;AACnB,MAAA,IAAI,QAAA,GAAW,gBAAgB,CAAC,CAAA;AAChC,MAAA,IAAI,QAAA,GAAW,gBAAgB,CAAC,CAAA;AAChC,MAAA,MAAM,SAAA,GAAY,eAAA,CAAgB,CAAC,CAAA,EAAG,MAAK,IAAK,MAAA;AAGhD,MAAA,IAAI,aAAa,KAAA,EAAO;AACtB,QAAA,UAAA,EAAA;AACA,QAAA,QAAA,GAAW,CAAA,MAAA,EAAS,UAAA,GAAa,CAAA,GAAI,UAAA,GAAa,EAAE,CAAA,CAAA;AACpD,QAAA,iBAAA,CAAkB,KAAA,EAAO,gBAAgB,EAAE,EAAA,EAAI,UAAU,KAAA,EAAO,EAAA,EAAI,KAAA,EAAO,aAAA,EAAe,CAAA;AAAA,MAC5F,CAAA,MAAO;AACL,QAAA,eAAA,CAAgB,KAAA,EAAO,gBAAgB,QAAQ,CAAA;AAAA,MACjD;AAEA,MAAA,IAAI,aAAa,KAAA,EAAO;AACtB,QAAA,QAAA,EAAA;AACA,QAAA,QAAA,GAAW,CAAA,IAAA,EAAO,QAAA,GAAW,CAAA,GAAI,QAAA,GAAW,EAAE,CAAA,CAAA;AAC9C,QAAA,iBAAA,CAAkB,KAAA,EAAO,gBAAgB,EAAE,EAAA,EAAI,UAAU,KAAA,EAAO,EAAA,EAAI,KAAA,EAAO,WAAA,EAAa,CAAA;AAAA,MAC1F,CAAA,MAAO;AACL,QAAA,eAAA,CAAgB,KAAA,EAAO,gBAAgB,QAAQ,CAAA;AAAA,MACjD;AAEA,MAAA,KAAA,CAAM,MAAM,IAAA,CAAK;AAAA,QACf,MAAA,EAAQ,QAAA;AAAA,QACR,MAAA,EAAQ,QAAA;AAAA,QACR,KAAA,EAAO,SAAA;AAAA,QACP,KAAA,EAAO,OAAA;AAAA,QACP,aAAA,EAAe,KAAA;AAAA,QACf,WAAA,EAAa;AAAA,OACd,CAAA;AACD,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,KAAA,CAAM,uBAAuB,CAAA;AACzD,IAAA,IAAI,cAAA,EAAgB;AAClB,MAAA,MAAM,EAAA,GAAK,eAAe,CAAC,CAAA;AAC3B,MAAA,MAAM,KAAA,GAAQ,cAAA,CAAe,CAAC,CAAA,CAAG,IAAA,EAAK;AACtC,MAAA,iBAAA,CAAkB,OAAO,cAAA,EAAgB,EAAE,IAAI,KAAA,EAAO,KAAA,EAAO,WAAW,CAAA;AACxE,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,KAAA;AACT;AAGA,SAAS,iBAAA,CACP,KAAA,EACA,cAAA,EACA,IAAA,EACM;AACN,EAAA,MAAM,QAAQ,CAAC,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,KAAK,EAAE,CAAA;AACtC,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,EAAA,EAAI,IAAI,CAAA;AAAA,EAC/B;AACA,EAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,IAAA,MAAM,OAAA,GAAU,cAAA,CAAe,cAAA,CAAe,MAAA,GAAS,CAAC,CAAA;AACxD,IAAA,IAAI,CAAC,OAAA,CAAQ,OAAA,CAAQ,QAAA,CAAS,IAAA,CAAK,EAAE,CAAA,EAAG;AACtC,MAAA,OAAA,CAAQ,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,EAAE,CAAA;AAAA,IAC9B;AAAA,EACF;AACF;AAGA,SAAS,eAAA,CACP,KAAA,EACA,cAAA,EACA,EAAA,EACM;AACN,EAAA,IAAI,CAAC,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,EAAE,CAAA,EAAG;AACxB,IAAA,iBAAA,CAAkB,KAAA,EAAO,gBAAgB,EAAE,EAAA,EAAI,OAAO,EAAA,EAAI,KAAA,EAAO,WAAW,CAAA;AAAA,EAC9E,CAAA,MAAO;AAEL,IAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,MAAA,MAAM,OAAA,GAAU,cAAA,CAAe,cAAA,CAAe,MAAA,GAAS,CAAC,CAAA;AACxD,MAAA,IAAI,CAAC,OAAA,CAAQ,OAAA,CAAQ,QAAA,CAAS,EAAE,CAAA,EAAG;AACjC,QAAA,OAAA,CAAQ,OAAA,CAAQ,KAAK,EAAE,CAAA;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AACF;AAOA,SAAS,gBAAgB,QAAA,EAA0C;AACjE,EAAA,MAAM,QAAgC,EAAC;AACvC,EAAA,KAAA,MAAW,IAAA,IAAQ,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,EAAG;AACtC,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,OAAA,CAAQ,GAAG,CAAA;AACjC,IAAA,IAAI,WAAW,CAAA,EAAG;AAChB,MAAA,MAAM,MAAM,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,QAAQ,EAAE,IAAA,EAAK;AACzC,MAAA,MAAM,MAAM,IAAA,CAAK,KAAA,CAAM,QAAA,GAAW,CAAC,EAAE,IAAA,EAAK;AAC1C,MAAA,IAAI,OAAO,GAAA,EAAK;AACd,QAAA,KAAA,CAAM,GAAG,CAAA,GAAI,GAAA;AAAA,MACf;AAAA,IACF;AAAA,EACF;AACA,EAAA,OAAO,KAAA;AACT;AAoBA,IAAM,WAAA,GAAc,kDAAA;AAMpB,IAAM,aAAA,GAA4D;AAAA;AAAA,EAEhE,EAAE,KAAA,EAAO,4BAAA,EAA8B,KAAA,EAAO,cAAA,EAAe;AAAA;AAAA;AAAA,EAG7D,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,SAAA,EAAU;AAAA;AAAA,EACxD,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,QAAA,EAAS;AAAA;AAAA,EACvD,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,YAAA,EAAa;AAAA;AAAA,EAC3D,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,UAAA,EAAW;AAAA;AAAA;AAAA,EAGzD,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,WAAA,EAAY;AAAA;AAAA,EAC1D,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,eAAA,EAAgB;AAAA;AAAA;AAAA,EAG9D,EAAE,KAAA,EAAO,mBAAA,EAA8B,KAAA,EAAO,YAAA,EAAa;AAAA;AAAA;AAAA,EAG3D,EAAE,KAAA,EAAO,wBAAA,EAA8B,KAAA,EAAO,SAAA,EAAU;AAAA;AAAA;AAAA,EAGxD,EAAE,KAAA,EAAO,oBAAA,EAA8B,KAAA,EAAO,WAAA,EAAY;AAAA;AAAA,EAC1D,EAAE,KAAA,EAAO,oBAAA,EAA8B,KAAA,EAAO,SAAA,EAAU;AAAA;AAAA,EACxD,EAAE,KAAA,EAAO,oBAAA,EAA8B,KAAA,EAAO,SAAA;AAAU;AAC1D,CAAA;AAGA,IAAM,eAAA,GAAkB,WAAA;AAGxB,IAAM,qBAAA,GAAwB,kBAAA;AAO9B,SAAS,aAAA,CACP,IAAA,EACA,KAAA,EACA,aAAA,EACM;AACN,EAAA,IAAI,SAAA,GAAY,KAAK,IAAA,EAAK;AAG1B,EAAA,MAAM,UAAA,GAAa,gBAAA,CAAiB,SAAA,EAAW,KAAA,EAAO,aAAa,CAAA;AACnE,EAAA,IAAI,CAAC,UAAA,IAAc,UAAA,CAAW,GAAA,CAAI,WAAW,CAAA,EAAG;AAEhD,EAAA,SAAA,GAAY,UAAA,CAAW,UAAU,IAAA,EAAK;AACtC,EAAA,IAAI,eAAe,UAAA,CAAW,GAAA;AAG9B,EAAA,OAAO,SAAA,CAAU,SAAS,CAAA,EAAG;AAC3B,IAAA,MAAM,UAAA,GAAa,SAAA,CAAU,KAAA,CAAM,WAAW,CAAA;AAC9C,IAAA,IAAI,CAAC,UAAA,EAAY;AAEjB,IAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAC,CAAA;AAC3C,IAAA,MAAM,OAAA,GAAU,WAAW,CAAC,CAAA;AAC5B,IAAA,MAAM,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,EAAG,MAAK,IAAK,MAAA;AAC3C,IAAA,SAAA,GAAY,UAAU,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA,CAAE,MAAM,EAAE,IAAA,EAAK;AAEvD,IAAA,MAAM,KAAA,GAAQ,iBAAiB,OAAO,CAAA;AACtC,IAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,QAAA,CAAS,GAAG,CAAA;AAGxC,IAAA,MAAM,SAAA,GAAY,gBAAA,CAAiB,SAAA,EAAW,KAAA,EAAO,aAAa,CAAA;AAClE,IAAA,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,GAAA,CAAI,WAAW,CAAA,EAAG;AAE9C,IAAA,SAAA,GAAY,SAAA,CAAU,UAAU,IAAA,EAAK;AAGrC,IAAA,KAAA,MAAW,YAAY,YAAA,EAAc;AACnC,MAAA,KAAA,MAAW,QAAA,IAAY,UAAU,GAAA,EAAK;AACpC,QAAA,KAAA,CAAM,MAAM,IAAA,CAAK;AAAA,UACf,MAAA,EAAQ,QAAA;AAAA,UACR,MAAA,EAAQ,QAAA;AAAA,UACR,KAAA,EAAO,SAAA;AAAA,UACP,KAAA;AAAA,UACA,aAAA;AAAA,UACA;AAAA,SACD,CAAA;AAAA,MACH;AAAA,IACF;AAEA,IAAA,YAAA,GAAe,SAAA,CAAU,GAAA;AAAA,EAC3B;AACF;AAWA,SAAS,gBAAA,CACP,IAAA,EACA,KAAA,EACA,aAAA,EAC0B;AAC1B,EAAA,MAAM,KAAA,GAAQ,WAAA,CAAY,IAAA,EAAM,KAAA,EAAO,aAAa,CAAA;AACpD,EAAA,IAAI,CAAC,OAAO,OAAO,IAAA;AAEnB,EAAA,MAAM,GAAA,GAAM,CAAC,KAAA,CAAM,EAAE,CAAA;AACrB,EAAA,IAAI,SAAA,GAAY,KAAA,CAAM,SAAA,CAAU,IAAA,EAAK;AAGrC,EAAA,OAAO,SAAA,CAAU,UAAA,CAAW,GAAG,CAAA,EAAG;AAChC,IAAA,SAAA,GAAY,SAAA,CAAU,KAAA,CAAM,CAAC,CAAA,CAAE,IAAA,EAAK;AACpC,IAAA,MAAM,IAAA,GAAO,WAAA,CAAY,SAAA,EAAW,KAAA,EAAO,aAAa,CAAA;AACxD,IAAA,IAAI,CAAC,IAAA,EAAM;AACX,IAAA,GAAA,CAAI,IAAA,CAAK,KAAK,EAAE,CAAA;AAChB,IAAA,SAAA,GAAY,IAAA,CAAK,UAAU,IAAA,EAAK;AAAA,EAClC;AAEA,EAAA,OAAO,EAAE,KAAK,SAAA,EAAU;AAC1B;AAaA,SAAS,WAAA,CACP,IAAA,EACA,KAAA,EACA,aAAA,EACqB;AACrB,EAAA,IAAI,EAAA,GAAoB,IAAA;AACxB,EAAA,IAAI,SAAA,GAAoB,IAAA;AAGxB,EAAA,KAAA,MAAW,EAAE,KAAA,EAAO,KAAA,EAAM,IAAK,aAAA,EAAe;AAC5C,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;AAC9B,IAAA,IAAI,KAAA,EAAO;AACT,MAAA,EAAA,GAAK,MAAM,CAAC,CAAA;AACZ,MAAA,MAAM,KAAA,GAAQ,MAAM,CAAC,CAAA;AACrB,MAAA,YAAA,CAAa,OAAO,aAAA,EAAe,EAAE,EAAA,EAAI,KAAA,EAAO,OAAO,CAAA;AACvD,MAAA,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,CAAC,EAAE,MAAM,CAAA;AACtC,MAAA;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,OAAO,IAAA,EAAM;AACf,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,eAAe,CAAA;AAC5C,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,EAAA,GAAK,UAAU,CAAC,CAAA;AAChB,MAAA,IAAI,CAAC,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,EAAE,CAAA,EAAG;AACxB,QAAA,YAAA,CAAa,KAAA,EAAO,eAAe,EAAE,EAAA,EAAI,OAAO,EAAA,EAAI,KAAA,EAAO,aAAa,CAAA;AAAA,MAC1E,CAAA,MAAO;AACL,QAAA,eAAA,CAAgB,eAAe,EAAE,CAAA;AAAA,MACnC;AACA,MAAA,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,SAAA,CAAU,CAAC,EAAE,MAAM,CAAA;AAAA,IAC5C;AAAA,EACF;AAEA,EAAA,IAAI,EAAA,KAAO,MAAM,OAAO,IAAA;AAGxB,EAAA,MAAM,UAAA,GAAa,SAAA,CAAU,KAAA,CAAM,qBAAqB,CAAA;AACxD,EAAA,IAAI,UAAA,EAAY;AACd,IAAA,KAAA,CAAM,gBAAA,CAAiB,GAAA,CAAI,EAAA,EAAI,UAAA,CAAW,CAAC,CAAE,CAAA;AAC7C,IAAA,SAAA,GAAY,SAAA,CAAU,KAAA,CAAM,UAAA,CAAW,CAAC,EAAE,MAAM,CAAA;AAAA,EAClD;AAEA,EAAA,OAAO,EAAE,IAAI,SAAA,EAAU;AACzB;AAGA,SAAS,YAAA,CACP,KAAA,EACA,aAAA,EACA,IAAA,EACM;AACN,EAAA,MAAM,QAAQ,CAAC,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,KAAK,EAAE,CAAA;AACtC,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,EAAA,EAAI,IAAI,CAAA;AAAA,EAC/B;AACA,EAAA,eAAA,CAAgB,aAAA,EAAe,KAAK,EAAE,CAAA;AACxC;AAGA,SAAS,eAAA,CAAgB,eAAkC,MAAA,EAAsB;AAC/E,EAAA,IAAI,aAAA,CAAc,SAAS,CAAA,EAAG;AAC5B,IAAA,MAAM,OAAA,GAAU,aAAA,CAAc,aAAA,CAAc,MAAA,GAAS,CAAC,CAAA;AACtD,IAAA,IAAI,CAAC,OAAA,CAAQ,OAAA,CAAQ,QAAA,CAAS,MAAM,CAAA,EAAG;AACrC,MAAA,OAAA,CAAQ,OAAA,CAAQ,KAAK,MAAM,CAAA;AAAA,IAC7B;AAAA,EACF;AACF;AAGA,SAAS,iBAAiB,EAAA,EAAuB;AAC/C,EAAA,IAAI,EAAA,KAAO,QAAQ,OAAO,QAAA;AAC1B,EAAA,IAAI,EAAA,KAAO,OAAO,OAAO,QAAA;AACzB,EAAA,IAAI,EAAA,KAAO,OAAO,OAAO,OAAA;AACzB,EAAA,IAAI,EAAA,KAAO,OAAO,OAAO,OAAA;AAEzB,EAAA,OAAO,OAAA;AACT;;;AC/gBO,IAAM,EAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,IAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,IAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,KAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,UAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,SAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,UAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,SAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC3C,IAAM,MAAA,GAAwB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AA2F3C,SAAS,eAAA,CAAgB,GAAc,CAAA,EAAuB;AACnE,EAAA,OAAO,EAAE,CAAA,KAAM,CAAA,CAAE,CAAA,IAAK,CAAA,CAAE,MAAM,CAAA,CAAE,CAAA;AAClC;AAEO,SAAS,kBAAA,CAAmB,GAAiB,CAAA,EAA0B;AAC5E,EAAA,OAAO,EAAE,CAAA,KAAM,CAAA,CAAE,CAAA,IAAK,CAAA,CAAE,MAAM,CAAA,CAAE,CAAA;AAClC;AAGO,SAAS,kBAAA,CAAmB,GAAc,GAAA,EAA2B;AAC1E,EAAA,OAAO,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,GAAA,CAAI,GAAG,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,GAAA,CAAI,CAAA,EAAE;AAC1C;AAGO,SAAS,QAAQ,CAAA,EAAsB;AAC5C,EAAA,OAAO,CAAA,EAAG,CAAA,CAAE,CAAC,CAAA,CAAA,EAAI,EAAE,CAAC,CAAA,CAAA;AACtB;AAGO,IAAM,cAA+B,EAAE,IAAA,EAAM,EAAA,EAAI,MAAA,EAAQ,EAAC,EAAE;;;AC1I5D,SAAS,QAAA,CAAS,GAAW,CAAA,EAAmB;AACrD,EAAA,MAAM,SAAiB,EAAC;AACxB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;AAC3B,IAAA,MAAM,MAAgB,EAAC;AACvB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;AAC3B,MAAA,GAAA,CAAI,KAAK,GAAG,CAAA;AAAA,IACd;AACA,IAAA,MAAA,CAAO,KAAK,GAAG,CAAA;AAAA,EACjB;AACA,EAAA,OAAO,MAAA;AACT;AAGO,SAAS,WAAW,MAAA,EAAwB;AACjD,EAAA,MAAM,CAAC,IAAA,EAAM,IAAI,CAAA,GAAI,cAAc,MAAM,CAAA;AACzC,EAAA,OAAO,QAAA,CAAS,MAAM,IAAI,CAAA;AAC5B;AAGO,SAAS,cAAc,MAAA,EAAkC;AAC9D,EAAA,OAAO,CAAC,OAAO,MAAA,GAAS,CAAA,EAAA,CAAI,OAAO,CAAC,CAAA,EAAG,MAAA,IAAU,CAAA,IAAK,CAAC,CAAA;AACzD;AAMO,SAAS,YAAA,CAAa,MAAA,EAAgB,IAAA,EAAc,IAAA,EAAsB;AAC/E,EAAA,MAAM,CAAC,KAAA,EAAO,KAAK,CAAA,GAAI,cAAc,MAAM,CAAA;AAC3C,EAAA,MAAM,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAK,CAAA;AACpC,EAAA,MAAM,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAK,CAAA;AACpC,EAAA,MAAM,KAAA,GAAQ,QAAA,CAAS,OAAA,EAAS,OAAO,CAAA;AACvC,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,MAAM,CAAC,CAAA,CAAG,QAAQ,CAAA,EAAA,EAAK;AACzC,MAAA,IAAI,IAAI,MAAA,CAAO,MAAA,IAAU,IAAI,MAAA,CAAO,CAAC,EAAG,MAAA,EAAQ;AAC9C,QAAA,KAAA,CAAM,CAAC,CAAA,CAAG,CAAC,IAAI,MAAA,CAAO,CAAC,EAAG,CAAC,CAAA;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAEA,EAAA,MAAA,CAAO,MAAA,GAAS,CAAA;AAChB,EAAA,MAAA,CAAO,IAAA,CAAK,GAAG,KAAK,CAAA;AACpB,EAAA,OAAO,MAAA;AACT;AAOA,IAAM,cAAA,uBAAqB,GAAA,CAAI;AAAA,EAC7B,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK,QAAA;AAAA,EAAK;AACxE,CAAC,CAAA;AAEM,SAAS,eAAe,CAAA,EAAoB;AACjD,EAAA,OAAO,cAAA,CAAe,IAAI,CAAC,CAAA;AAC7B;AAOA,IAAM,YAAA,GAAuD;AAAA,EAC3D,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAI;AAAA,EAChG,UAAK,EAAE,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA,EAAK,QAAA,EAAK,UAAK,QAAA;AAC9F,CAAA;AAEO,SAAS,cAAA,CAAe,IAAY,EAAA,EAAoB;AAC7D,EAAA,OAAO,YAAA,CAAa,EAAE,CAAA,GAAI,EAAE,CAAA,IAAK,EAAA;AACnC;AAWO,SAAS,aAAA,CACd,IAAA,EACA,MAAA,EACA,QAAA,EAAA,GACG,QAAA,EACK;AACR,EAAA,IAAI,CAAC,IAAA,EAAM,IAAI,CAAA,GAAI,cAAc,IAAI,CAAA;AACrC,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,MAAM,CAAC,EAAA,EAAI,EAAE,CAAA,GAAI,cAAc,OAAO,CAAA;AACtC,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,EAAA,GAAK,OAAO,CAAC,CAAA;AACnC,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,EAAA,GAAK,OAAO,CAAC,CAAA;AAAA,EACrC;AAEA,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,IAAA,EAAM,IAAI,CAAA;AAGlC,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AAC9B,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AAC9B,MAAA,IAAI,IAAI,IAAA,CAAK,MAAA,IAAU,IAAI,IAAA,CAAK,CAAC,EAAG,MAAA,EAAQ;AAC1C,QAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,IAAI,IAAA,CAAK,CAAC,EAAG,CAAC,CAAA;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,QAAQ,CAAA,EAAA,EAAK;AACvC,MAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,QAAQ,CAAC,CAAA,CAAG,QAAQ,CAAA,EAAA,EAAK;AAC3C,QAAA,MAAM,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,CAAG,CAAC,CAAA;AACvB,QAAA,IAAI,MAAM,GAAA,EAAK;AACb,UAAA,MAAM,EAAA,GAAK,IAAI,MAAA,CAAO,CAAA;AACtB,UAAA,MAAM,EAAA,GAAK,IAAI,MAAA,CAAO,CAAA;AACtB,UAAA,MAAM,OAAA,GAAU,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA;AAC9B,UAAA,IAAI,CAAC,QAAA,IAAY,cAAA,CAAe,CAAC,CAAA,IAAK,cAAA,CAAe,OAAO,CAAA,EAAG;AAC7D,YAAA,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,cAAA,CAAe,SAAS,CAAC,CAAA;AAAA,UAC7C,CAAA,MAAO;AACL,YAAA,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,CAAA;AAAA,UACpB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAOO,SAAS,eAAe,MAAA,EAAwB;AACrD,EAAA,MAAM,CAAC,IAAA,EAAM,IAAI,CAAA,GAAI,cAAc,MAAM,CAAA;AACzC,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AAC9B,IAAA,IAAI,IAAA,GAAO,EAAA;AACX,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AAC9B,MAAA,IAAA,IAAQ,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA;AAAA,IACtB;AACA,IAAA,KAAA,CAAM,KAAK,IAAI,CAAA;AAAA,EACjB;AACA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAcA,IAAM,iBAAA,GAA4C;AAAA;AAAA,EAEhD,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK,QAAA;AAAA,EACf,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK,QAAA;AAAA,EACf,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK,QAAA;AAAA;AAAA,EAEf,GAAA,EAAK,GAAA;AAAA,EAAK,GAAA,EAAK,GAAA;AAAA;AAAA,EAEf,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK,QAAA;AAAA,EACf,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK,QAAA;AAAA;AAAA,EAEf,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK,QAAA;AAAA;AAAA,EAEf,QAAA,EAAK,QAAA;AAAA,EAAK,QAAA,EAAK;AACjB,CAAA;AAUO,SAAS,qBAAqB,MAAA,EAAwB;AAE3D,EAAA,KAAA,MAAW,OAAO,MAAA,EAAQ;AACxB,IAAA,GAAA,CAAI,OAAA,EAAQ;AAAA,EACd;AAGA,EAAA,KAAA,MAAW,OAAO,MAAA,EAAQ;AACxB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,QAAQ,CAAA,EAAA,EAAK;AACnC,MAAA,MAAM,OAAA,GAAU,iBAAA,CAAkB,GAAA,CAAI,CAAC,CAAE,CAAA;AACzC,MAAA,IAAI,OAAA,EAAS,GAAA,CAAI,CAAC,CAAA,GAAI,OAAA;AAAA,IACxB;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAGO,SAAS,QAAA,CAAS,MAAA,EAAgB,KAAA,EAAqB,IAAA,EAAoB;AAChF,EAAA,YAAA,CAAa,QAAQ,KAAA,CAAM,CAAA,GAAI,IAAA,CAAK,MAAA,EAAQ,MAAM,CAAC,CAAA;AACnD,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAQ,CAAA,EAAA,EAAK;AACpC,IAAA,MAAA,CAAO,KAAA,CAAM,IAAI,CAAC,CAAA,CAAG,MAAM,CAAC,CAAA,GAAI,KAAK,CAAC,CAAA;AAAA,EACxC;AACF;AAMO,SAAS,mBAAA,CACd,MAAA,EACA,WAAA,EACA,SAAA,EACM;AACN,EAAA,IAAI,IAAA,GAAO,CAAA;AACX,EAAA,IAAI,IAAA,GAAO,CAAA;AACX,EAAA,KAAA,MAAW,CAAA,IAAK,WAAA,CAAY,MAAA,EAAO,EAAG,IAAA,IAAQ,CAAA;AAC9C,EAAA,KAAA,MAAW,CAAA,IAAK,SAAA,CAAU,MAAA,EAAO,EAAG,IAAA,IAAQ,CAAA;AAC5C,EAAA,YAAA,CAAa,MAAA,EAAQ,IAAA,GAAO,CAAA,EAAG,IAAA,GAAO,CAAC,CAAA;AACzC;;;AC1NO,SAAS,mBAAA,CAAoB,QAAsB,MAAA,EAAiC;AAEzF,EAAA,MAAM,OAAA,uBAAc,GAAA,EAAuB;AAC3C,EAAA,IAAI,KAAA,GAAQ,CAAA;AAEZ,EAAA,KAAA,MAAW,CAAC,EAAA,EAAI,KAAK,CAAA,IAAK,OAAO,KAAA,EAAO;AACtC,IAAA,MAAM,SAAA,GAAuB;AAAA;AAAA;AAAA,MAG3B,IAAA,EAAM,EAAA;AAAA;AAAA,MAEN,cAAc,KAAA,CAAM,KAAA;AAAA,MACpB,KAAA;AAAA,MACA,SAAA,EAAW,IAAA;AAAA,MACX,YAAA,EAAc,IAAA;AAAA,MACd,OAAA,EAAS,IAAA;AAAA,MACT,KAAA,EAAO,KAAA;AAAA,MACP,cAAA,EAAgB,EAAA;AAAA,MAChB,UAAA,EAAY;AAAA,KACd;AACA,IAAA,OAAA,CAAQ,GAAA,CAAI,IAAI,SAAS,CAAA;AACzB,IAAA,KAAA,EAAA;AAAA,EACF;AAEA,EAAA,MAAM,KAAA,GAAQ,CAAC,GAAG,OAAA,CAAQ,QAAQ,CAAA;AAGlC,EAAA,MAAM,QAAqB,EAAC;AAC5B,EAAA,KAAA,MAAW,KAAA,IAAS,OAAO,KAAA,EAAO;AAChC,IAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,GAAA,CAAI,KAAA,CAAM,MAAM,CAAA;AACrC,IAAA,MAAM,EAAA,GAAK,OAAA,CAAQ,GAAA,CAAI,KAAA,CAAM,MAAM,CAAA;AACnC,IAAA,IAAI,CAAC,IAAA,IAAQ,CAAC,EAAA,EAAI;AAElB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,MACT,IAAA;AAAA,MACA,EAAA;AAAA,MACA,IAAA,EAAM,MAAM,KAAA,IAAS,EAAA;AAAA,MACrB,MAAM,EAAC;AAAA,MACP,WAAW,EAAC;AAAA,MACZ,QAAA,EAAU,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAAA,MACvB,MAAA,EAAQ,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA;AAAE,KACtB,CAAA;AAAA,EACH;AAGA,EAAA,MAAM,YAA6B,EAAC;AACpC,EAAA,KAAA,MAAW,GAAA,IAAO,OAAO,SAAA,EAAW;AAClC,IAAA,eAAA,CAAgB,GAAA,EAAK,IAAA,EAAM,OAAA,EAAS,SAAS,CAAA;AAAA,EAC/C;AAMA,EAAA,wBAAA,CAAyB,MAAA,CAAO,SAAA,EAAW,SAAA,EAAW,OAAe,CAAA;AAGrE,EAAA,KAAA,MAAW,CAAC,MAAA,EAAQ,SAAS,CAAA,IAAK,OAAO,gBAAA,EAAkB;AACzD,IAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA;AAC/B,IAAA,MAAM,QAAA,GAAW,MAAA,CAAO,SAAA,CAAU,GAAA,CAAI,SAAS,CAAA;AAC/C,IAAA,IAAI,QAAQ,QAAA,EAAU;AACpB,MAAA,IAAA,CAAK,cAAA,GAAiB,SAAA;AACtB,MAAA,IAAA,CAAK,UAAA,GAAa,EAAE,IAAA,EAAM,SAAA,EAAW,QAAQ,QAAA,EAAS;AAAA,IACxD;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,KAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA,EAAQ,QAAA,CAAS,CAAA,EAAG,CAAC,CAAA;AAAA,IACrB,IAAA,sBAAU,GAAA,EAAI;AAAA,IACd,WAAA,sBAAiB,GAAA,EAAI;AAAA,IACrB,SAAA,sBAAe,GAAA,EAAI;AAAA,IACnB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA,EAAS,CAAA;AAAA,IACT,OAAA,EAAS;AAAA,GACX;AACF;AAQA,SAAS,eAAA,CACP,GAAA,EACA,MAAA,EACA,OAAA,EACA,YAAA,EACe;AACf,EAAA,MAAM,EAAA,GAAoB;AAAA,IACxB,MAAM,GAAA,CAAI,KAAA;AAAA,IACV,OAAO,EAAC;AAAA,IACR,MAAA;AAAA,IACA,UAAU,EAAC;AAAA,IACX,IAAA,EAAM,CAAA;AAAA,IAAG,IAAA,EAAM,CAAA;AAAA,IAAG,IAAA,EAAM,CAAA;AAAA,IAAG,IAAA,EAAM;AAAA,GACnC;AAGA,EAAA,KAAA,MAAW,MAAA,IAAU,IAAI,OAAA,EAAS;AAChC,IAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA;AAC/B,IAAA,IAAI,IAAA,EAAM,EAAA,CAAG,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;AAAA,EAC9B;AAEA,EAAA,YAAA,CAAa,KAAK,EAAE,CAAA;AAGpB,EAAA,KAAA,MAAW,QAAA,IAAY,IAAI,QAAA,EAAU;AACnC,IAAA,MAAM,KAAA,GAAQ,eAAA,CAAgB,QAAA,EAAU,EAAA,EAAI,SAAS,YAAY,CAAA;AACjE,IAAA,EAAA,CAAG,QAAA,CAAS,KAAK,KAAK,CAAA;AAKtB,IAAA,KAAA,MAAW,SAAA,IAAa,MAAM,KAAA,EAAO;AACnC,MAAA,IAAI,CAAC,EAAA,CAAG,KAAA,CAAM,QAAA,CAAS,SAAS,CAAA,EAAG;AACjC,QAAA,EAAA,CAAG,KAAA,CAAM,KAAK,SAAS,CAAA;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,EAAA;AACT;AAcA,SAAS,wBAAA,CACP,gBAAA,EACA,cAAA,EACA,OAAA,EACA,MAAA,EACM;AAGN,EAAA,MAAM,KAAA,uBAAY,GAAA,EAAoC;AACtD,EAAA,UAAA,CAAW,gBAAA,EAAkB,gBAAgB,KAAK,CAAA;AAMlD,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAA2B;AAIjD,EAAA,SAAS,WAAW,GAAA,EAA4B;AAC9C,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC7B,IAAA,IAAI,CAAC,OAAA,EAAS;AAMd,IAAA,KAAA,MAAW,KAAA,IAAS,IAAI,QAAA,EAAU;AAChC,MAAA,UAAA,CAAW,KAAK,CAAA;AAAA,IAClB;AAGA,IAAA,KAAA,MAAW,MAAA,IAAU,IAAI,OAAA,EAAS;AAChC,MAAA,IAAI,CAAC,SAAA,CAAU,GAAA,CAAI,MAAM,CAAA,EAAG;AAC1B,QAAA,SAAA,CAAU,GAAA,CAAI,QAAQ,OAAO,CAAA;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAEA,EAAA,KAAA,MAAW,OAAO,gBAAA,EAAkB;AAClC,IAAA,UAAA,CAAW,GAAG,CAAA;AAAA,EAChB;AAIA,EAAA,KAAA,MAAW,WAAW,cAAA,EAAgB;AACpC,IAAA,OAAA,CAAQ,KAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,MAAA,CAAO,CAAA,IAAA,KAAQ;AAE3C,MAAA,IAAI,MAAA;AACJ,MAAA,KAAA,MAAW,CAAC,EAAA,EAAI,CAAC,CAAA,IAAK,OAAA,EAAS;AAC7B,QAAA,IAAI,MAAM,IAAA,EAAM;AAAE,UAAA,MAAA,GAAS,EAAA;AAAI,UAAA;AAAA,QAAM;AAAA,MACvC;AACA,MAAA,IAAI,CAAC,QAAQ,OAAO,KAAA;AAEpB,MAAA,MAAM,KAAA,GAAQ,SAAA,CAAU,GAAA,CAAI,MAAM,CAAA;AAClC,MAAA,IAAI,CAAC,OAAO,OAAO,IAAA;AAGnB,MAAA,OAAO,gBAAA,CAAiB,SAAS,KAAK,CAAA;AAAA,IACxC,CAAC,CAAA;AAAA,EACH;AACF;AAGA,SAAS,gBAAA,CAAiB,WAA0B,MAAA,EAAgC;AAClF,EAAA,IAAI,OAAA,GAAgC,MAAA;AACpC,EAAA,OAAO,YAAY,IAAA,EAAM;AACvB,IAAA,IAAI,OAAA,KAAY,WAAW,OAAO,IAAA;AAClC,IAAA,OAAA,GAAU,OAAA,CAAQ,MAAA;AAAA,EACpB;AACA,EAAA,OAAO,KAAA;AACT;AAGA,SAAS,UAAA,CACP,IAAA,EACA,IAAA,EACA,MAAA,EACM;AAIN,EAAA,MAAM,cAAiC,EAAC;AACxC,EAAA,SAAS,QAAQ,GAAA,EAA8B;AAC7C,IAAA,KAAA,MAAW,MAAM,GAAA,EAAK;AACpB,MAAA,WAAA,CAAY,KAAK,EAAE,CAAA;AACnB,MAAA,OAAA,CAAQ,GAAG,QAAQ,CAAA;AAAA,IACrB;AAAA,EACF;AACA,EAAA,OAAA,CAAQ,IAAI,CAAA;AAEZ,EAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,WAAA,CAAY,UAAU,CAAA,GAAI,IAAA,CAAK,QAAQ,CAAA,EAAA,EAAK;AAC9D,IAAA,MAAA,CAAO,IAAI,WAAA,CAAY,CAAC,CAAA,EAAI,IAAA,CAAK,CAAC,CAAE,CAAA;AAAA,EACtC;AACF;;;ACxOA,IAAM,UAAN,MAAc;AAAA,EACJ,QAAkB,EAAC;AAAA,EAE3B,IAAI,MAAA,GAAiB;AACnB,IAAA,OAAO,KAAK,KAAA,CAAM,MAAA;AAAA,EACpB;AAAA,EAEA,KAAK,IAAA,EAAoB;AACvB,IAAA,IAAA,CAAK,KAAA,CAAM,KAAK,IAAI,CAAA;AACpB,IAAA,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA;AAAA,EACrC;AAAA,EAEA,GAAA,GAA0B;AACxB,IAAA,IAAI,IAAA,CAAK,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG,OAAO,MAAA;AACpC,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;AACxB,IAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,EAAI;AAC5B,IAAA,IAAI,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;AACzB,MAAA,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,GAAI,IAAA;AAChB,MAAA,IAAA,CAAK,SAAS,CAAC,CAAA;AAAA,IACjB;AACA,IAAA,OAAO,GAAA;AAAA,EACT;AAAA,EAEQ,SAAS,CAAA,EAAiB;AAChC,IAAA,OAAO,IAAI,CAAA,EAAG;AACZ,MAAA,MAAM,MAAA,GAAU,IAAI,CAAA,IAAM,CAAA;AAC1B,MAAA,IAAI,IAAA,CAAK,MAAM,CAAC,CAAA,CAAG,WAAW,IAAA,CAAK,KAAA,CAAM,MAAM,CAAA,CAAG,QAAA,EAAU;AACzD,QAAA,CAAC,KAAK,KAAA,CAAM,CAAC,CAAA,EAAG,IAAA,CAAK,MAAM,MAAM,CAAC,CAAA,GAAI,CAAC,KAAK,KAAA,CAAM,MAAM,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAE,CAAA;AAC3E,QAAA,CAAA,GAAI,MAAA;AAAA,MACN,CAAA,MAAO;AACL,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,SAAS,CAAA,EAAiB;AAChC,IAAA,MAAM,CAAA,GAAI,KAAK,KAAA,CAAM,MAAA;AACrB,IAAA,OAAO,IAAA,EAAM;AACX,MAAA,IAAI,QAAA,GAAW,CAAA;AACf,MAAA,MAAM,IAAA,GAAO,IAAI,CAAA,GAAI,CAAA;AACrB,MAAA,MAAM,KAAA,GAAQ,IAAI,CAAA,GAAI,CAAA;AACtB,MAAA,IAAI,IAAA,GAAO,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA,CAAG,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,QAAQ,CAAA,CAAG,QAAA,EAAU;AAC3E,QAAA,QAAA,GAAW,IAAA;AAAA,MACb;AACA,MAAA,IAAI,KAAA,GAAQ,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA,CAAG,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,QAAQ,CAAA,CAAG,QAAA,EAAU;AAC7E,QAAA,QAAA,GAAW,KAAA;AAAA,MACb;AACA,MAAA,IAAI,aAAa,CAAA,EAAG;AACjB,QAAA,CAAC,KAAK,KAAA,CAAM,CAAC,CAAA,EAAG,IAAA,CAAK,MAAM,QAAQ,CAAC,CAAA,GAAI,CAAC,KAAK,KAAA,CAAM,QAAQ,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAE,CAAA;AAC/E,QAAA,CAAA,GAAI,QAAA;AAAA,MACN,CAAA,MAAO;AACL,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF,CAAA;AAUO,SAAS,SAAA,CAAU,GAAc,CAAA,EAAsB;AAC5D,EAAA,MAAM,OAAO,IAAA,CAAK,GAAA,CAAI,CAAA,CAAE,CAAA,GAAI,EAAE,CAAC,CAAA;AAC/B,EAAA,MAAM,OAAO,IAAA,CAAK,GAAA,CAAI,CAAA,CAAE,CAAA,GAAI,EAAE,CAAC,CAAA;AAC/B,EAAA,IAAI,IAAA,KAAS,CAAA,IAAK,IAAA,KAAS,CAAA,EAAG;AAC5B,IAAA,OAAO,IAAA,GAAO,IAAA;AAAA,EAChB;AACA,EAAA,OAAO,OAAO,IAAA,GAAO,CAAA;AACvB;AAOA,IAAM,SAAA,GAAyB;AAAA,EAC7B,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAE;AAAA,EACb,EAAE,CAAA,EAAG,EAAA,EAAI,CAAA,EAAG,CAAA,EAAE;AAAA,EACd,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAE;AAAA,EACb,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,EAAA;AACb,CAAA;AAGA,SAAS,YAAA,CAAa,MAA8B,CAAA,EAAuB;AACzE,EAAA,IAAI,EAAE,CAAA,GAAI,CAAA,IAAK,CAAA,CAAE,CAAA,GAAI,GAAG,OAAO,KAAA;AAC/B,EAAA,OAAO,CAAC,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAC,CAAA;AAC7B;AAMO,SAAS,OAAA,CACd,IAAA,EACA,IAAA,EACA,EAAA,EACoB;AACpB,EAAA,MAAM,EAAA,GAAK,IAAI,OAAA,EAAQ;AACvB,EAAA,EAAA,CAAG,KAAK,EAAE,KAAA,EAAO,IAAA,EAAM,QAAA,EAAU,GAAG,CAAA;AAEpC,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAoB;AAC1C,EAAA,SAAA,CAAU,GAAA,CAAI,OAAA,CAAQ,IAAI,CAAA,EAAG,CAAC,CAAA;AAE9B,EAAA,MAAM,QAAA,uBAAe,GAAA,EAA8B;AACnD,EAAA,QAAA,CAAS,GAAA,CAAI,OAAA,CAAQ,IAAI,CAAA,EAAG,IAAI,CAAA;AAEhC,EAAA,OAAO,EAAA,CAAG,SAAS,CAAA,EAAG;AACpB,IAAA,MAAM,OAAA,GAAU,EAAA,CAAG,GAAA,EAAI,CAAG,KAAA;AAE1B,IAAA,IAAI,eAAA,CAAgB,OAAA,EAAS,EAAE,CAAA,EAAG;AAEhC,MAAA,MAAM,OAAoB,EAAC;AAC3B,MAAA,IAAI,CAAA,GAAsB,OAAA;AAC1B,MAAA,OAAO,MAAM,IAAA,EAAM;AACjB,QAAA,IAAA,CAAK,QAAQ,CAAC,CAAA;AACd,QAAA,CAAA,GAAI,QAAA,CAAS,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAC,CAAA,IAAK,IAAA;AAAA,MAClC;AACA,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,MAAM,WAAA,GAAc,SAAA,CAAU,GAAA,CAAI,OAAA,CAAQ,OAAO,CAAC,CAAA;AAElD,IAAA,KAAA,MAAW,OAAO,SAAA,EAAW;AAC3B,MAAA,MAAM,IAAA,GAAkB,EAAE,CAAA,EAAG,OAAA,CAAQ,CAAA,GAAI,GAAA,CAAI,CAAA,EAAG,CAAA,EAAG,OAAA,CAAQ,CAAA,GAAI,GAAA,CAAI,CAAA,EAAE;AAGrE,MAAA,IAAI,CAAC,aAAa,IAAA,EAAM,IAAI,KAAK,CAAC,eAAA,CAAgB,IAAA,EAAM,EAAE,CAAA,EAAG;AAC3D,QAAA;AAAA,MACF;AAEA,MAAA,MAAM,UAAU,WAAA,GAAc,CAAA;AAC9B,MAAA,MAAM,OAAA,GAAU,QAAQ,IAAI,CAAA;AAC5B,MAAA,MAAM,YAAA,GAAe,SAAA,CAAU,GAAA,CAAI,OAAO,CAAA;AAE1C,MAAA,IAAI,YAAA,KAAiB,MAAA,IAAa,OAAA,GAAU,YAAA,EAAc;AACxD,QAAA,SAAA,CAAU,GAAA,CAAI,SAAS,OAAO,CAAA;AAC9B,QAAA,MAAM,QAAA,GAAW,OAAA,GAAU,SAAA,CAAU,IAAA,EAAM,EAAE,CAAA;AAC7C,QAAA,EAAA,CAAG,IAAA,CAAK,EAAE,KAAA,EAAO,IAAA,EAAM,UAAU,CAAA;AACjC,QAAA,QAAA,CAAS,GAAA,CAAI,SAAS,OAAO,CAAA;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAAS,UAAU,IAAA,EAAgC;AACxD,EAAA,IAAI,IAAA,CAAK,MAAA,IAAU,CAAA,EAAG,OAAO,IAAA;AAE7B,EAAA,MAAM,QAAA,uBAAe,GAAA,EAAY;AACjC,EAAA,IAAI,KAAA,GAAQ,KAAK,CAAC,CAAA;AAClB,EAAA,IAAI,KAAA,GAAQ,KAAK,CAAC,CAAA;AAElB,EAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,GAAM,IAAA,CAAK,QAAQ,GAAA,EAAA,EAAO;AAC1C,IAAA,MAAM,KAAA,GAAQ,KAAK,GAAG,CAAA;AACtB,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,CAAA;AAC/B,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,CAAA;AAC/B,IAAA,MAAM,EAAA,GAAK,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,CAAA;AAC3B,IAAA,MAAM,EAAA,GAAK,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,CAAA;AAG3B,IAAA,IAAI,MAAA,KAAW,EAAA,IAAM,MAAA,KAAW,EAAA,EAAI;AAYlC,MAAA,QAAA,CAAS,GAAA,CAAI,MAAM,CAAC,CAAA;AAAA,IACtB;AAEA,IAAA,KAAA,GAAQ,KAAA;AACR,IAAA,KAAA,GAAQ,KAAA;AAAA,EACV;AAEA,EAAA,OAAO,IAAA,CAAK,OAAO,CAAC,CAAA,EAAG,MAAM,CAAC,QAAA,CAAS,GAAA,CAAI,CAAC,CAAC,CAAA;AAC/C;;;ACnMO,SAAS,YAAY,CAAA,EAAyB;AACnD,EAAA,IAAI,CAAA,KAAM,IAAI,OAAO,IAAA;AACrB,EAAA,IAAI,CAAA,KAAM,MAAM,OAAO,EAAA;AACvB,EAAA,IAAI,CAAA,KAAM,MAAM,OAAO,KAAA;AACvB,EAAA,IAAI,CAAA,KAAM,OAAO,OAAO,IAAA;AACxB,EAAA,IAAI,CAAA,KAAM,YAAY,OAAO,SAAA;AAC7B,EAAA,IAAI,CAAA,KAAM,WAAW,OAAO,UAAA;AAC5B,EAAA,IAAI,CAAA,KAAM,YAAY,OAAO,SAAA;AAC7B,EAAA,IAAI,CAAA,KAAM,WAAW,OAAO,UAAA;AAC5B,EAAA,OAAO,MAAA;AACT;AAGO,SAAS,SAAA,CAAU,GAAc,CAAA,EAAuB;AAC7D,EAAA,OAAO,EAAE,CAAA,KAAM,CAAA,CAAE,CAAA,IAAK,CAAA,CAAE,MAAM,CAAA,CAAE,CAAA;AAClC;AAMO,SAAS,kBAAA,CAAmB,MAAgC,EAAA,EAAyC;AAC1G,EAAA,IAAI,IAAA,CAAK,CAAA,KAAM,EAAA,CAAG,CAAA,EAAG;AACnB,IAAA,OAAO,IAAA,CAAK,CAAA,GAAI,EAAA,CAAG,CAAA,GAAI,IAAA,GAAO,EAAA;AAAA,EAChC,CAAA,MAAA,IAAW,IAAA,CAAK,CAAA,KAAM,EAAA,CAAG,CAAA,EAAG;AAC1B,IAAA,OAAO,IAAA,CAAK,CAAA,GAAI,EAAA,CAAG,CAAA,GAAI,KAAA,GAAQ,IAAA;AAAA,EACjC,CAAA,MAAA,IAAW,IAAA,CAAK,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG;AACxB,IAAA,OAAO,IAAA,CAAK,CAAA,GAAI,EAAA,CAAG,CAAA,GAAI,UAAA,GAAa,UAAA;AAAA,EACtC,CAAA,MAAO;AACL,IAAA,OAAO,IAAA,CAAK,CAAA,GAAI,EAAA,CAAG,CAAA,GAAI,SAAA,GAAY,SAAA;AAAA,EACrC;AACF;AAOA,SAAS,uBAAuB,cAAA,EAAsE;AACpG,EAAA,IAAI,mBAAmB,IAAA,EAAM,OAAO,CAAC,KAAA,EAAO,IAAA,EAAM,MAAM,KAAK,CAAA;AAC7D,EAAA,OAAO,CAAC,IAAA,EAAM,KAAA,EAAO,KAAA,EAAO,IAAI,CAAA;AAClC;AASO,SAAS,uBAAA,CACd,MACA,cAAA,EAC8C;AAC9C,EAAA,IAAI,KAAK,IAAA,KAAS,IAAA,CAAK,EAAA,EAAI,OAAO,uBAAuB,cAAc,CAAA;AAEvE,EAAA,MAAM,IAAI,kBAAA,CAAmB,IAAA,CAAK,KAAK,SAAA,EAAY,IAAA,CAAK,GAAG,SAAU,CAAA;AAErE,EAAA,IAAI,YAAA;AACJ,EAAA,IAAI,oBAAA;AACJ,EAAA,IAAI,cAAA;AACJ,EAAA,IAAI,sBAAA;AAEJ,EAAA,MAAM,WAAA,GAAc,cAAA,KAAmB,IAAA,GAClC,SAAA,CAAU,CAAA,EAAG,IAAI,CAAA,IAAK,SAAA,CAAU,CAAA,EAAG,SAAS,CAAA,IAAK,SAAA,CAAU,GAAG,SAAS,CAAA,GACvE,SAAA,CAAU,CAAA,EAAG,EAAE,CAAA,IAAK,SAAA,CAAU,CAAA,EAAG,SAAS,CAAA,IAAK,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA;AAE3E,EAAA,IAAI,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG;AAC5B,IAAA,IAAI,mBAAmB,IAAA,EAAM;AAC3B,MAAA,YAAA,GAAe,IAAA;AAAM,MAAA,oBAAA,GAAuB,IAAA;AAC5C,MAAA,cAAA,GAAiB,KAAA;AAAO,MAAA,sBAAA,GAAyB,EAAA;AAAA,IACnD,CAAA,MAAO;AACL,MAAA,YAAA,GAAe,KAAA;AAAO,MAAA,oBAAA,GAAuB,EAAA;AAC7C,MAAA,cAAA,GAAiB,IAAA;AAAM,MAAA,sBAAA,GAAyB,IAAA;AAAA,IAClD;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG;AACnC,IAAA,IAAI,mBAAmB,IAAA,EAAM;AAC3B,MAAA,YAAA,GAAe,EAAA;AAAI,MAAA,oBAAA,GAAuB,IAAA;AAC1C,MAAA,cAAA,GAAiB,KAAA;AAAO,MAAA,sBAAA,GAAyB,IAAA;AAAA,IACnD,CAAA,MAAO;AACL,MAAA,YAAA,GAAe,KAAA;AAAO,MAAA,oBAAA,GAAuB,IAAA;AAC7C,MAAA,cAAA,GAAiB,EAAA;AAAI,MAAA,sBAAA,GAAyB,IAAA;AAAA,IAChD;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,CAAA,EAAG,SAAS,CAAA,EAAG;AAClC,IAAA,IAAI,mBAAmB,IAAA,EAAM;AAC3B,MAAA,YAAA,GAAe,IAAA;AAAM,MAAA,oBAAA,GAAuB,IAAA;AAC5C,MAAA,cAAA,GAAiB,IAAA;AAAM,MAAA,sBAAA,GAAyB,EAAA;AAAA,IAClD,CAAA,MAAO;AACL,MAAA,YAAA,GAAe,IAAA;AAAM,MAAA,oBAAA,GAAuB,EAAA;AAC5C,MAAA,cAAA,GAAiB,IAAA;AAAM,MAAA,sBAAA,GAAyB,KAAA;AAAA,IAClD;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,CAAA,EAAG,SAAS,CAAA,EAAG;AAClC,IAAA,IAAI,mBAAmB,IAAA,EAAM;AAC3B,MAAA,YAAA,GAAe,IAAA;AAAM,MAAA,oBAAA,GAAuB,IAAA;AAC5C,MAAA,cAAA,GAAiB,IAAA;AAAM,MAAA,sBAAA,GAAyB,IAAA;AAAA,IAClD,CAAA,MAAO;AACL,MAAA,YAAA,GAAe,KAAA;AAAO,MAAA,oBAAA,GAAuB,KAAA;AAC7C,MAAA,cAAA,GAAiB,EAAA;AAAI,MAAA,sBAAA,GAAyB,KAAA;AAAA,IAChD;AAAA,EACF,WAAW,WAAA,EAAa;AACtB,IAAA,IAAI,cAAA,KAAmB,IAAA,IAAQ,SAAA,CAAU,CAAA,EAAG,IAAI,CAAA,EAAG;AACjD,MAAA,YAAA,GAAe,IAAA;AAAM,MAAA,oBAAA,GAAuB,IAAA;AAC5C,MAAA,cAAA,GAAiB,IAAA;AAAM,MAAA,sBAAA,GAAyB,KAAA;AAAA,IAClD,WAAW,cAAA,KAAmB,IAAA,IAAQ,SAAA,CAAU,CAAA,EAAG,EAAE,CAAA,EAAG;AACtD,MAAA,YAAA,GAAe,KAAA;AAAO,MAAA,oBAAA,GAAuB,KAAA;AAC7C,MAAA,cAAA,GAAiB,EAAA;AAAI,MAAA,sBAAA,GAAyB,IAAA;AAAA,IAChD,CAAA,MAAO;AACL,MAAA,YAAA,GAAe,CAAA;AAAG,MAAA,oBAAA,GAAuB,YAAY,CAAC,CAAA;AACtD,MAAA,cAAA,GAAiB,CAAA;AAAG,MAAA,sBAAA,GAAyB,YAAY,CAAC,CAAA;AAAA,IAC5D;AAAA,EACF,CAAA,MAAO;AAEL,IAAA,YAAA,GAAe,CAAA;AAAG,IAAA,oBAAA,GAAuB,YAAY,CAAC,CAAA;AACtD,IAAA,cAAA,GAAiB,CAAA;AAAG,IAAA,sBAAA,GAAyB,YAAY,CAAC,CAAA;AAAA,EAC5D;AAEA,EAAA,OAAO,CAAC,YAAA,EAAc,oBAAA,EAAsB,cAAA,EAAgB,sBAAsB,CAAA;AACpF;AAUO,SAAS,aAAA,CAAc,OAAmB,IAAA,EAAuB;AACtE,EAAA,MAAM,CAAC,YAAA,EAAc,oBAAA,EAAsB,cAAA,EAAgB,sBAAsB,IAC/E,uBAAA,CAAwB,IAAA,EAAM,KAAA,CAAM,MAAA,CAAO,cAAc,CAAA;AAG3D,EAAA,MAAM,QAAA,GAAW,kBAAA,CAAmB,IAAA,CAAK,IAAA,CAAK,WAAY,YAAY,CAAA;AACtE,EAAA,MAAM,MAAA,GAAS,kBAAA,CAAmB,IAAA,CAAK,EAAA,CAAG,WAAY,oBAAoB,CAAA;AAC1E,EAAA,IAAI,aAAA,GAAgB,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAM,UAAU,MAAM,CAAA;AAExD,EAAA,IAAI,kBAAkB,IAAA,EAAM;AAE1B,IAAA,IAAA,CAAK,QAAA,GAAW,cAAA;AAChB,IAAA,IAAA,CAAK,MAAA,GAAS,sBAAA;AACd,IAAA,IAAA,CAAK,OAAO,EAAC;AACb,IAAA;AAAA,EACF;AACA,EAAA,aAAA,GAAgB,UAAU,aAAa,CAAA;AAGvC,EAAA,MAAM,OAAA,GAAU,kBAAA,CAAmB,IAAA,CAAK,IAAA,CAAK,WAAY,cAAc,CAAA;AACvE,EAAA,MAAM,KAAA,GAAQ,kBAAA,CAAmB,IAAA,CAAK,EAAA,CAAG,WAAY,sBAAsB,CAAA;AAC3E,EAAA,IAAI,eAAA,GAAkB,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAM,SAAS,KAAK,CAAA;AAExD,EAAA,IAAI,oBAAoB,IAAA,EAAM;AAE5B,IAAA,IAAA,CAAK,QAAA,GAAW,YAAA;AAChB,IAAA,IAAA,CAAK,MAAA,GAAS,oBAAA;AACd,IAAA,IAAA,CAAK,IAAA,GAAO,aAAA;AACZ,IAAA;AAAA,EACF;AACA,EAAA,eAAA,GAAkB,UAAU,eAAe,CAAA;AAG3C,EAAA,IAAI,aAAA,CAAc,MAAA,IAAU,eAAA,CAAgB,MAAA,EAAQ;AAClD,IAAA,IAAA,CAAK,QAAA,GAAW,YAAA;AAChB,IAAA,IAAA,CAAK,MAAA,GAAS,oBAAA;AACd,IAAA,IAAA,CAAK,IAAA,GAAO,aAAA;AAAA,EACd,CAAA,MAAO;AACL,IAAA,IAAA,CAAK,QAAA,GAAW,cAAA;AAChB,IAAA,IAAA,CAAK,MAAA,GAAS,sBAAA;AACd,IAAA,IAAA,CAAK,IAAA,GAAO,eAAA;AAAA,EACd;AACF;AAOO,SAAS,kBAAA,CAAmB,OAAmB,IAAA,EAAuB;AAC3E,EAAA,IAAI,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;AAE5B,EAAA,MAAM,QAAA,GAAW,KAAK,IAAA,CAAK,MAAA;AAC3B,EAAA,IAAI,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA;AAC1B,EAAA,IAAI,cAAsC,CAAC,QAAA,EAAU,IAAA,CAAK,IAAA,CAAK,CAAC,CAAE,CAAA;AAClE,EAAA,IAAI,eAAA,GAAkB,CAAA;AAEtB,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,QAAQ,CAAA,EAAA,EAAK;AACzC,IAAA,MAAM,IAAA,GAAO,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA;AACxB,IAAA,MAAM,IAAA,GAA+B,CAAC,QAAA,EAAU,IAAI,CAAA;AACpD,IAAA,MAAM,SAAA,GAAY,kBAAA,CAAmB,KAAA,EAAO,IAAI,CAAA;AAEhD,IAAA,IAAI,aAAa,QAAA,EAAU;AACzB,MAAA,WAAA,GAAc,IAAA;AACd,MAAA;AAAA,IACF,CAAA,MAAA,IAAW,YAAY,eAAA,EAAiB;AACtC,MAAA,eAAA,GAAkB,SAAA;AAClB,MAAA,WAAA,GAAc,IAAA;AAAA,IAChB;AACA,IAAA,QAAA,GAAW,IAAA;AAAA,EACb;AAGA,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,CAAC,EAAE,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA,CAAE,CAAC,CAAA;AACxD,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,CAAC,EAAE,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA,CAAE,CAAC,CAAA;AACxD,EAAA,MAAM,UAAU,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,IAAA,GAAO,QAAQ,CAAC,CAAA;AAEnD,EAAA,MAAM,OAAA,GAAU,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,OAAO,CAAA,IAAK,CAAA;AAClD,EAAA,KAAA,CAAM,WAAA,CAAY,IAAI,OAAA,EAAS,IAAA,CAAK,IAAI,OAAA,EAAS,QAAA,GAAW,CAAC,CAAC,CAAA;AAE9D,EAAA,IAAA,CAAK,YAAY,CAAC,WAAA,CAAY,CAAC,CAAA,EAAG,WAAA,CAAY,CAAC,CAAC,CAAA;AAClD;AAGA,SAAS,kBAAA,CAAmB,OAAmB,IAAA,EAAsC;AACnF,EAAA,IAAI,KAAA,GAAQ,CAAA;AACZ,EAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAC,EAAE,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA,CAAE,CAAC,CAAA;AAC5C,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAC,EAAE,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA,CAAE,CAAC,CAAA;AAC1C,EAAA,KAAA,IAAS,CAAA,GAAI,MAAA,EAAQ,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AACnC,IAAA,KAAA,IAAS,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,CAAC,CAAA,IAAK,CAAA;AAAA,EACvC;AACA,EAAA,OAAO,KAAA;AACT;;;ACjNO,SAAS,OAAA,CAAQ,MAAiB,KAAA,EAA2B;AAClE,EAAA,MAAM,KAAK,IAAA,CAAK,SAAA;AAChB,EAAA,MAAM,QAAA,GAAW,MAAM,MAAA,CAAO,QAAA;AAG9B,EAAA,IAAI,CAAA,GAAI,CAAA;AACR,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;AAC1B,IAAA,CAAA,IAAK,MAAM,WAAA,CAAY,GAAA,CAAI,EAAA,CAAG,CAAA,GAAI,CAAC,CAAA,IAAK,CAAA;AAAA,EAC1C;AAEA,EAAA,IAAI,CAAA,GAAI,CAAA;AACR,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;AAC1B,IAAA,CAAA,IAAK,MAAM,SAAA,CAAU,GAAA,CAAI,EAAA,CAAG,CAAA,GAAI,CAAC,CAAA,IAAK,CAAA;AAAA,EACxC;AAEA,EAAA,MAAM,IAAA,GAAqB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AACxC,EAAA,MAAM,EAAA,GAAmB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AACtC,EAAA,MAAM,GAAA,GAAM,QAAA,CAAS,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,KAAK,GAAA,CAAI,IAAA,CAAK,CAAA,EAAG,EAAA,CAAG,CAAC,CAAC,CAAA;AAEnE,EAAA,IAAI,CAAC,QAAA,EAAU;AAEb,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AAC1D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AACxD,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AAC1D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,EAAA,CAAG,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AACxD,IAAA,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AACvB,IAAA,GAAA,CAAI,EAAA,CAAG,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AACrB,IAAA,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AACrB,IAAA,GAAA,CAAI,EAAA,CAAG,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AAAA,EACrB,CAAA,MAAO;AAEL,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,GAAA;AAC1D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AACxD,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AAC1D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,GAAA,CAAI,EAAA,CAAG,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AACxD,IAAA,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,GAAA;AACvB,IAAA,GAAA,CAAI,EAAA,CAAG,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,GAAA;AACrB,IAAA,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AACrB,IAAA,GAAA,CAAI,EAAA,CAAG,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AAAA,EACrB;AAGA,EAAA,MAAM,QAAQ,IAAA,CAAK,YAAA;AACnB,EAAA,MAAM,QAAQ,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,IAAI,CAAC,CAAA;AACvC,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAA,GAAI,CAAC,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACzE,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,GAAA,CAAI,QAAQ,CAAC,CAAA,CAAG,KAAK,CAAA,GAAI,MAAM,CAAC,CAAA;AAAA,EAClC;AAEA,EAAA,OAAO,GAAA;AACT;AAgBO,SAAS,YAAA,CACd,QAAA,EACA,QAAA,EACA,OAAA,GAAkB,CAAA,EACV;AAER,EAAA,IAAI,YAAA,GAAe,CAAA;AACnB,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,KAAA,MAAW,QAAQ,OAAA,EAAS;AAC1B,MAAA,YAAA,GAAe,IAAA,CAAK,GAAA,CAAI,YAAA,EAAc,IAAA,CAAK,MAAM,CAAA;AAAA,IACnD;AAAA,EACF;AACA,EAAA,MAAM,UAAA,GAAa,eAAe,CAAA,GAAI,OAAA;AACtC,EAAA,MAAM,WAAW,UAAA,GAAa,CAAA;AAG9B,EAAA,IAAI,UAAA,GAAa,CAAA;AACjB,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,UAAA,IAAc,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,MAAA,EAAQ,CAAC,CAAA;AAAA,EAC1C;AACA,EAAA,MAAM,WAAA,GAAc,SAAS,MAAA,GAAS,CAAA;AACtC,EAAA,MAAM,SAAA,GAAY,aAAa,WAAA,GAAc,CAAA;AAG7C,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAC/B,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAC/B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,IAAA,GAAO,WAAW,GAAA,GAAM,QAAA;AAC9B,EAAA,MAAM,IAAA,GAAO,WAAW,GAAA,GAAM,QAAA;AAE9B,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,QAAA,GAAW,CAAA,EAAG,YAAY,CAAC,CAAA;AAGnD,EAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,EAAA;AAChB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,GAAW,CAAA,EAAG,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AACvD,EAAA,MAAA,CAAO,QAAA,GAAW,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,EAAA;AAG3B,EAAA,MAAA,CAAO,CAAC,CAAA,CAAG,SAAA,GAAY,CAAC,CAAA,GAAI,EAAA;AAC5B,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,GAAW,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,SAAA,GAAY,CAAC,CAAA,GAAI,KAAA;AACnE,EAAA,MAAA,CAAO,QAAA,GAAW,CAAC,CAAA,CAAG,SAAA,GAAY,CAAC,CAAA,GAAI,EAAA;AAGvC,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,GAAY,GAAG,CAAA,EAAA,EAAK;AACtC,IAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAChB,IAAA,MAAA,CAAO,QAAA,GAAW,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,EAC7B;AAGA,EAAA,IAAI,GAAA,GAAM,CAAA;AACV,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AACxC,IAAA,MAAM,OAAA,GAAU,SAAS,CAAC,CAAA;AAC1B,IAAA,MAAM,QAAQ,OAAA,CAAQ,MAAA,GAAS,CAAA,GAAI,OAAA,GAAU,CAAC,EAAE,CAAA;AAGhD,IAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,MAAA,MAAM,SAAS,CAAA,GAAI,OAAA;AACnB,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAQ,CAAA,EAAA,EAAK;AACpC,QAAA,MAAA,CAAO,SAAS,CAAC,CAAA,CAAG,GAAG,CAAA,GAAI,KAAK,CAAC,CAAA;AAAA,MACnC;AACA,MAAA,GAAA,EAAA;AAAA,IACF;AAGA,IAAA,IAAI,CAAA,GAAI,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG;AAC3B,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,GAAG,CAAA,GAAI,IAAA;AAClB,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,GAAW,CAAA,EAAG,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,GAAG,CAAA,GAAI,KAAA;AACzD,MAAA,MAAA,CAAO,QAAA,GAAW,CAAC,CAAA,CAAG,GAAG,CAAA,GAAI,IAAA;AAC7B,MAAA,GAAA,EAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAWO,SAAS,SACd,MAAA,EACA,IAAA,EACA,EAAA,EACA,UAAA,EACA,UACA,QAAA,EACgB;AAChB,EAAA,MAAM,GAAA,GAAM,kBAAA,CAAmB,IAAA,EAAM,EAAE,CAAA;AACvC,EAAA,MAAM,cAA8B,EAAC;AAGrC,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAC/B,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAC/B,EAAA,MAAM,MAAA,GAAS,WAAW,IAAA,GAAO,QAAA;AACjC,EAAA,MAAM,MAAA,GAAS,WAAW,GAAA,GAAM,QAAA;AAEhC,EAAA,IAAI,SAAA,CAAU,GAAA,EAAK,EAAE,CAAA,EAAG;AACtB,IAAA,KAAA,IAAS,CAAA,GAAI,KAAK,CAAA,GAAI,UAAA,EAAY,KAAK,EAAA,CAAG,CAAA,GAAI,UAAU,CAAA,EAAA,EAAK;AAC3D,MAAA,WAAA,CAAY,KAAK,EAAE,CAAA,EAAG,IAAA,CAAK,CAAA,EAAG,GAAG,CAAA;AACjC,MAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,IACvB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG;AAC/B,IAAA,KAAA,IAAS,CAAA,GAAI,KAAK,CAAA,GAAI,UAAA,EAAY,KAAK,EAAA,CAAG,CAAA,GAAI,UAAU,CAAA,EAAA,EAAK;AAC3D,MAAA,WAAA,CAAY,KAAK,EAAE,CAAA,EAAG,IAAA,CAAK,CAAA,EAAG,GAAG,CAAA;AACjC,MAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,IACvB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG;AAC/B,IAAA,KAAA,IAAS,CAAA,GAAI,KAAK,CAAA,GAAI,UAAA,EAAY,KAAK,EAAA,CAAG,CAAA,GAAI,UAAU,CAAA,EAAA,EAAK;AAC3D,MAAA,WAAA,CAAY,KAAK,EAAE,CAAA,EAAG,CAAA,EAAG,IAAA,CAAK,GAAG,CAAA;AACjC,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,KAAA;AAAA,IACvB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,KAAK,CAAA,EAAG;AAChC,IAAA,KAAA,IAAS,CAAA,GAAI,KAAK,CAAA,GAAI,UAAA,EAAY,KAAK,EAAA,CAAG,CAAA,GAAI,UAAU,CAAA,EAAA,EAAK;AAC3D,MAAA,WAAA,CAAY,KAAK,EAAE,CAAA,EAAG,CAAA,EAAG,IAAA,CAAK,GAAG,CAAA;AACjC,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,KAAA;AAAA,IACvB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,SAAS,CAAA,EAAG;AACpC,IAAA,KAAA,IAAS,IAAI,IAAA,CAAK,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,IAAI,UAAA,EAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,YAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,QAAA,EAAU,KAAK,CAAA,EAAA,EAAK;AACpG,MAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA;AACzB,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,MAAA;AAAA,IAClB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,UAAU,CAAA,EAAG;AACrC,IAAA,KAAA,IAAS,IAAI,IAAA,CAAK,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,IAAI,UAAA,EAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,YAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,QAAA,EAAU,KAAK,CAAA,EAAA,EAAK;AACpG,MAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA;AACzB,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,MAAA;AAAA,IAClB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,SAAS,CAAA,EAAG;AACpC,IAAA,KAAA,IAAS,IAAI,IAAA,CAAK,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,IAAI,UAAA,EAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,YAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,QAAA,EAAU,KAAK,CAAA,EAAA,EAAK;AACpG,MAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA;AACzB,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,MAAA;AAAA,IAClB;AAAA,EACF,CAAA,MAAA,IAAW,SAAA,CAAU,GAAA,EAAK,UAAU,CAAA,EAAG;AACrC,IAAA,KAAA,IAAS,IAAI,IAAA,CAAK,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,IAAI,UAAA,EAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,YAAY,CAAA,IAAK,EAAA,CAAG,CAAA,GAAI,QAAA,EAAU,KAAK,CAAA,EAAA,EAAK;AACpG,MAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA;AACzB,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,MAAA;AAAA,IAClB;AAAA,EACF;AAEA,EAAA,OAAO,WAAA;AACT;AAWO,SAAS,SAAA,CACd,OACA,IAAA,EAC0C;AAC1C,EAAA,IAAI,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;AAC1B,IAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;AACrC,IAAA,OAAO,CAAC,KAAA,EAAO,KAAA,EAAO,KAAA,EAAO,OAAO,KAAK,CAAA;AAAA,EAC3C;AAEA,EAAA,MAAM,WAAA,GAAc,cAAA,CAAe,KAAA,EAAO,IAAI,CAAA;AAC9C,EAAA,MAAM,CAAC,YAAY,UAAA,EAAY,QAAQ,IAAI,QAAA,CAAS,KAAA,EAAO,KAAK,IAAI,CAAA;AACpE,EAAA,MAAM,iBAAiB,YAAA,CAAa,KAAA,EAAO,KAAK,IAAA,EAAM,UAAA,CAAW,CAAC,CAAE,CAAA;AACpE,EAAA,MAAM,eAAA,GAAkB,aAAA;AAAA,IACtB,KAAA;AAAA,IACA,UAAA,CAAW,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA;AAAA,IAChC,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAC;AAAA,GAC9B;AACA,EAAA,MAAM,aAAA,GAAgB,WAAA,CAAY,KAAA,EAAO,IAAA,CAAK,IAAI,CAAA;AAElD,EAAA,OAAO,CAAC,UAAA,EAAY,cAAA,EAAgB,eAAA,EAAiB,eAAe,WAAW,CAAA;AACjF;AAMA,SAAS,QAAA,CACP,OACA,IAAA,EACyC;AACzC,EAAA,MAAM,MAAA,GAAS,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;AACtC,EAAA,IAAI,aAAA,GAAgB,KAAK,CAAC,CAAA;AAC1B,EAAA,MAAM,aAA+B,EAAC;AACtC,EAAA,MAAM,WAAwB,EAAC;AAE/B,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAQ,CAAA,EAAA,EAAK;AACpC,IAAA,MAAM,SAAA,GAAY,KAAK,CAAC,CAAA;AACxB,IAAA,MAAM,MAAA,GAAS,kBAAA,CAAmB,KAAA,EAAO,aAAa,CAAA;AACtD,IAAA,MAAM,MAAA,GAAS,kBAAA,CAAmB,KAAA,EAAO,SAAS,CAAA;AAElD,IAAA,IAAI,kBAAA,CAAmB,MAAA,EAAQ,MAAM,CAAA,EAAG;AACtC,MAAA,aAAA,GAAgB,SAAA;AAChB,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,GAAA,GAAM,kBAAA,CAAmB,aAAA,EAAe,SAAS,CAAA;AACvD,IAAA,MAAM,OAAA,GAAU,SAAS,MAAA,EAAQ,MAAA,EAAQ,QAAQ,CAAA,EAAG,EAAA,EAAI,KAAA,CAAM,MAAA,CAAO,QAAQ,CAAA;AAC7E,IAAA,IAAI,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG,OAAA,CAAQ,KAAK,MAAM,CAAA;AAC7C,IAAA,UAAA,CAAW,KAAK,OAAO,CAAA;AACvB,IAAA,QAAA,CAAS,KAAK,GAAG,CAAA;AACjB,IAAA,aAAA,GAAgB,SAAA;AAAA,EAClB;AAEA,EAAA,OAAO,CAAC,MAAA,EAAQ,UAAA,EAAY,QAAQ,CAAA;AACtC;AAMA,SAAS,YAAA,CACP,KAAA,EACA,IAAA,EACA,SAAA,EACQ;AACR,EAAA,MAAM,MAAA,GAAS,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;AACtC,EAAA,IAAI,KAAA,CAAM,MAAA,CAAO,QAAA,EAAU,OAAO,MAAA;AAElC,EAAA,MAAM,IAAA,GAAO,UAAU,CAAC,CAAA;AACxB,EAAA,MAAM,MAAM,kBAAA,CAAmB,IAAA,CAAK,CAAC,CAAA,EAAI,IAAA,CAAK,CAAC,CAAE,CAAA;AAEjD,EAAA,IAAI,SAAA,CAAU,GAAA,EAAK,EAAE,CAAA,EAAG,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,GAAI,QAAA;AAAA,OAAA,IAC7C,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,GAAI,QAAA;AAAA,OAAA,IACpD,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG,MAAA,CAAO,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AAAA,OAAA,IACpD,SAAA,CAAU,GAAA,EAAK,KAAK,CAAA,EAAG,MAAA,CAAO,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AAE9D,EAAA,OAAO,MAAA;AACT;AAMA,SAAS,aAAA,CACP,KAAA,EACA,QAAA,EACA,WAAA,EACQ;AACR,EAAA,MAAM,MAAA,GAAS,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;AACtC,EAAA,IAAI,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG,OAAO,MAAA;AAElC,EAAA,MAAM,IAAA,GAAO,SAAS,CAAC,CAAA;AACvB,EAAA,MAAM,OAAA,GAAU,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAC,CAAA;AAC5C,EAAA,IAAI,GAAA,GAAM,kBAAA,CAAmB,IAAA,EAAM,OAAO,CAAA;AAC1C,EAAA,IAAI,SAAS,MAAA,KAAW,CAAA,IAAK,UAAU,GAAA,EAAK,MAAM,GAAG,GAAA,GAAM,WAAA;AAE3D,EAAA,IAAI,IAAA;AAEJ,EAAA,IAAI,CAAC,KAAA,CAAM,MAAA,CAAO,QAAA,EAAU;AAC1B,IAAA,IAAI,SAAA,CAAU,GAAA,EAAK,EAAE,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IACtB,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IAC7B,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IAC7B,SAAA,CAAU,GAAA,EAAK,KAAK,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IAC9B,SAAA,CAAU,GAAA,EAAK,UAAU,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IACnC,SAAA,CAAU,GAAA,EAAK,SAAS,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IAClC,SAAA,CAAU,GAAA,EAAK,UAAU,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SAAA,IACnC,SAAA,CAAU,GAAA,EAAK,SAAS,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,SACtC;AAEH,MAAA,IAAI,SAAA,CAAU,WAAA,EAAa,EAAE,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IAC9B,SAAA,CAAU,WAAA,EAAa,IAAI,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IACrC,SAAA,CAAU,WAAA,EAAa,IAAI,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IACrC,SAAA,CAAU,WAAA,EAAa,KAAK,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IACtC,SAAA,CAAU,WAAA,EAAa,UAAU,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IAC3C,SAAA,CAAU,WAAA,EAAa,SAAS,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IAC1C,SAAA,CAAU,WAAA,EAAa,UAAU,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IAC3C,SAAA,CAAU,WAAA,EAAa,SAAS,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAC9C,IAAA,GAAO,QAAA;AAAA,IACd;AAAA,EACF,CAAA,MAAO;AACL,IAAA,IAAI,SAAA,CAAU,GAAA,EAAK,EAAE,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,SAAA,IACtB,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,SAAA,IAC7B,SAAA,CAAU,GAAA,EAAK,IAAI,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,SAAA,IAC7B,SAAA,CAAU,GAAA,EAAK,KAAK,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,SAClC;AACH,MAAA,IAAI,SAAA,CAAU,WAAA,EAAa,EAAE,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,WAAA,IAC9B,SAAA,CAAU,WAAA,EAAa,IAAI,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,WAAA,IACrC,SAAA,CAAU,WAAA,EAAa,IAAI,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,WAAA,IACrC,SAAA,CAAU,WAAA,EAAa,KAAK,CAAA,EAAG,IAAA,GAAO,GAAA;AAAA,WAC1C,IAAA,GAAO,GAAA;AAAA,IACd;AAAA,EACF;AAEA,EAAA,MAAA,CAAO,OAAA,CAAQ,CAAC,CAAA,CAAG,OAAA,CAAQ,CAAC,CAAA,GAAI,IAAA;AAChC,EAAA,OAAO,MAAA;AACT;AAMA,SAAS,WAAA,CAAY,OAAmB,IAAA,EAA2B;AACjE,EAAA,MAAM,MAAA,GAAS,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;AAEtC,EAAA,KAAA,IAAS,MAAM,CAAA,EAAG,GAAA,GAAM,IAAA,CAAK,MAAA,GAAS,GAAG,GAAA,EAAA,EAAO;AAC9C,IAAA,MAAM,KAAA,GAAQ,KAAK,GAAG,CAAA;AACtB,IAAA,MAAM,EAAA,GAAK,kBAAA,CAAmB,KAAA,EAAO,KAAK,CAAA;AAC1C,IAAA,MAAM,UAAU,kBAAA,CAAmB,IAAA,CAAK,GAAA,GAAM,CAAC,GAAI,KAAK,CAAA;AACxD,IAAA,MAAM,UAAU,kBAAA,CAAmB,KAAA,EAAO,IAAA,CAAK,GAAA,GAAM,CAAC,CAAE,CAAA;AAExD,IAAA,IAAI,MAAA;AACJ,IAAA,IAAI,CAAC,KAAA,CAAM,MAAA,CAAO,QAAA,EAAU;AAC1B,MAAA,IAAK,SAAA,CAAU,OAAA,EAAS,KAAK,CAAA,IAAK,UAAU,OAAA,EAAS,IAAI,CAAA,IACpD,SAAA,CAAU,SAAS,EAAE,CAAA,IAAK,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA,EAAI;AACxD,QAAA,MAAA,GAAS,QAAA;AAAA,MACX,WAAY,SAAA,CAAU,OAAA,EAAS,KAAK,CAAA,IAAK,UAAU,OAAA,EAAS,EAAE,CAAA,IAClD,SAAA,CAAU,SAAS,IAAI,CAAA,IAAK,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA,EAAI;AACjE,QAAA,MAAA,GAAS,QAAA;AAAA,MACX,WAAY,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA,IAAK,UAAU,OAAA,EAAS,IAAI,CAAA,IACnD,SAAA,CAAU,SAAS,EAAE,CAAA,IAAK,SAAA,CAAU,OAAA,EAAS,KAAK,CAAA,EAAI;AAChE,QAAA,MAAA,GAAS,QAAA;AAAA,MACX,WAAY,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA,IAAK,UAAU,OAAA,EAAS,EAAE,CAAA,IACjD,SAAA,CAAU,SAAS,IAAI,CAAA,IAAK,SAAA,CAAU,OAAA,EAAS,KAAK,CAAA,EAAI;AAClE,QAAA,MAAA,GAAS,QAAA;AAAA,MACX,CAAA,MAAO;AACL,QAAA,MAAA,GAAS,GAAA;AAAA,MACX;AAAA,IACF,CAAA,MAAO;AACL,MAAA,MAAA,GAAS,GAAA;AAAA,IACX;AAEA,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,MAAA;AAAA,EACxB;AAEA,EAAA,OAAO,MAAA;AACT;AAGA,SAAS,cAAA,CAAe,OAAmB,IAAA,EAAyB;AAClE,EAAA,MAAM,MAAA,GAAS,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;AACtC,EAAA,IAAI,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG,OAAO,MAAA;AAEnC,EAAA,MAAM,WAAA,GAAc,aAAA,CAAc,KAAA,EAAO,IAAA,CAAK,SAAS,CAAA;AACvD,EAAA,cAAA,CAAe,MAAA,EAAQ,WAAA,EAAa,IAAA,CAAK,IAAI,CAAA;AAC7C,EAAA,OAAO,MAAA;AACT;AAGA,SAAS,cAAA,CAAe,MAAA,EAAgB,IAAA,EAAsB,KAAA,EAAqB;AACjF,EAAA,IAAI,IAAA,CAAK,SAAS,CAAA,EAAG;AACrB,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAC,EAAG,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA;AAC5C,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAC,EAAG,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA;AAC5C,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAC,EAAG,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA;AAC5C,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAC,EAAG,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA;AAC5C,EAAA,MAAM,UAAU,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,IAAA,GAAO,QAAQ,CAAC,CAAA;AACnD,EAAA,MAAM,UAAU,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,IAAA,GAAO,QAAQ,CAAC,CAAA;AACnD,EAAA,MAAM,SAAS,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,SAAS,CAAC,CAAA;AACpD,EAAA,QAAA,CAAS,QAAQ,EAAE,CAAA,EAAG,QAAQ,CAAA,EAAG,OAAA,IAAW,KAAK,CAAA;AACnD;AAOO,SAAS,eAAA,CAAgB,IAAmB,KAAA,EAA2B;AAC5E,EAAA,MAAM,KAAA,GAAQ,EAAA,CAAG,IAAA,GAAO,EAAA,CAAG,IAAA;AAC3B,EAAA,MAAM,MAAA,GAAS,EAAA,CAAG,IAAA,GAAO,EAAA,CAAG,IAAA;AAC5B,EAAA,IAAI,SAAS,CAAA,IAAK,MAAA,IAAU,GAAG,OAAO,QAAA,CAAS,GAAG,CAAC,CAAA;AAEnD,EAAA,MAAM,IAAA,GAAqB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AACxC,EAAA,MAAM,EAAA,GAAmB,EAAE,CAAA,EAAG,KAAA,EAAO,GAAG,MAAA,EAAO;AAC/C,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,KAAA,EAAO,MAAM,CAAA;AAErC,EAAA,IAAI,CAAC,KAAA,CAAM,MAAA,CAAO,QAAA,EAAU;AAC1B,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AAC7D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AAC3D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AAC7D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AAC3D,IAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AAC1B,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,QAAA;AACxB,IAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AACxB,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,QAAA;AAAA,EACxB,CAAA,MAAO;AACL,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,GAAA;AAC7D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AAC3D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AAC7D,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AAC3D,IAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,GAAA;AAC1B,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,IAAA,CAAK,CAAC,CAAA,GAAI,GAAA;AACxB,IAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AACxB,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;AAAA,EACxB;AAEA,EAAA,OAAO,MAAA;AACT;AAGO,SAAS,iBAAA,CAAkB,IAAmB,KAAA,EAA2C;AAC9F,EAAA,MAAM,KAAA,GAAQ,EAAA,CAAG,IAAA,GAAO,EAAA,CAAG,IAAA;AAC3B,EAAA,MAAM,MAAA,GAAS,EAAA,CAAG,IAAA,GAAO,EAAA,CAAG,IAAA;AAC5B,EAAA,IAAI,KAAA,IAAS,CAAA,IAAK,MAAA,IAAU,CAAA,SAAU,CAAC,QAAA,CAAS,CAAA,EAAG,CAAC,GAAG,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA;AAErE,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,KAAA,EAAO,MAAM,CAAA;AACrC,EAAA,MAAM,MAAA,GAAS,CAAA;AACf,EAAA,IAAI,MAAA,GAAS,IAAA,CAAK,KAAA,CAAM,KAAA,GAAQ,CAAC,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,EAAA,CAAG,IAAA,CAAK,MAAA,GAAS,CAAC,CAAA;AAClE,EAAA,IAAI,MAAA,GAAS,GAAG,MAAA,GAAS,CAAA;AAEzB,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,IAAA,CAAK,QAAQ,CAAA,EAAA,EAAK;AACvC,IAAA,IAAI,MAAA,GAAS,IAAI,KAAA,EAAO;AACtB,MAAA,MAAA,CAAO,SAAS,CAAC,CAAA,CAAG,MAAM,CAAA,GAAI,EAAA,CAAG,KAAK,CAAC,CAAA;AAAA,IACzC;AAAA,EACF;AAEA,EAAA,OAAO,CAAC,QAAQ,EAAE,CAAA,EAAG,GAAG,IAAA,EAAM,CAAA,EAAG,EAAA,CAAG,IAAA,EAAM,CAAA;AAC5C;AAOA,SAAS,qBAAqB,SAAA,EAA6C;AACzE,EAAA,SAAS,SAAS,EAAA,EAA2B;AAC3C,IAAA,OAAO,GAAG,MAAA,KAAW,IAAA,GAAO,IAAI,CAAA,GAAI,QAAA,CAAS,GAAG,MAAM,CAAA;AAAA,EACxD;AACA,EAAA,MAAM,MAAA,GAAS,CAAC,GAAG,SAAS,CAAA;AAC5B,EAAA,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM,SAAS,CAAC,CAAA,GAAI,QAAA,CAAS,CAAC,CAAC,CAAA;AAC/C,EAAA,OAAO,MAAA;AACT;AAcO,SAAS,UAAU,KAAA,EAA2B;AACnD,EAAA,MAAM,QAAA,GAAW,MAAM,MAAA,CAAO,QAAA;AAG9B,EAAA,MAAM,SAAA,GAAY,oBAAA,CAAqB,KAAA,CAAM,SAAS,CAAA;AACtD,EAAA,KAAA,MAAW,MAAM,SAAA,EAAW;AAC1B,IAAA,MAAM,QAAA,GAAW,eAAA,CAAgB,EAAA,EAAI,KAAK,CAAA;AAC1C,IAAA,MAAM,SAAuB,EAAE,CAAA,EAAG,GAAG,IAAA,EAAM,CAAA,EAAG,GAAG,IAAA,EAAK;AACtD,IAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,MAAA,EAAQ,MAAA,EAAQ,UAAU,QAAQ,CAAA;AAAA,EACvE;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,IAAI,CAAC,IAAA,CAAK,KAAA,IAAS,IAAA,CAAK,YAAA,IAAgB,KAAK,OAAA,EAAS;AACpD,MAAA,KAAA,CAAM,MAAA,GAAS,cAAc,KAAA,CAAM,MAAA,EAAQ,KAAK,YAAA,EAAc,QAAA,EAAU,KAAK,OAAO,CAAA;AACpF,MAAA,IAAA,CAAK,KAAA,GAAQ,IAAA;AAAA,IACf;AAAA,EACF;AAGA,EAAA,MAAM,eAAyB,EAAC;AAChC,EAAA,MAAM,iBAA2B,EAAC;AAClC,EAAA,MAAM,oBAA8B,EAAC;AACrC,EAAA,MAAM,mBAA6B,EAAC;AACpC,EAAA,MAAM,gBAA0B,EAAC;AAEjC,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,MAAM,CAAC,OAAO,SAAA,EAAW,UAAA,EAAY,UAAU,MAAM,CAAA,GAAI,SAAA,CAAU,KAAA,EAAO,IAAI,CAAA;AAC9E,IAAA,YAAA,CAAa,KAAK,KAAK,CAAA;AACvB,IAAA,cAAA,CAAe,KAAK,QAAQ,CAAA;AAC5B,IAAA,iBAAA,CAAkB,KAAK,UAAU,CAAA;AACjC,IAAA,gBAAA,CAAiB,KAAK,SAAS,CAAA;AAC/B,IAAA,aAAA,CAAc,KAAK,MAAM,CAAA;AAAA,EAC3B;AAGA,EAAA,MAAM,IAAA,GAAqB,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AACxC,EAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,QAAQ,IAAA,EAAM,QAAA,EAAU,GAAG,YAAY,CAAA;AAC1E,EAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,QAAQ,IAAA,EAAM,QAAA,EAAU,GAAG,cAAc,CAAA;AAC5E,EAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,QAAQ,IAAA,EAAM,QAAA,EAAU,GAAG,iBAAiB,CAAA;AAC/E,EAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,QAAQ,IAAA,EAAM,QAAA,EAAU,GAAG,gBAAgB,CAAA;AAC9E,EAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,QAAQ,IAAA,EAAM,QAAA,EAAU,GAAG,aAAa,CAAA;AAG3E,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,IAAI,EAAA,CAAG,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;AAC3B,IAAA,MAAM,CAAC,WAAA,EAAa,MAAM,CAAA,GAAI,iBAAA,CAAkB,EAAS,CAAA;AACzD,IAAA,KAAA,CAAM,SAAS,aAAA,CAAc,KAAA,CAAM,MAAA,EAAQ,MAAA,EAAQ,UAAU,WAAW,CAAA;AAAA,EAC1E;AAEA,EAAA,OAAO,KAAA,CAAM,MAAA;AACf;;;ACjjBO,SAAS,kBAAA,CACd,KAAA,EACA,CAAA,EACA,GAAA,EACc;AACd,EAAA,MAAM,MAAA,GAEF,CAAA;AAEJ,EAAA,IAAI,CAAA,GAAI,CAAA;AACR,EAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,GAAM,MAAA,CAAO,GAAG,GAAA,EAAA,EAAO;AACvC,IAAA,CAAA,IAAK,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,GAAG,CAAA,IAAK,CAAA;AAAA,EACrC;AAEA,EAAA,IAAI,CAAA,GAAI,CAAA;AACR,EAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,GAAM,MAAA,CAAO,GAAG,GAAA,EAAA,EAAO;AACvC,IAAA,CAAA,IAAK,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,GAAG,CAAA,IAAK,CAAA;AAAA,EACnC;AAEA,EAAA,MAAM,OAAO,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA,IAAK,CAAA;AAChD,EAAA,MAAM,OAAO,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA,IAAK,CAAA;AAC9C,EAAA,OAAO;AAAA,IACL,GAAG,CAAA,GAAI,IAAA,CAAK,MAAM,IAAA,GAAO,CAAC,IAAI,KAAA,CAAM,OAAA;AAAA,IACpC,GAAG,CAAA,GAAI,IAAA,CAAK,MAAM,IAAA,GAAO,CAAC,IAAI,KAAA,CAAM;AAAA,GACtC;AACF;AAGO,SAAS,aAAA,CAAc,OAAmB,IAAA,EAAmC;AAClF,EAAA,OAAO,KAAK,GAAA,CAAI,CAAA,CAAA,KAAK,kBAAA,CAAmB,KAAA,EAAO,CAAC,CAAC,CAAA;AACnD;AAWO,SAAS,iBAAA,CACd,KAAA,EACA,IAAA,EACA,SAAA,EACW;AACX,EAAA,IAAI,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,SAAS,CAAC,CAAA,EAAG;AAEtC,IAAA,IAAI,KAAA,CAAM,MAAA,CAAO,cAAA,KAAmB,IAAA,EAAM;AACxC,MAAA,OAAO,iBAAA,CAAkB,KAAA,EAAO,IAAA,EAAM,EAAE,CAAA,EAAG,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,SAAA,CAAU,CAAA,GAAI,CAAA,EAAG,CAAA;AAAA,IAC9E,CAAA,MAAO;AACL,MAAA,OAAO,iBAAA,CAAkB,KAAA,EAAO,IAAA,EAAM,EAAE,CAAA,EAAG,SAAA,CAAU,CAAA,GAAI,CAAA,EAAG,CAAA,EAAG,SAAA,CAAU,CAAA,EAAG,CAAA;AAAA,IAC9E;AAAA,EACF;AAGA,EAAA,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,EAAA,GAAK,CAAA,EAAG,EAAA,EAAA,EAAM;AAC7B,IAAA,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,EAAA,GAAK,CAAA,EAAG,EAAA,EAAA,EAAM;AAC7B,MAAA,MAAM,QAAA,GAAsB,EAAE,CAAA,EAAG,SAAA,CAAU,IAAI,EAAA,EAAI,CAAA,EAAG,SAAA,CAAU,CAAA,GAAI,EAAA,EAAG;AACvE,MAAA,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,QAAQ,GAAG,IAAI,CAAA;AAAA,IACxC;AAAA,EACF;AAEA,EAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AACjB,EAAA,OAAO,SAAA;AACT;AAWO,SAAS,cAAA,CAAe,OAAmB,IAAA,EAAuB;AACvE,EAAA,MAAM,KAAK,IAAA,CAAK,SAAA;AAChB,EAAA,MAAM,OAAA,GAAU,MAAM,MAAA,CAAO,gBAAA;AAG7B,EAAA,MAAM,SAAA,GAAY,CAAC,CAAA,EAAG,CAAA,GAAI,UAAU,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAC,CAAA;AAE/D,EAAA,MAAM,aAAa,CAAC,CAAA,EAAG,CAAA,GAAI,CAAA,GAAI,SAAS,CAAC,CAAA;AAEzC,EAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,GAAM,SAAA,CAAU,QAAQ,GAAA,EAAA,EAAO;AAC/C,IAAA,MAAM,MAAA,GAAS,GAAG,CAAA,GAAI,GAAA;AACtB,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,IAAK,CAAA;AACjD,IAAA,KAAA,CAAM,WAAA,CAAY,IAAI,MAAA,EAAQ,IAAA,CAAK,IAAI,OAAA,EAAS,SAAA,CAAU,GAAG,CAAE,CAAC,CAAA;AAAA,EAClE;AAEA,EAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,GAAM,UAAA,CAAW,QAAQ,GAAA,EAAA,EAAO;AAChD,IAAA,MAAM,MAAA,GAAS,GAAG,CAAA,GAAI,GAAA;AACtB,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,MAAM,CAAA,IAAK,CAAA;AAC/C,IAAA,KAAA,CAAM,SAAA,CAAU,IAAI,MAAA,EAAQ,IAAA,CAAK,IAAI,OAAA,EAAS,UAAA,CAAW,GAAG,CAAE,CAAC,CAAA;AAAA,EACjE;AAGA,EAAA,IAAI,EAAA,CAAG,IAAI,CAAA,EAAG;AACZ,IAAA,MAAM,UAAU,KAAA,CAAM,WAAA,CAAY,IAAI,EAAA,CAAG,CAAA,GAAI,CAAC,CAAA,IAAK,CAAA;AACnD,IAAA,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,EAAA,CAAG,CAAA,GAAI,CAAA,EAAG,IAAA,CAAK,GAAA,CAAI,OAAA,EAAS,KAAA,CAAM,MAAA,CAAO,QAAQ,CAAC,CAAA;AAAA,EAC1E;AAEA,EAAA,IAAI,EAAA,CAAG,IAAI,CAAA,EAAG;AACZ,IAAA,IAAI,WAAA,GAAc,MAAM,MAAA,CAAO,QAAA;AAE/B,IAAA,IAAI,kCAAA,CAAmC,KAAA,EAAO,IAAI,CAAA,EAAG;AACnD,MAAA,MAAM,gBAAA,GAAmB,CAAA;AACzB,MAAA,WAAA,IAAe,gBAAA;AAAA,IACjB;AACA,IAAA,MAAM,UAAU,KAAA,CAAM,SAAA,CAAU,IAAI,EAAA,CAAG,CAAA,GAAI,CAAC,CAAA,IAAK,CAAA;AACjD,IAAA,KAAA,CAAM,SAAA,CAAU,IAAI,EAAA,CAAG,CAAA,GAAI,GAAG,IAAA,CAAK,GAAA,CAAI,OAAA,EAAS,WAAW,CAAC,CAAA;AAAA,EAC9D;AACF;AAGO,SAAS,uBAAA,CAAwB,OAAmB,IAAA,EAAyB;AAClF,EAAA,KAAA,MAAW,KAAK,IAAA,EAAM;AACpB,IAAA,IAAI,CAAC,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,CAAA,CAAE,CAAC,CAAA,EAAG;AAC/B,MAAA,KAAA,CAAM,WAAA,CAAY,GAAA,CAAI,CAAA,CAAE,CAAA,EAAG,IAAA,CAAK,MAAM,KAAA,CAAM,MAAA,CAAO,QAAA,GAAW,CAAC,CAAC,CAAA;AAAA,IAClE;AACA,IAAA,IAAI,CAAC,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,CAAA,CAAE,CAAC,CAAA,EAAG;AAC7B,MAAA,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,CAAA,CAAE,CAAA,EAAG,IAAA,CAAK,MAAM,KAAA,CAAM,MAAA,CAAO,QAAA,GAAW,CAAC,CAAC,CAAA;AAAA,IAChE;AAAA,EACF;AACF;AAMA,SAAS,mBAAA,CAAoB,OAAmB,IAAA,EAA0B;AACxE,EAAA,OAAO,KAAA,CAAM,UAAU,IAAA,CAAK,CAAA,EAAA,KAAM,GAAG,KAAA,CAAM,QAAA,CAAS,IAAI,CAAC,CAAA;AAC3D;AAEA,SAAS,eAAA,CAAgB,OAAmB,IAAA,EAAuC;AACjF,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,IAAI,EAAA,CAAG,KAAA,CAAM,QAAA,CAAS,IAAI,GAAG,OAAO,EAAA;AAAA,EACtC;AACA,EAAA,OAAO,IAAA;AACT;AAOA,SAAS,kCAAA,CAAmC,OAAmB,IAAA,EAA0B;AACvF,EAAA,MAAM,MAAA,GAAS,eAAA,CAAgB,KAAA,EAAO,IAAI,CAAA;AAC1C,EAAA,IAAI,CAAC,QAAQ,OAAO,KAAA;AAEpB,EAAA,IAAI,eAAA,GAAkB,KAAA;AACtB,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,IAAI,IAAA,CAAK,OAAO,IAAA,EAAM;AACpB,MAAA,MAAM,QAAA,GAAW,eAAA,CAAgB,KAAA,EAAO,IAAA,CAAK,IAAI,CAAA;AACjD,MAAA,IAAI,aAAa,MAAA,EAAQ;AACvB,QAAA,eAAA,GAAkB,IAAA;AAClB,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAA,IAAI,CAAC,iBAAiB,OAAO,KAAA;AAG7B,EAAA,KAAA,MAAW,SAAA,IAAa,OAAO,KAAA,EAAO;AACpC,IAAA,IAAI,SAAA,KAAc,IAAA,IAAQ,CAAC,SAAA,CAAU,SAAA,EAAW;AAChD,IAAA,IAAI,gBAAA,GAAmB,KAAA;AACvB,IAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,MAAA,IAAI,IAAA,CAAK,OAAO,SAAA,EAAW;AACzB,QAAA,MAAM,QAAA,GAAW,eAAA,CAAgB,KAAA,EAAO,IAAA,CAAK,IAAI,CAAA;AACjD,QAAA,IAAI,aAAa,MAAA,EAAQ;AACvB,UAAA,gBAAA,GAAmB,IAAA;AACnB,UAAA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,IAAA,IAAI,oBAAoB,SAAA,CAAU,SAAA,CAAU,CAAA,GAAI,IAAA,CAAK,UAAW,CAAA,EAAG;AACjE,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AAEA,EAAA,OAAO,IAAA;AACT;AAMA,SAAS,4BAAA,CAA6B,OAAmB,EAAA,EAAyB;AAChF,EAAA,IAAI,EAAA,CAAG,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;AAE3B,EAAA,IAAI,IAAA,GAAO,GAAA;AACX,EAAA,IAAI,IAAA,GAAO,GAAA;AACX,EAAA,IAAI,IAAA,GAAO,IAAA;AACX,EAAA,IAAI,IAAA,GAAO,IAAA;AAGX,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,4BAAA,CAA6B,OAAO,KAAK,CAAA;AACzC,IAAA,IAAI,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;AAC1B,MAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAA,CAAM,IAAI,CAAA;AAChC,MAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAA,CAAM,IAAI,CAAA;AAChC,MAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAA,CAAM,IAAI,CAAA;AAChC,MAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAA,CAAM,IAAI,CAAA;AAAA,IAClC;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,GAAG,KAAA,EAAO;AAC3B,IAAA,IAAI,CAAC,IAAA,CAAK,YAAA,IAAgB,CAAC,KAAK,OAAA,EAAS;AACzC,IAAA,MAAM,QAAA,GAAW,KAAK,YAAA,CAAa,CAAA;AACnC,IAAA,MAAM,QAAA,GAAW,KAAK,YAAA,CAAa,CAAA;AACnC,IAAA,MAAM,QAAA,GAAW,QAAA,GAAW,IAAA,CAAK,OAAA,CAAQ,MAAA,GAAS,CAAA;AAClD,IAAA,MAAM,WAAW,QAAA,GAAW,IAAA,CAAK,OAAA,CAAQ,CAAC,EAAG,MAAA,GAAS,CAAA;AACtD,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAC9B,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAC9B,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAC9B,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAAA,EAChC;AAEA,EAAA,MAAM,eAAA,GAAkB,CAAA;AACxB,EAAA,MAAM,kBAAA,GAAqB,CAAA;AAC3B,EAAA,EAAA,CAAG,OAAO,IAAA,GAAO,eAAA;AACjB,EAAA,EAAA,CAAG,IAAA,GAAO,OAAO,eAAA,GAAkB,kBAAA;AACnC,EAAA,EAAA,CAAG,OAAO,IAAA,GAAO,eAAA;AACjB,EAAA,EAAA,CAAG,OAAO,IAAA,GAAO,eAAA;AACnB;AAGA,SAAS,sBAAsB,KAAA,EAAyB;AACtD,EAAA,MAAM,UAAA,GAAa,CAAA;AACnB,EAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,SAAA,CAAU,MAAA,CAAO,CAAA,EAAA,KAAM,EAAA,CAAG,MAAA,KAAW,IAAA,IAAQ,EAAA,CAAG,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA;AAE5F,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,aAAA,CAAc,QAAQ,CAAA,EAAA,EAAK;AAC7C,IAAA,KAAA,IAAS,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,aAAA,CAAc,QAAQ,CAAA,EAAA,EAAK;AACjD,MAAA,MAAM,GAAA,GAAM,cAAc,CAAC,CAAA;AAC3B,MAAA,MAAM,GAAA,GAAM,cAAc,CAAC,CAAA;AAG3B,MAAA,IAAI,IAAI,IAAA,GAAO,GAAA,CAAI,QAAQ,GAAA,CAAI,IAAA,GAAO,IAAI,IAAA,EAAM;AAC9C,QAAA,IAAI,GAAA,CAAI,QAAQ,GAAA,CAAI,IAAA,GAAO,cAAc,GAAA,CAAI,IAAA,GAAO,IAAI,IAAA,EAAM;AAC5D,UAAA,GAAA,CAAI,IAAA,GAAO,GAAA,CAAI,IAAA,GAAO,UAAA,GAAa,CAAA;AAAA,QACrC,CAAA,MAAA,IAAW,IAAI,IAAA,IAAQ,GAAA,CAAI,OAAO,UAAA,IAAc,GAAA,CAAI,IAAA,GAAO,GAAA,CAAI,IAAA,EAAM;AACnE,UAAA,GAAA,CAAI,IAAA,GAAO,GAAA,CAAI,IAAA,GAAO,UAAA,GAAa,CAAA;AAAA,QACrC;AAAA,MACF;AAEA,MAAA,IAAI,IAAI,IAAA,GAAO,GAAA,CAAI,QAAQ,GAAA,CAAI,IAAA,GAAO,IAAI,IAAA,EAAM;AAC9C,QAAA,IAAI,GAAA,CAAI,QAAQ,GAAA,CAAI,IAAA,GAAO,cAAc,GAAA,CAAI,IAAA,GAAO,IAAI,IAAA,EAAM;AAC5D,UAAA,GAAA,CAAI,IAAA,GAAO,GAAA,CAAI,IAAA,GAAO,UAAA,GAAa,CAAA;AAAA,QACrC,CAAA,MAAA,IAAW,IAAI,IAAA,IAAQ,GAAA,CAAI,OAAO,UAAA,IAAc,GAAA,CAAI,IAAA,GAAO,GAAA,CAAI,IAAA,EAAM;AACnE,UAAA,GAAA,CAAI,IAAA,GAAO,GAAA,CAAI,IAAA,GAAO,UAAA,GAAa,CAAA;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEO,SAAS,+BAA+B,KAAA,EAAyB;AACtE,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,4BAAA,CAA6B,OAAO,EAAE,CAAA;AAAA,EACxC;AACA,EAAA,qBAAA,CAAsB,KAAK,CAAA;AAC7B;AAMO,SAAS,0BAA0B,KAAA,EAAyB;AACjE,EAAA,IAAI,KAAA,CAAM,SAAA,CAAU,MAAA,KAAW,CAAA,EAAG;AAElC,EAAA,IAAI,IAAA,GAAO,CAAA;AACX,EAAA,IAAI,IAAA,GAAO,CAAA;AACX,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,EAAA,CAAG,IAAI,CAAA;AAC7B,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,EAAA,CAAG,IAAI,CAAA;AAAA,EAC/B;AAEA,EAAA,MAAM,UAAU,CAAC,IAAA;AACjB,EAAA,MAAM,UAAU,CAAC,IAAA;AACjB,EAAA,IAAI,OAAA,KAAY,CAAA,IAAK,OAAA,KAAY,CAAA,EAAG;AAEpC,EAAA,KAAA,CAAM,OAAA,GAAU,OAAA;AAChB,EAAA,KAAA,CAAM,OAAA,GAAU,OAAA;AAEhB,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,EAAA,CAAG,IAAA,IAAQ,OAAA;AACX,IAAA,EAAA,CAAG,IAAA,IAAQ,OAAA;AACX,IAAA,EAAA,CAAG,IAAA,IAAQ,OAAA;AACX,IAAA,EAAA,CAAG,IAAA,IAAQ,OAAA;AAAA,EACb;AAEA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA,IAAA,CAAK,aAAa,CAAA,IAAK,OAAA;AACvB,MAAA,IAAA,CAAK,aAAa,CAAA,IAAK,OAAA;AAAA,IACzB;AAAA,EACF;AACF;AAiBO,SAAS,cAAc,KAAA,EAAyB;AACrD,EAAA,MAAM,GAAA,GAAM,MAAM,MAAA,CAAO,cAAA;AACzB,EAAA,MAAM,0BAAoC,IAAI,KAAA,CAAM,GAAG,CAAA,CAAE,KAAK,CAAC,CAAA;AAG/D,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAY;AACnC,EAAA,MAAM,YAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,IAAI,CAAC,UAAA,CAAW,GAAA,CAAI,IAAA,CAAK,IAAI,CAAA,EAAG;AAC9B,MAAA,SAAA,CAAU,KAAK,IAAI,CAAA;AAAA,IACrB;AACA,IAAA,UAAA,CAAW,GAAA,CAAI,KAAK,IAAI,CAAA;AACxB,IAAA,KAAA,MAAW,KAAA,IAAS,WAAA,CAAY,KAAA,EAAO,IAAI,CAAA,EAAG;AAC5C,MAAA,UAAA,CAAW,GAAA,CAAI,MAAM,IAAI,CAAA;AAAA,IAC3B;AAAA,EACF;AAIA,EAAA,IAAI,gBAAA,GAAmB,KAAA;AACvB,EAAA,IAAI,yBAAA,GAA4B,KAAA;AAChC,EAAA,KAAA,MAAW,QAAQ,SAAA,EAAW;AAC5B,IAAA,IAAI,mBAAA,CAAoB,KAAA,EAAO,IAAI,CAAA,EAAG;AACpC,MAAA,IAAI,YAAY,KAAA,EAAO,IAAI,CAAA,CAAE,MAAA,GAAS,GAAG,yBAAA,GAA4B,IAAA;AAAA,IACvE,CAAA,MAAO;AACL,MAAA,gBAAA,GAAmB,IAAA;AAAA,IACrB;AAAA,EACF;AACA,EAAA,MAAM,cAAA,GAAiB,GAAA,KAAQ,IAAA,IAAQ,gBAAA,IAAoB,yBAAA;AAE3D,EAAA,IAAI,iBAAA;AACJ,EAAA,IAAI,oBAAiC,EAAC;AAEtC,EAAA,IAAI,cAAA,EAAgB;AAClB,IAAA,iBAAA,GAAoB,UAAU,MAAA,CAAO,CAAA,CAAA,KAAK,CAAC,mBAAA,CAAoB,KAAA,EAAO,CAAC,CAAC,CAAA;AACxE,IAAA,iBAAA,GAAoB,UAAU,MAAA,CAAO,CAAA,CAAA,KAAK,mBAAA,CAAoB,KAAA,EAAO,CAAC,CAAC,CAAA;AAAA,EACzE,CAAA,MAAO;AACL,IAAA,iBAAA,GAAoB,SAAA;AAAA,EACtB;AAGA,EAAA,KAAA,MAAW,QAAQ,iBAAA,EAAmB;AACpC,IAAA,MAAM,YAAuB,GAAA,KAAQ,IAAA,GACjC,EAAE,CAAA,EAAG,GAAG,CAAA,EAAG,uBAAA,CAAwB,CAAC,CAAA,KACpC,EAAE,CAAA,EAAG,wBAAwB,CAAC,CAAA,EAAI,GAAG,CAAA,EAAE;AAC3C,IAAA,iBAAA,CAAkB,OAAO,KAAA,CAAM,KAAA,CAAM,IAAA,CAAK,KAAK,GAAI,SAAS,CAAA;AAC5D,IAAA,uBAAA,CAAwB,CAAC,CAAA,GAAI,uBAAA,CAAwB,CAAC,CAAA,GAAK,CAAA;AAAA,EAC7D;AAGA,EAAA,IAAI,cAAA,IAAkB,iBAAA,CAAkB,MAAA,GAAS,CAAA,EAAG;AAClD,IAAA,MAAM,aAAA,GAAgB,CAAA;AACtB,IAAA,KAAA,MAAW,QAAQ,iBAAA,EAAmB;AACpC,MAAA,MAAM,YAAuB,GAAA,KAAQ,IAAA,GACjC,EAAE,CAAA,EAAG,eAAe,CAAA,EAAG,uBAAA,CAAwB,aAAa,CAAA,KAC5D,EAAE,CAAA,EAAG,wBAAwB,aAAa,CAAA,EAAI,GAAG,aAAA,EAAc;AACnE,MAAA,iBAAA,CAAkB,OAAO,KAAA,CAAM,KAAA,CAAM,IAAA,CAAK,KAAK,GAAI,SAAS,CAAA;AAC5D,MAAA,uBAAA,CAAwB,aAAa,CAAA,GAAI,uBAAA,CAAwB,aAAa,CAAA,GAAK,CAAA;AAAA,IACrF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,MAAM,KAAK,IAAA,CAAK,SAAA;AAChB,IAAA,MAAM,aAAa,GAAA,KAAQ,IAAA,GAAO,GAAG,CAAA,GAAI,CAAA,GAAI,GAAG,CAAA,GAAI,CAAA;AACpD,IAAA,IAAI,eAAA,GAAkB,wBAAwB,UAAU,CAAA;AAExD,IAAA,KAAA,MAAW,KAAA,IAAS,WAAA,CAAY,KAAA,EAAO,IAAI,CAAA,EAAG;AAC5C,MAAA,IAAI,KAAA,CAAM,cAAc,IAAA,EAAM;AAE9B,MAAA,MAAM,SAAA,GAAuB,GAAA,KAAQ,IAAA,GACjC,EAAE,CAAA,EAAG,UAAA,EAAY,CAAA,EAAG,eAAA,EAAgB,GACpC,EAAE,CAAA,EAAG,eAAA,EAAiB,GAAG,UAAA,EAAW;AACxC,MAAA,iBAAA,CAAkB,OAAO,KAAA,CAAM,KAAA,CAAM,KAAA,CAAM,KAAK,GAAI,SAAS,CAAA;AAC7D,MAAA,uBAAA,CAAwB,UAAU,IAAI,eAAA,GAAkB,CAAA;AACxD,MAAA,eAAA,GAAkB,wBAAwB,UAAU,CAAA;AAAA,IACtD;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,cAAA,CAAe,OAAO,IAAI,CAAA;AAAA,EAC5B;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,aAAA,CAAc,OAAO,IAAI,CAAA;AACzB,IAAA,uBAAA,CAAwB,KAAA,EAAO,KAAK,IAAI,CAAA;AACxC,IAAA,kBAAA,CAAmB,OAAO,IAAI,CAAA;AAAA,EAChC;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,IAAA,CAAK,YAAA,GAAe,kBAAA,CAAmB,KAAA,EAAO,IAAA,CAAK,SAAU,CAAA;AAC7D,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA,CAAQ,IAAA,EAAM,KAAK,CAAA;AAAA,EACpC;AAGA,EAAA,mBAAA,CAAoB,KAAA,CAAM,MAAA,EAAQ,KAAA,CAAM,WAAA,EAAa,MAAM,SAAS,CAAA;AACpE,EAAA,8BAAA,CAA+B,KAAK,CAAA;AACpC,EAAA,yBAAA,CAA0B,KAAK,CAAA;AACjC;AAOA,SAAS,gBAAA,CAAiB,OAAmB,IAAA,EAAsC;AACjF,EAAA,OAAO,KAAA,CAAM,MAAM,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,IAAA,CAAK,IAAA,KAAS,KAAK,IAAI,CAAA;AAC1D;AAGA,SAAS,WAAA,CAAY,OAAmB,IAAA,EAA8B;AACpE,EAAA,OAAO,iBAAiB,KAAA,EAAO,IAAI,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,EAAE,CAAA;AACpD;;;AC9aO,SAAS,qBAAqB,KAAA,EAAkC;AACrE,EAAA,MAAM,OAAA,GAA2B;AAAA,IAC/B,QAAQ,EAAC;AAAA,IACT,UAAU,EAAC;AAAA,IACX,QAAQ,EAAC;AAAA,IACT,OAAO;AAAC,GACV;AAGA,EAAA,MAAM,QAAA,uBAAe,GAAA,EAAY;AAEjC,EAAA,MAAM,aAA6G,EAAC;AAEpH,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAKpB,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,KAAA,CAAM,iDAAiD,CAAA;AAC/E,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,MAAM,IAAA,GAAO,WAAW,CAAC,CAAA;AACzB,MAAA,MAAM,EAAA,GAAK,WAAW,CAAC,CAAA;AACvB,MAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,CAAC,CAAA,EAAG,MAAK,IAAK,EAAA;AACvC,MAAA,IAAI,CAAC,QAAA,CAAS,GAAA,CAAI,EAAE,CAAA,EAAG;AACrB,QAAA,QAAA,CAAS,IAAI,EAAE,CAAA;AACf,QAAA,OAAA,CAAQ,OAAO,IAAA,CAAK,EAAE,EAAA,EAAI,KAAA,EAAO,MAAM,CAAA;AAAA,MACzC;AACA,MAAA;AAAA,IACF;AAIA,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,qDAAqD,CAAA;AAClF,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,MAAM,MAAA,GAAS,SAAA,CAAU,CAAC,CAAA,CAAG,WAAA,EAAY;AACzC,MAAA,MAAM,SAAA,GAAY,SAAA,CAAU,CAAC,CAAA,CAAG,IAAA,EAAK;AACrC,MAAA,MAAM,IAAA,GAAO,SAAA,CAAU,CAAC,CAAA,CAAG,IAAA,EAAK;AAChC,MAAA,MAAM,YAAA,GAAe,UAAU,KAAA,CAAM,GAAG,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,IAAA,EAAM,CAAA;AAG3D,MAAA,KAAA,MAAW,OAAO,YAAA,EAAc;AAC9B,QAAA,WAAA,CAAY,OAAA,EAAS,UAAU,GAAG,CAAA;AAAA,MACpC;AAEA,MAAA,IAAI,QAAA,GAAsC,MAAA;AAC1C,MAAA,IAAI,MAAA,KAAW,WAAW,QAAA,GAAW,MAAA;AAAA,WAAA,IAC5B,MAAA,KAAW,YAAY,QAAA,GAAW,OAAA;AAE3C,MAAA,OAAA,CAAQ,MAAM,IAAA,CAAK;AAAA,QACjB,QAAA,EAAU,YAAA;AAAA,QACV,IAAA;AAAA,QACA,QAAA;AAAA,QACA,UAAA,EAAY,OAAA,CAAQ,QAAA,CAAS,MAAA,GAAS;AAAA,OACvC,CAAA;AACD,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,KAAA,CAAM,iDAAiD,CAAA;AAC/E,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,MAAM,SAAA,GAAY,WAAW,CAAC,CAAA;AAC9B,MAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,CAAC,CAAA,EAAG,MAAK,IAAK,EAAA;AACvC,MAAA,UAAA,CAAW,IAAA,CAAK;AAAA,QACd,IAAA,EAAM,SAAA;AAAA,QACN,KAAA;AAAA,QACA,UAAA,EAAY,QAAQ,QAAA,CAAS,MAAA;AAAA,QAC7B,UAAU;AAAC,OACZ,CAAA;AACD,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,YAAA,GAAe,IAAA,CAAK,KAAA,CAAM,qBAAqB,CAAA;AACrD,IAAA,IAAI,YAAA,IAAgB,UAAA,CAAW,MAAA,GAAS,CAAA,EAAG;AACzC,MAAA,MAAM,KAAA,GAAQ,YAAA,CAAa,CAAC,CAAA,EAAG,MAAK,IAAK,EAAA;AACzC,MAAA,UAAA,CAAW,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,CAAG,SAAS,IAAA,CAAK;AAAA,QAC/C,KAAA,EAAO,QAAQ,QAAA,CAAS,MAAA;AAAA,QACxB;AAAA,OACD,CAAA;AACD,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,IAAA,KAAS,KAAA,IAAS,UAAA,CAAW,MAAA,GAAS,CAAA,EAAG;AAC3C,MAAA,MAAM,SAAA,GAAY,WAAW,GAAA,EAAI;AACjC,MAAA,OAAA,CAAQ,OAAO,IAAA,CAAK;AAAA,QAClB,MAAM,SAAA,CAAU,IAAA;AAAA,QAChB,OAAO,SAAA,CAAU,KAAA;AAAA,QACjB,YAAY,SAAA,CAAU,UAAA;AAAA,QACtB,QAAA,EAAU,KAAK,GAAA,CAAI,OAAA,CAAQ,SAAS,MAAA,GAAS,CAAA,EAAG,UAAU,UAAU,CAAA;AAAA,QACpE,UAAU,SAAA,CAAU;AAAA,OACrB,CAAA;AACD,MAAA;AAAA,IACF;AAKA,IAAA,MAAM,WAAW,IAAA,CAAK,KAAA;AAAA,MACpB;AAAA,KACF;AACA,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,MAAM,IAAA,GAAO,SAAS,CAAC,CAAA;AACvB,MAAA,MAAM,KAAA,GAAQ,SAAS,CAAC,CAAA;AACxB,MAAA,MAAM,cAAA,GAAiB,SAAS,CAAC,CAAA;AACjC,MAAA,MAAM,EAAA,GAAK,SAAS,CAAC,CAAA;AACrB,MAAA,MAAM,KAAA,GAAQ,QAAA,CAAS,CAAC,CAAA,CAAG,IAAA,EAAK;AAGhC,MAAA,WAAA,CAAY,OAAA,EAAS,UAAU,IAAI,CAAA;AACnC,MAAA,WAAA,CAAY,OAAA,EAAS,UAAU,EAAE,CAAA;AAGjC,MAAA,MAAM,SAAA,GAAY,KAAA,CAAM,UAAA,CAAW,IAAI,IAAI,QAAA,GAAW,OAAA;AAEtD,MAAA,MAAM,SAAA,GAAY,MAAM,QAAA,CAAS,IAAI,KAAK,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA,GAAI,QAAA,GAAW,MAAA;AAE3E,MAAA,MAAM,GAAA,GAAe;AAAA,QACnB,IAAA;AAAA,QACA,EAAA;AAAA,QACA,KAAA;AAAA,QACA,SAAA;AAAA,QACA;AAAA,OACF;AAGA,MAAA,IAAI,cAAA,KAAmB,GAAA,EAAK,GAAA,CAAI,QAAA,GAAW,IAAA;AAC3C,MAAA,IAAI,cAAA,KAAmB,GAAA,EAAK,GAAA,CAAI,UAAA,GAAa,IAAA;AAE7C,MAAA,OAAA,CAAQ,QAAA,CAAS,KAAK,GAAG,CAAA;AACzB,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,iBAAiB,IAAA,CAAK,KAAA;AAAA,MAC1B;AAAA,KACF;AACA,IAAA,IAAI,cAAA,EAAgB;AAClB,MAAA,MAAM,IAAA,GAAO,eAAe,CAAC,CAAA;AAC7B,MAAA,MAAM,KAAA,GAAQ,eAAe,CAAC,CAAA;AAC9B,MAAA,MAAM,cAAA,GAAiB,eAAe,CAAC,CAAA;AACvC,MAAA,MAAM,EAAA,GAAK,eAAe,CAAC,CAAA;AAC3B,MAAA,MAAM,KAAA,GAAQ,cAAA,CAAe,CAAC,CAAA,CAAG,IAAA,EAAK;AAEtC,MAAA,WAAA,CAAY,OAAA,EAAS,UAAU,IAAI,CAAA;AACnC,MAAA,WAAA,CAAY,OAAA,EAAS,UAAU,EAAE,CAAA;AAEjC,MAAA,MAAM,SAAA,GAAY,KAAA,CAAM,UAAA,CAAW,IAAI,IAAI,QAAA,GAAW,OAAA;AACtD,MAAA,MAAM,SAAA,GAAY,MAAM,QAAA,CAAS,IAAI,KAAK,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA,GAAI,QAAA,GAAW,MAAA;AAE3E,MAAA,MAAM,MAAe,EAAE,IAAA,EAAM,EAAA,EAAI,KAAA,EAAO,WAAW,SAAA,EAAU;AAC7D,MAAA,IAAI,cAAA,KAAmB,GAAA,EAAK,GAAA,CAAI,QAAA,GAAW,IAAA;AAC3C,MAAA,IAAI,cAAA,KAAmB,GAAA,EAAK,GAAA,CAAI,UAAA,GAAa,IAAA;AAE7C,MAAA,OAAA,CAAQ,QAAA,CAAS,KAAK,GAAG,CAAA;AACzB,MAAA;AAAA,IACF;AAAA,EAKF;AAEA,EAAA,OAAO,OAAA;AACT;AAGA,SAAS,WAAA,CAAY,OAAA,EAA0B,QAAA,EAAuB,EAAA,EAAkB;AACtF,EAAA,IAAI,CAAC,QAAA,CAAS,GAAA,CAAI,EAAE,CAAA,EAAG;AACrB,IAAA,QAAA,CAAS,IAAI,EAAE,CAAA;AACf,IAAA,OAAA,CAAQ,MAAA,CAAO,KAAK,EAAE,EAAA,EAAI,OAAO,EAAA,EAAI,IAAA,EAAM,eAAe,CAAA;AAAA,EAC5D;AACF;;;ACrLO,SAAS,mBAAA,CAAoB,MAAc,MAAA,EAA6B;AAC7E,EAAA,MAAM,KAAA,GAAQ,KAAK,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAA,EAAM,EAAE,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,MAAA,GAAS,CAAA,IAAK,CAAC,CAAA,CAAE,UAAA,CAAW,IAAI,CAAC,CAAA;AACjG,EAAA,MAAM,OAAA,GAAU,qBAAqB,KAAK,CAAA;AAE1C,EAAA,IAAI,OAAA,CAAQ,MAAA,CAAO,MAAA,KAAW,CAAA,EAAG,OAAO,EAAA;AAExC,EAAA,MAAM,WAAW,MAAA,CAAO,QAAA;AAGxB,EAAA,MAAM,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAC3B,EAAA,MAAM,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAC3B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,WAAW,GAAA,GAAM,QAAA;AAI5B,EAAA,MAAM,QAAA,uBAAe,GAAA,EAAoB;AACzC,EAAA,OAAA,CAAQ,MAAA,CAAO,OAAA,CAAQ,CAAC,CAAA,EAAG,CAAA,KAAM,SAAS,GAAA,CAAI,CAAA,CAAE,EAAA,EAAI,CAAC,CAAC,CAAA;AAEtD,EAAA,MAAM,MAAA,GAAS,CAAA;AACf,EAAA,MAAM,cAAA,GAAiB,OAAA,CAAQ,MAAA,CAAO,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,KAAA,CAAM,MAAA,GAAS,CAAA,GAAI,MAAA,GAAS,CAAC,CAAA;AAC9E,EAAA,MAAM,OAAA,GAAU,eAAe,GAAA,CAAI,CAAA,CAAA,KAAK,KAAK,IAAA,CAAK,CAAA,GAAI,CAAC,CAAC,CAAA;AACxD,EAAA,MAAM,SAAA,GAAY,CAAA;AAIlB,EAAA,MAAM,WAAA,GAAwB,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,CAAC,CAAC,CAAA,CAAE,KAAK,CAAC,CAAA;AAEtF,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,QAAA,EAAU;AAClC,IAAA,MAAM,EAAA,GAAK,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA;AAChC,IAAA,MAAM,EAAA,GAAK,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAC9B,IAAA,IAAI,OAAO,EAAA,EAAI;AACf,IAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,EAAE,CAAA;AAC1B,IAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,EAAE,CAAA;AAE1B,IAAA,MAAM,MAAA,GAAS,GAAA,CAAI,KAAA,CAAM,MAAA,GAAS,CAAA;AAClC,IAAA,MAAM,UAAU,EAAA,GAAK,EAAA;AACrB,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,OAAO,CAAA;AACzC,IAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;AAC5B,MAAA,WAAA,CAAY,CAAC,CAAA,GAAI,IAAA,CAAK,IAAI,WAAA,CAAY,CAAC,GAAI,MAAM,CAAA;AAAA,IACnD;AAAA,EACF;AAGA,EAAA,MAAM,GAAA,GAAgB,CAAC,OAAA,CAAQ,CAAC,CAAE,CAAA;AAClC,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,MAAM,MAAM,IAAA,CAAK,GAAA;AAAA,MACf,QAAQ,CAAA,GAAI,CAAC,CAAA,GAAK,OAAA,CAAQ,CAAC,CAAA,GAAK,CAAA;AAAA,MAChC,WAAA,CAAY,CAAA,GAAI,CAAC,CAAA,GAAK,CAAA;AAAA,MACtB;AAAA,KACF;AACA,IAAA,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAA,GAAI,CAAC,CAAA,GAAK,GAAA;AAAA,EACzB;AAMA,EAAA,MAAM,YAAsB,EAAC;AAC7B,EAAA,MAAM,YAAsB,EAAC;AAC7B,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAAoB;AAC5C,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAoB;AAC1C,EAAA,MAAM,OAAA,uBAAc,GAAA,EAAoB;AACxC,EAAA,MAAM,gBAAiG,EAAC;AAExG,EAAA,IAAI,IAAA,GAAO,SAAA;AAEX,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AAEhD,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,MAAA,IAAI,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,CAAG,eAAe,CAAA,EAAG;AACvC,QAAA,IAAA,IAAQ,CAAA;AACR,QAAA,WAAA,CAAY,GAAA,CAAI,CAAA,EAAG,IAAA,GAAO,CAAC,CAAA;AAAA,MAC7B;AAAA,IACF;AAGA,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,MAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,OAAA,CAAQ,OAAO,CAAC,CAAA,CAAG,QAAA,CAAS,MAAA,EAAQ,CAAA,EAAA,EAAK;AAC3D,QAAA,IAAI,OAAA,CAAQ,OAAO,CAAC,CAAA,CAAG,SAAS,CAAC,CAAA,CAAG,UAAU,CAAA,EAAG;AAC/C,UAAA,IAAA,IAAQ,CAAA;AACR,UAAA,OAAA,CAAQ,IAAI,CAAA,EAAG,CAAC,CAAA,CAAA,EAAI,CAAC,IAAI,IAAI,CAAA;AAC7B,UAAA,IAAA,IAAQ,CAAA;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAEA,IAAA,IAAA,IAAQ,CAAA;AAER,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;AAC9B,IAAA,MAAM,MAAA,GAAS,GAAA,CAAI,IAAA,KAAS,GAAA,CAAI,EAAA;AAEhC,IAAA,IAAI,MAAA,EAAQ;AAEV,MAAA,SAAA,CAAU,CAAC,IAAI,IAAA,GAAO,CAAA;AACtB,MAAA,SAAA,CAAU,CAAC,CAAA,GAAI,IAAA;AACf,MAAA,IAAA,IAAQ,CAAA;AAAA,IACV,CAAA,MAAO;AAEL,MAAA,SAAA,CAAU,CAAC,CAAA,GAAI,IAAA;AACf,MAAA,SAAA,CAAU,CAAC,IAAI,IAAA,GAAO,CAAA;AACtB,MAAA,IAAA,IAAQ,CAAA;AAAA,IACV;AAGA,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AAC7C,MAAA,IAAI,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA,CAAG,eAAe,CAAA,EAAG;AACtC,QAAA,IAAA,IAAQ,CAAA;AACR,QAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;AAC5B,QAAA,MAAM,MAAA,GAAS,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;AACpC,QAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,GAAG,MAAA,CAAO,IAAI,CAAA,CAAA,KAAK,CAAA,CAAE,MAAM,CAAC,CAAA,GAAI,CAAA;AACxD,QAAA,MAAM,OAAA,GAAU,OAAO,MAAA,GAAS,CAAA;AAGhC,QAAA,MAAM,OAAO,QAAA,CAAS,GAAA,CAAI,KAAK,QAAA,CAAS,CAAC,CAAE,CAAA,IAAK,CAAA;AAChD,QAAA,IAAI,EAAA;AACJ,QAAA,IAAI,IAAA,CAAK,aAAa,MAAA,EAAQ;AAC5B,UAAA,EAAA,GAAK,GAAA,CAAI,IAAI,CAAA,GAAK,MAAA,GAAS,CAAA;AAAA,QAC7B,CAAA,MAAA,IAAW,IAAA,CAAK,QAAA,KAAa,OAAA,EAAS;AACpC,UAAA,EAAA,GAAK,GAAA,CAAI,IAAI,CAAA,GAAK,CAAA;AAAA,QACpB,CAAA,MAAO;AAEL,UAAA,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,IAAU,CAAA,EAAG;AAC7B,YAAA,MAAM,QAAQ,QAAA,CAAS,GAAA,CAAI,KAAK,QAAA,CAAS,CAAC,CAAE,CAAA,IAAK,IAAA;AACjD,YAAA,EAAA,GAAK,IAAA,CAAK,KAAA,CAAA,CAAO,GAAA,CAAI,IAAI,CAAA,GAAK,GAAA,CAAI,KAAK,CAAA,IAAM,CAAC,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,SAAS,CAAC,CAAA;AAAA,UACzE,CAAA,MAAO;AACL,YAAA,EAAA,GAAK,IAAI,IAAI,CAAA,GAAK,IAAA,CAAK,KAAA,CAAM,SAAS,CAAC,CAAA;AAAA,UACzC;AAAA,QACF;AACA,QAAA,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,EAAE,CAAA;AAEnB,QAAA,aAAA,CAAc,IAAA,CAAK,EAAE,CAAA,EAAG,EAAA,EAAI,CAAA,EAAG,IAAA,EAAM,KAAA,EAAO,MAAA,EAAQ,MAAA,EAAQ,OAAA,EAAS,KAAA,EAAO,MAAA,EAAQ,CAAA;AACpF,QAAA,IAAA,IAAQ,OAAA;AAAA,MACV;AAAA,IACF;AAGA,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,MAAA,IAAI,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,CAAG,aAAa,CAAA,EAAG;AACrC,QAAA,IAAA,IAAQ,CAAA;AACR,QAAA,SAAA,CAAU,GAAA,CAAI,GAAG,IAAI,CAAA;AACrB,QAAA,IAAA,IAAQ,CAAA;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAEA,EAAA,IAAA,IAAQ,CAAA;AACR,EAAA,MAAM,OAAA,GAAU,IAAA;AAChB,EAAA,MAAM,SAAS,OAAA,GAAU,SAAA;AAGzB,EAAA,MAAM,MAAA,GAAS,GAAA,CAAI,GAAA,CAAI,MAAA,GAAS,CAAC,CAAA,IAAK,CAAA;AACtC,EAAA,MAAM,QAAA,GAAW,OAAA,CAAQ,OAAA,CAAQ,MAAA,GAAS,CAAC,CAAA,IAAK,CAAA;AAChD,EAAA,IAAI,MAAA,GAAS,SAAS,QAAA,GAAW,CAAA;AAGjC,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AAChD,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;AAC9B,IAAA,IAAI,GAAA,CAAI,IAAA,KAAS,GAAA,CAAI,EAAA,EAAI;AACvB,MAAA,MAAM,EAAA,GAAK,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA;AAChC,MAAA,MAAM,YAAY,GAAA,CAAI,EAAE,IAAK,CAAA,GAAI,CAAA,GAAI,IAAI,KAAA,CAAM,MAAA;AAC/C,MAAA,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,SAAA,GAAY,CAAC,CAAA;AAAA,IACzC;AAAA,EACF;AACA,EAAA,KAAA,MAAW,MAAM,aAAA,EAAe;AAC9B,IAAA,MAAA,GAAS,KAAK,GAAA,CAAI,MAAA,EAAQ,GAAG,CAAA,GAAI,EAAA,CAAG,QAAQ,CAAC,CAAA;AAAA,EAC/C;AAEA,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,MAAA,EAAQ,MAAA,GAAS,CAAC,CAAA;AAI1C,EAAA,SAAS,YAAA,CAAa,EAAA,EAAY,IAAA,EAAc,KAAA,EAAqB;AACnE,IAAA,MAAM,CAAA,GAAI,KAAA,CAAM,MAAA,GAAS,CAAA,GAAI,MAAA,GAAS,CAAA;AACtC,IAAA,MAAM,IAAA,GAAO,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,IAAI,CAAC,CAAA;AAElC,IAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAI,CAAA,GAAI,EAAA;AACtB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,CAAA;AAC1D,IAAA,MAAA,CAAO,IAAA,GAAO,CAAA,GAAI,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,EAAA;AAE9B,IAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAA,GAAO,CAAC,CAAA,GAAI,CAAA;AAC1B,IAAA,MAAA,CAAO,OAAO,CAAA,GAAI,CAAC,CAAA,CAAG,IAAA,GAAO,CAAC,CAAA,GAAI,CAAA;AAClC,IAAA,MAAM,EAAA,GAAK,OAAO,CAAA,GAAI,MAAA;AACtB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,CAAG,IAAA,GAAO,CAAC,CAAA,GAAI,MAAM,CAAC,CAAA;AAE1E,IAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAA,GAAO,CAAC,CAAA,GAAI,EAAA;AAC1B,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA,CAAG,IAAA,GAAO,CAAC,CAAA,GAAI,CAAA;AAC9D,IAAA,MAAA,CAAO,OAAO,CAAA,GAAI,CAAC,CAAA,CAAG,IAAA,GAAO,CAAC,CAAA,GAAI,EAAA;AAAA,EACpC;AAIA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,MAAM,CAAA,GAAI,IAAI,CAAC,CAAA;AACf,IAAA,KAAA,IAAS,CAAA,GAAI,SAAA,EAAW,CAAA,IAAK,OAAA,EAAS,CAAA,EAAA,EAAK;AACzC,MAAA,MAAA,CAAO,CAAC,CAAA,CAAG,CAAC,CAAA,GAAI,CAAA;AAAA,IAClB;AAAA,EACF;AAIA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;AAC9B,IAAA,YAAA,CAAa,GAAA,CAAI,CAAC,CAAA,EAAI,CAAA,EAAG,MAAM,KAAK,CAAA;AACpC,IAAA,YAAA,CAAa,GAAA,CAAI,CAAC,CAAA,EAAI,OAAA,EAAS,MAAM,KAAK,CAAA;AAG1C,IAAA,IAAI,CAAC,QAAA,EAAU;AACb,MAAA,MAAA,CAAO,IAAI,CAAC,CAAE,CAAA,CAAG,SAAA,GAAY,CAAC,CAAA,GAAI,EAAA;AAClC,MAAA,MAAA,CAAO,GAAA,CAAI,CAAC,CAAE,CAAA,CAAG,OAAO,CAAA,GAAI,EAAA;AAAA,IAC9B;AAAA,EACF;AAIA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AAChD,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;AAC9B,IAAA,MAAM,EAAA,GAAK,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA;AAChC,IAAA,MAAM,EAAA,GAAK,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAC9B,IAAA,MAAM,KAAA,GAAQ,IAAI,EAAE,CAAA;AACpB,IAAA,MAAM,GAAA,GAAM,IAAI,EAAE,CAAA;AAClB,IAAA,MAAM,SAAS,EAAA,KAAO,EAAA;AACtB,IAAA,MAAM,QAAA,GAAW,IAAI,SAAA,KAAc,QAAA;AACnC,IAAA,MAAM,QAAA,GAAW,IAAI,SAAA,KAAc,QAAA;AAGnC,IAAA,MAAM,QAAA,GAAW,QAAA,GAAY,QAAA,GAAW,GAAA,GAAM,QAAA,GAAO,CAAA;AAErD,IAAA,IAAI,MAAA,EAAQ;AAKV,MAAA,MAAM,EAAA,GAAK,UAAU,CAAC,CAAA;AACtB,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,CAAC,CAAA;AAG3B,MAAA,MAAA,CAAO,KAAK,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AACrB,MAAA,KAAA,IAAS,CAAA,GAAI,KAAA,GAAQ,CAAA,EAAG,CAAA,GAAI,KAAA,GAAQ,KAAA,EAAO,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,QAAA;AACjE,MAAA,MAAA,CAAO,QAAQ,KAAK,CAAA,CAAG,EAAE,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAG9C,MAAA,MAAA,CAAO,KAAA,GAAQ,KAAK,CAAA,CAAG,EAAA,GAAK,CAAC,CAAA,GAAI,CAAA;AACjC,MAAA,MAAM,MAAA,GAAS,QAAQ,KAAA,GAAQ,CAAA;AAC/B,MAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACzC,QAAA,IAAI,MAAA,GAAS,CAAA,GAAI,MAAA,EAAQ,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA,CAAG,EAAA,GAAK,CAAC,CAAA,GAAI,GAAA,CAAI,KAAA,CAAM,CAAC,CAAA;AAAA,MACpE;AAGA,MAAA,MAAM,YAAY,QAAA,GAAY,QAAA,GAAW,GAAA,GAAM,QAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AACxE,MAAA,MAAA,CAAO,KAAK,CAAA,CAAG,EAAA,GAAK,CAAC,CAAA,GAAI,SAAA;AACzB,MAAA,KAAA,IAAS,CAAA,GAAI,KAAA,GAAQ,CAAA,EAAG,CAAA,GAAI,KAAA,GAAQ,KAAA,EAAO,CAAA,EAAA,EAAK,MAAA,CAAO,CAAC,CAAA,CAAG,EAAA,GAAK,CAAC,CAAA,GAAI,QAAA;AACrE,MAAA,MAAA,CAAO,QAAQ,KAAK,CAAA,CAAG,KAAK,CAAC,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAAA,IACpD,CAAA,MAAO;AAEL,MAAA,MAAM,MAAA,GAAS,UAAU,CAAC,CAAA;AAC1B,MAAA,MAAM,MAAA,GAAS,UAAU,CAAC,CAAA;AAC1B,MAAA,MAAM,cAAc,KAAA,GAAQ,GAAA;AAG5B,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,KAAA,GAAQ,OAAO,CAAC,CAAA;AACzC,MAAA,MAAM,aAAa,IAAA,GAAO,IAAA,CAAK,MAAM,GAAA,CAAI,KAAA,CAAM,SAAS,CAAC,CAAA;AACzD,MAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACzC,QAAA,MAAM,KAAK,UAAA,GAAa,CAAA;AACxB,QAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,MAAM,CAAA,GAAI,GAAA,CAAI,KAAA,CAAM,CAAC,CAAA;AAAA,MAC/D;AAGA,MAAA,IAAI,WAAA,EAAa;AACf,QAAA,KAAA,IAAS,CAAA,GAAI,KAAA,GAAQ,CAAA,EAAG,CAAA,GAAI,GAAA,EAAK,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,MAAM,CAAA,GAAI,QAAA;AAE3D,QAAA,MAAM,KAAK,QAAA,GAAY,QAAA,GAAW,GAAA,GAAM,QAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AACjE,QAAA,MAAA,CAAO,GAAG,CAAA,CAAG,MAAM,CAAA,GAAI,EAAA;AAAA,MACzB,CAAA,MAAO;AACL,QAAA,KAAA,IAAS,CAAA,GAAI,GAAA,GAAM,CAAA,EAAG,CAAA,GAAI,KAAA,EAAO,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,MAAM,CAAA,GAAI,QAAA;AAC3D,QAAA,MAAM,KAAK,QAAA,GAAY,QAAA,GAAW,GAAA,GAAM,QAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AACjE,QAAA,MAAA,CAAO,GAAG,CAAA,CAAG,MAAM,CAAA,GAAI,EAAA;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAIA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;AAC9B,IAAA,MAAM,IAAA,GAAO,WAAA,CAAY,GAAA,CAAI,CAAC,CAAA;AAC9B,IAAA,MAAM,IAAA,GAAO,SAAA,CAAU,GAAA,CAAI,CAAC,CAAA;AAC5B,IAAA,IAAI,IAAA,KAAS,MAAA,IAAa,IAAA,KAAS,MAAA,EAAW;AAG9C,IAAA,IAAI,KAAA,GAAQ,MAAA;AACZ,IAAA,IAAI,KAAA,GAAQ,CAAA;AACZ,IAAA,KAAA,IAAS,IAAI,KAAA,CAAM,UAAA,EAAY,CAAA,IAAK,KAAA,CAAM,UAAU,CAAA,EAAA,EAAK;AACvD,MAAA,IAAI,CAAA,IAAK,OAAA,CAAQ,QAAA,CAAS,MAAA,EAAQ;AAClC,MAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;AAC9B,MAAA,MAAM,CAAA,GAAI,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA,IAAK,CAAA;AACpC,MAAA,MAAM,CAAA,GAAI,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA,IAAK,CAAA;AAClC,MAAA,KAAA,GAAQ,IAAA,CAAK,IAAI,KAAA,EAAO,GAAA,CAAI,KAAK,GAAA,CAAI,CAAA,EAAG,CAAC,CAAC,CAAE,CAAA;AAC5C,MAAA,KAAA,GAAQ,IAAA,CAAK,IAAI,KAAA,EAAO,GAAA,CAAI,KAAK,GAAA,CAAI,CAAA,EAAG,CAAC,CAAC,CAAE,CAAA;AAAA,IAC9C;AAEA,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,QAAQ,CAAC,CAAA;AACnC,IAAA,MAAM,SAAS,IAAA,CAAK,GAAA,CAAI,MAAA,GAAS,CAAA,EAAG,QAAQ,CAAC,CAAA;AAG7C,IAAA,MAAA,CAAO,KAAK,CAAA,CAAG,IAAI,CAAA,GAAI,EAAA;AACvB,IAAA,KAAA,IAAS,CAAA,GAAI,KAAA,GAAQ,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,CAAA;AAC5D,IAAA,MAAA,CAAO,MAAM,CAAA,CAAG,IAAI,CAAA,GAAI,EAAA;AAExB,IAAA,MAAM,QAAA,GAAW,KAAA,CAAM,KAAA,GAAQ,CAAA,EAAG,KAAA,CAAM,IAAI,CAAA,EAAA,EAAK,KAAA,CAAM,KAAK,CAAA,CAAA,CAAA,GAAM,KAAA,CAAM,IAAA;AACxE,IAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,QAAA,CAAS,UAAU,KAAA,GAAQ,CAAA,GAAI,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;AAClE,MAAA,MAAA,CAAO,QAAQ,CAAA,GAAI,CAAC,EAAG,IAAI,CAAA,GAAI,SAAS,CAAC,CAAA;AAAA,IAC3C;AAGA,IAAA,MAAA,CAAO,KAAK,CAAA,CAAG,IAAI,CAAA,GAAI,EAAA;AACvB,IAAA,KAAA,IAAS,CAAA,GAAI,KAAA,GAAQ,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,CAAA;AAC5D,IAAA,MAAA,CAAO,MAAM,CAAA,CAAG,IAAI,CAAA,GAAI,EAAA;AAGxB,IAAA,KAAA,IAAS,CAAA,GAAI,IAAA,GAAO,CAAA,EAAG,CAAA,GAAI,MAAM,CAAA,EAAA,EAAK;AACpC,MAAA,MAAA,CAAO,KAAK,CAAA,CAAG,CAAC,CAAA,GAAI,CAAA;AACpB,MAAA,MAAA,CAAO,MAAM,CAAA,CAAG,CAAC,CAAA,GAAI,CAAA;AAAA,IACvB;AAGA,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AAC9C,MAAA,MAAM,KAAK,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAC,CAAA,CAAA,EAAI,CAAC,CAAA,CAAE,CAAA;AAClC,MAAA,IAAI,OAAO,MAAA,EAAW;AACtB,MAAA,MAAM,WAAW,SAAA,EAAU;AAC3B,MAAA,MAAA,CAAO,KAAK,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AACrB,MAAA,KAAA,IAAS,CAAA,GAAI,KAAA,GAAQ,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,KAAK,MAAA,CAAO,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,QAAA;AAC1D,MAAA,MAAA,CAAO,MAAM,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AAEtB,MAAA,MAAM,MAAA,GAAS,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAG,KAAA;AAClC,MAAA,IAAI,MAAA,EAAQ;AACV,QAAA,MAAM,IAAA,GAAO,IAAI,MAAM,CAAA,CAAA,CAAA;AACvB,QAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,IAAA,CAAK,UAAU,KAAA,GAAQ,CAAA,GAAI,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;AAC9D,UAAA,MAAA,CAAO,QAAQ,CAAA,GAAI,CAAC,EAAG,EAAE,CAAA,GAAI,KAAK,CAAC,CAAA;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAIA,EAAA,KAAA,MAAW,MAAM,aAAA,EAAe;AAE9B,IAAA,YAAA,CAAa,MAAA,EAAQ,GAAG,CAAA,GAAI,EAAA,CAAG,OAAO,EAAA,CAAG,CAAA,GAAI,GAAG,MAAM,CAAA;AAEtD,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA;AACtB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,QAAQ,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,EAAA,CAAG,CAAA,GAAI,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,CAAA;AACjE,IAAA,MAAA,CAAO,EAAA,CAAG,IAAI,EAAA,CAAG,KAAA,GAAQ,CAAC,CAAA,CAAG,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA;AAErC,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACxC,MAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAA,GAAI,CAAA,GAAI,CAAA;AACtB,MAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,CAAA;AACpB,MAAA,MAAA,CAAO,GAAG,CAAA,GAAI,EAAA,CAAG,QAAQ,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,CAAA;AACnC,MAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,EAAA,CAAG,MAAM,CAAC,CAAA,CAAG,QAAQ,CAAA,EAAA,EAAK;AAC5C,QAAA,MAAA,CAAO,EAAA,CAAG,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA,CAAG,KAAA,CAAM,CAAC,CAAA,CAAG,CAAC,CAAA;AAAA,MAC5C;AAAA,IACF;AAEA,IAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAA,GAAI,EAAA,CAAG,MAAA,GAAS,CAAA;AAC9B,IAAA,MAAA,CAAO,EAAA,CAAG,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AACpB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,CAAG,KAAA,GAAQ,CAAA,EAAG,CAAA,EAAA,EAAK,MAAA,CAAO,EAAA,CAAG,CAAA,GAAI,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,CAAA;AAC/D,IAAA,MAAA,CAAO,GAAG,CAAA,GAAI,EAAA,CAAG,QAAQ,CAAC,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AAAA,EACrC;AAEA,EAAA,OAAO,eAAe,MAAM,CAAA;AAG5B,EAAA,SAAS,SAAA,GAAoB;AAC3B,IAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,EAC1B;AACF;;;ACzXO,SAAS,kBAAkB,KAAA,EAA+B;AAC/D,EAAA,MAAM,OAAA,GAAwB;AAAA,IAC5B,SAAS,EAAC;AAAA,IACV,eAAe,EAAC;AAAA,IAChB,YAAY;AAAC,GACf;AAGA,EAAA,MAAM,QAAA,uBAAe,GAAA,EAAuB;AAE5C,EAAA,IAAI,gBAAA,GAA0C,IAAA;AAE9C,EAAA,IAAI,YAAA,GAAiC,IAAA;AACrC,EAAA,IAAI,UAAA,GAAa,CAAA;AAEjB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAGpB,IAAA,IAAI,YAAA,IAAgB,aAAa,CAAA,EAAG;AAClC,MAAA,IAAI,SAAS,GAAA,EAAK;AAChB,QAAA,UAAA,EAAA;AACA,QAAA,IAAI,eAAe,CAAA,EAAG;AACpB,UAAA,YAAA,GAAe,IAAA;AAAA,QACjB;AACA,QAAA;AAAA,MACF;AAGA,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,KAAA,CAAM,aAAa,CAAA;AAC3C,MAAA,IAAI,UAAA,EAAY;AACd,QAAA,YAAA,CAAa,UAAA,GAAa,WAAW,CAAC,CAAA;AACtC,QAAA;AAAA,MACF;AAGA,MAAA,MAAM,MAAA,GAAS,YAAY,IAAI,CAAA;AAC/B,MAAA,IAAI,MAAA,EAAQ;AACV,QAAA,IAAI,OAAO,QAAA,EAAU;AACnB,UAAA,YAAA,CAAa,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;AAAA,QACzC,CAAA,MAAO;AACL,UAAA,YAAA,CAAa,UAAA,CAAW,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;AAAA,QAC5C;AAAA,MACF;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,0BAA0B,CAAA;AACrD,IAAA,IAAI,OAAA,EAAS;AACX,MAAA,gBAAA,GAAmB,EAAE,IAAA,EAAM,OAAA,CAAQ,CAAC,CAAA,EAAI,QAAA,EAAU,EAAC,EAAE;AACrD,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,IAAA,KAAS,OAAO,gBAAA,EAAkB;AACpC,MAAA,OAAA,CAAQ,UAAA,CAAW,KAAK,gBAAgB,CAAA;AACxC,MAAA,gBAAA,GAAmB,IAAA;AACnB,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,KAAA,CAAM,sCAAsC,CAAA;AACzE,IAAA,IAAI,eAAA,EAAiB;AACnB,MAAA,MAAM,EAAA,GAAK,gBAAgB,CAAC,CAAA;AAC5B,MAAA,MAAM,OAAA,GAAU,gBAAgB,CAAC,CAAA;AACjC,MAAA,MAAM,GAAA,GAAM,WAAA,CAAY,QAAA,EAAU,EAAE,CAAA;AACpC,MAAA,IAAI,OAAA,EAAS;AACX,QAAA,GAAA,CAAI,KAAA,GAAQ,CAAA,EAAG,EAAE,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAA;AAAA,MAC9B;AACA,MAAA,YAAA,GAAe,GAAA;AACf,MAAA,UAAA,GAAa,CAAA;AACb,MAAA,IAAI,gBAAA,EAAkB;AACpB,QAAA,gBAAA,CAAiB,QAAA,CAAS,KAAK,EAAE,CAAA;AAAA,MACnC;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,KAAA,CAAM,oCAAoC,CAAA;AACtE,IAAA,IAAI,cAAA,EAAgB;AAClB,MAAA,MAAM,EAAA,GAAK,eAAe,CAAC,CAAA;AAC3B,MAAA,MAAM,OAAA,GAAU,eAAe,CAAC,CAAA;AAChC,MAAA,MAAM,GAAA,GAAM,WAAA,CAAY,QAAA,EAAU,EAAE,CAAA;AACpC,MAAA,IAAI,OAAA,EAAS;AACX,QAAA,GAAA,CAAI,KAAA,GAAQ,CAAA,EAAG,EAAE,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAA;AAAA,MAC9B;AACA,MAAA,IAAI,gBAAA,EAAkB;AACpB,QAAA,gBAAA,CAAiB,QAAA,CAAS,KAAK,EAAE,CAAA;AAAA,MACnC;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,KAAA,CAAM,wCAAwC,CAAA;AAC5E,IAAA,IAAI,gBAAA,EAAkB;AACpB,MAAA,MAAM,GAAA,GAAM,WAAA,CAAY,QAAA,EAAU,gBAAA,CAAiB,CAAC,CAAE,CAAA;AACtD,MAAA,GAAA,CAAI,UAAA,GAAa,iBAAiB,CAAC,CAAA;AACnC,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,KAAA,CAAM,qBAAqB,CAAA;AACxD,IAAA,IAAI,eAAA,EAAiB;AAEnB,MAAA,MAAM,IAAA,GAAO,gBAAgB,CAAC,CAAA;AAC9B,MAAA,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,qCAAqC,CAAA,EAAG;AACtD,QAAA,MAAM,GAAA,GAAM,WAAA,CAAY,QAAA,EAAU,eAAA,CAAgB,CAAC,CAAE,CAAA;AACrD,QAAA,MAAM,MAAA,GAAS,YAAY,IAAI,CAAA;AAC/B,QAAA,IAAI,MAAA,EAAQ;AACV,UAAA,IAAI,OAAO,QAAA,EAAU;AACnB,YAAA,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;AAAA,UAChC,CAAA,MAAO;AACL,YAAA,GAAA,CAAI,UAAA,CAAW,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;AAAA,UACnC;AAAA,QACF;AACA,QAAA;AAAA,MACF;AAAA,IACF;AAMA,IAAA,MAAM,GAAA,GAAM,kBAAkB,IAAI,CAAA;AAClC,IAAA,IAAI,GAAA,EAAK;AAEP,MAAA,WAAA,CAAY,QAAA,EAAU,IAAI,IAAI,CAAA;AAC9B,MAAA,WAAA,CAAY,QAAA,EAAU,IAAI,EAAE,CAAA;AAC5B,MAAA,OAAA,CAAQ,aAAA,CAAc,KAAK,GAAG,CAAA;AAC9B,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAA,CAAQ,OAAA,GAAU,CAAC,GAAG,QAAA,CAAS,QAAQ,CAAA;AACvC,EAAA,OAAO,OAAA;AACT;AAGA,SAAS,WAAA,CAAY,UAAkC,EAAA,EAAuB;AAC5E,EAAA,IAAI,GAAA,GAAM,QAAA,CAAS,GAAA,CAAI,EAAE,CAAA;AACzB,EAAA,IAAI,CAAC,GAAA,EAAK;AACR,IAAA,GAAA,GAAM,EAAE,IAAI,KAAA,EAAO,EAAA,EAAI,YAAY,EAAC,EAAG,OAAA,EAAS,EAAC,EAAE;AACnD,IAAA,QAAA,CAAS,GAAA,CAAI,IAAI,GAAG,CAAA;AAAA,EACtB;AACA,EAAA,OAAO,GAAA;AACT;AAGA,SAAS,YAAY,IAAA,EAAiE;AACpF,EAAA,MAAM,UAAU,IAAA,CAAK,IAAA,EAAK,CAAE,OAAA,CAAQ,MAAM,EAAE,CAAA;AAC5C,EAAA,IAAI,CAAC,SAAS,OAAO,IAAA;AAGrB,EAAA,IAAI,UAAA,GAAwC,EAAA;AAC5C,EAAA,IAAI,IAAA,GAAO,OAAA;AACX,EAAA,IAAI,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;AACzB,IAAA,UAAA,GAAa,KAAK,CAAC,CAAA;AACnB,IAAA,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,IAAA,EAAK;AAAA,EAC5B;AAGA,EAAA,MAAM,WAAA,GAAc,IAAA,CAAK,KAAA,CAAM,gCAAgC,CAAA;AAC/D,EAAA,IAAI,WAAA,EAAa;AACf,IAAA,MAAMA,KAAAA,GAAO,WAAA,CAAY,CAAC,CAAA,CAAG,IAAA,EAAK;AAClC,IAAA,MAAMC,KAAAA,GAAO,WAAA,CAAY,CAAC,CAAA,EAAG,IAAA,EAAK;AAElC,IAAA,MAAMC,YAAWF,KAAAA,CAAK,QAAA,CAAS,GAAG,CAAA,IAAK,IAAA,CAAK,SAAS,GAAG,CAAA;AACxD,IAAA,MAAMG,cAAaH,KAAAA,CAAK,QAAA,CAAS,GAAG,CAAA,IAAK,IAAA,CAAK,SAAS,GAAG,CAAA;AAC1D,IAAA,OAAO;AAAA,MACL,MAAA,EAAQ;AAAA,QACN,UAAA;AAAA,QACA,IAAA,EAAMA,KAAAA,CAAK,OAAA,CAAQ,OAAA,EAAS,EAAE,CAAA;AAAA,QAC9B,MAAMC,KAAAA,IAAQ,MAAA;AAAA,QACd,QAAA,EAAAC,SAAAA;AAAA,QACA,UAAA,EAAAC;AAAA,OACF;AAAA,MACA,QAAA,EAAU;AAAA,KACZ;AAAA,EACF;AAIA,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;AAC9B,EAAA,IAAI,IAAA;AACJ,EAAA,IAAI,IAAA;AAEJ,EAAA,IAAI,KAAA,CAAM,UAAU,CAAA,EAAG;AAErB,IAAA,IAAA,GAAO,MAAM,CAAC,CAAA;AACd,IAAA,IAAA,GAAO,KAAA,CAAM,KAAA,CAAM,CAAC,CAAA,CAAE,KAAK,GAAG,CAAA;AAAA,EAChC,CAAA,MAAO;AACL,IAAA,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA,IAAK,IAAA;AAAA,EACrB;AAEA,EAAA,MAAM,QAAA,GAAW,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA;AAClC,EAAA,MAAM,UAAA,GAAa,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA;AAEpC,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ;AAAA,MACN,UAAA;AAAA,MACA,IAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,OAAA,EAAS,EAAE,CAAA;AAAA,MAC9B,MAAM,IAAA,IAAQ,MAAA;AAAA,MACd,QAAA;AAAA,MACA;AAAA,KACF;AAAA,IACA,QAAA,EAAU;AAAA,GACZ;AACF;AAGA,SAAS,kBAAkB,IAAA,EAAwC;AAGjE,EAAA,MAAM,QAAQ,IAAA,CAAK,KAAA;AAAA,IACjB;AAAA,GACF;AACA,EAAA,IAAI,CAAC,OAAO,OAAO,IAAA;AAEnB,EAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,EAAA,MAAM,eAAA,GAAkB,KAAA,CAAM,CAAC,CAAA,IAAK,MAAA;AACpC,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,CAAC,CAAA,CAAG,IAAA,EAAK;AAC7B,EAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,CAAC,CAAA,IAAK,MAAA;AAClC,EAAA,MAAM,EAAA,GAAK,MAAM,CAAC,CAAA;AAClB,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,CAAC,CAAA,EAAG,MAAK,IAAK,MAAA;AAElC,EAAA,MAAM,MAAA,GAAS,WAAW,KAAK,CAAA;AAC/B,EAAA,IAAI,CAAC,QAAQ,OAAO,IAAA;AAEpB,EAAA,OAAO,EAAE,IAAA,EAAM,EAAA,EAAI,IAAA,EAAM,MAAA,CAAO,IAAA,EAAM,QAAA,EAAU,MAAA,CAAO,QAAA,EAAU,KAAA,EAAO,eAAA,EAAiB,aAAA,EAAc;AACzG;AAOA,SAAS,WAAW,KAAA,EAA2E;AAC7F,EAAA,QAAQ,KAAA;AAAO,IACb,KAAK,MAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,MAAA,EAAO;AAAA,IAC7D,KAAK,MAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,MAAA,EAAO;AAAA,IAC7D,KAAK,KAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,MAAA,EAAO;AAAA,IAC7D,KAAK,KAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,IAAA,EAAK;AAAA,IAC3D,KAAK,KAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,MAAA,EAAO;AAAA,IAC7D,KAAK,KAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,IAAA,EAAK;AAAA,IAC3D,KAAK,KAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,IAAA,EAAK;AAAA,IAC3D,KAAK,KAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,YAAA,EAAgB,QAAA,EAAU,IAAA,EAAK;AAAA,IAC3D,KAAK,MAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,IAAA,EAAK;AAAA,IAC3D,KAAK,IAAA;AAAQ,MAAA,OAAO,EAAE,IAAA,EAAM,aAAA,EAAgB,QAAA,EAAU,IAAA,EAAK;AAAA,IAC3D;AAAa,MAAA,OAAO,IAAA;AAAA;AAExB;;;AC7PA,SAAS,aAAa,CAAA,EAAwB;AAC5C,EAAA,MAAM,GAAA,GAAM,EAAE,UAAA,IAAc,EAAA;AAC5B,EAAA,MAAM,OAAO,CAAA,CAAE,IAAA,GAAO,CAAA,EAAA,EAAK,CAAA,CAAE,IAAI,CAAA,CAAA,GAAK,EAAA;AACtC,EAAA,OAAO,GAAG,GAAG,CAAA,EAAG,CAAA,CAAE,IAAI,GAAG,IAAI,CAAA,CAAA;AAC/B;AAGA,SAAS,mBAAmB,GAAA,EAA4B;AAEtD,EAAA,MAAM,SAAmB,EAAC;AAC1B,EAAA,IAAI,IAAI,UAAA,EAAY,MAAA,CAAO,KAAK,CAAA,EAAA,EAAK,GAAA,CAAI,UAAU,CAAA,EAAA,CAAI,CAAA;AACvD,EAAA,MAAA,CAAO,IAAA,CAAK,IAAI,KAAK,CAAA;AAGrB,EAAA,MAAM,KAAA,GAAQ,GAAA,CAAI,UAAA,CAAW,GAAA,CAAI,YAAY,CAAA;AAG7C,EAAA,MAAM,OAAA,GAAU,GAAA,CAAI,OAAA,CAAQ,GAAA,CAAI,YAAY,CAAA;AAG5C,EAAA,IAAI,KAAA,CAAM,WAAW,CAAA,IAAK,OAAA,CAAQ,WAAW,CAAA,EAAG,OAAO,CAAC,MAAM,CAAA;AAE9D,EAAA,IAAI,QAAQ,MAAA,KAAW,CAAA,EAAG,OAAO,CAAC,QAAQ,KAAK,CAAA;AAE/C,EAAA,OAAO,CAAC,MAAA,EAAQ,KAAA,EAAO,OAAO,CAAA;AAChC;AAmBA,SAAS,YAAA,CAAa,MAAwB,QAAA,EAAoC;AAChF,EAAA,MAAM,MAAA,GAAS,IAAA,KAAS,YAAA,IAAgB,IAAA,KAAS,aAAA;AACjD,EAAA,OAAO,EAAE,IAAA,EAAM,QAAA,EAAU,MAAA,EAAO;AAClC;AAOA,SAAS,cAAA,CACP,IAAA,EACA,QAAA,EACA,SAAA,EACQ;AACR,EAAA,QAAQ,IAAA;AAAM,IACZ,KAAK,aAAA;AAAA,IACL,KAAK,aAAA;AAGH,MAAA,IAAI,cAAc,MAAA,EAAQ;AAExB,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B,CAAA,MAAA,IAAW,cAAc,IAAA,EAAM;AAE7B,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B,CAAA,MAAA,IAAW,cAAc,MAAA,EAAQ;AAE/B,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B,CAAA,MAAO;AAEL,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B;AAAA,IACF,KAAK,aAAA;AAEH,MAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,IAC1B,KAAK,aAAA;AAEH,MAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,IAC1B,KAAK,aAAA;AAAA,IACL,KAAK,YAAA;AAEH,MAAA,IAAI,cAAc,MAAA,EAAQ;AACxB,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B,CAAA,MAAA,IAAW,cAAc,IAAA,EAAM;AAC7B,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B,CAAA,MAAA,IAAW,cAAc,MAAA,EAAQ;AAC/B,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B,CAAA,MAAO;AAEL,QAAA,OAAO,WAAW,GAAA,GAAM,QAAA;AAAA,MAC1B;AAAA;AAEN;AAqBO,SAAS,gBAAA,CAAiB,MAAc,MAAA,EAA6B;AAC1E,EAAA,MAAM,KAAA,GAAQ,KAAK,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAA,EAAM,EAAE,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,MAAA,GAAS,CAAA,IAAK,CAAC,CAAA,CAAE,UAAA,CAAW,IAAI,CAAC,CAAA;AACjG,EAAA,MAAM,OAAA,GAAU,kBAAkB,KAAK,CAAA;AAEvC,EAAA,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG,OAAO,EAAA;AAEzC,EAAA,MAAM,WAAW,MAAA,CAAO,QAAA;AACxB,EAAA,MAAM,IAAA,GAAO,CAAA;AACb,EAAA,MAAM,IAAA,GAAO,CAAA;AAGb,EAAA,MAAM,aAAA,uBAAoB,GAAA,EAAwB;AAClD,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAoB;AAC1C,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAoB;AAE1C,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,IAAA,MAAM,QAAA,GAAW,mBAAmB,GAAG,CAAA;AACvC,IAAA,aAAA,CAAc,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,QAAQ,CAAA;AAGlC,IAAA,IAAI,QAAA,GAAW,CAAA;AACf,IAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,MAAA,KAAA,MAAW,QAAQ,OAAA,EAAS,QAAA,GAAW,KAAK,GAAA,CAAI,QAAA,EAAU,KAAK,MAAM,CAAA;AAAA,IACvE;AACA,IAAA,MAAM,OAAO,QAAA,GAAW,CAAA;AAExB,IAAA,IAAI,UAAA,GAAa,CAAA;AACjB,IAAA,KAAA,MAAW,WAAW,QAAA,EAAU,UAAA,IAAc,KAAK,GAAA,CAAI,OAAA,CAAQ,QAAQ,CAAC,CAAA;AACxE,IAAA,MAAM,IAAA,GAAO,UAAA,IAAc,QAAA,CAAS,MAAA,GAAS,CAAA,CAAA,GAAK,CAAA;AAElD,IAAA,SAAA,CAAU,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,IAAI,CAAA;AAC1B,IAAA,SAAA,CAAU,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,IAAI,CAAA;AAAA,EAC5B;AAWA,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAuB;AAC7C,EAAA,KAAA,MAAW,OAAO,OAAA,CAAQ,OAAA,YAAmB,GAAA,CAAI,GAAA,CAAI,IAAI,GAAG,CAAA;AAE5D,EAAA,MAAM,OAAA,uBAAc,GAAA,EAAyB;AAC7C,EAAA,MAAM,QAAA,uBAAe,GAAA,EAAyB;AAE9C,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AAKvC,IAAA,MAAM,cAAA,GAAiB,GAAA,CAAI,IAAA,KAAS,aAAA,IAAiB,IAAI,IAAA,KAAS,aAAA;AAClE,IAAA,MAAM,WAAW,cAAA,IAAkB,GAAA,CAAI,aAAa,IAAA,GAAO,GAAA,CAAI,KAAK,GAAA,CAAI,IAAA;AACxE,IAAA,MAAM,UAAU,cAAA,IAAkB,GAAA,CAAI,aAAa,IAAA,GAAO,GAAA,CAAI,OAAO,GAAA,CAAI,EAAA;AAEzE,IAAA,IAAI,CAAC,OAAA,CAAQ,GAAA,CAAI,OAAO,CAAA,UAAW,GAAA,CAAI,OAAA,kBAAS,IAAI,GAAA,EAAK,CAAA;AACzD,IAAA,OAAA,CAAQ,GAAA,CAAI,OAAO,CAAA,CAAG,GAAA,CAAI,QAAQ,CAAA;AAClC,IAAA,IAAI,CAAC,QAAA,CAAS,GAAA,CAAI,QAAQ,CAAA,WAAY,GAAA,CAAI,QAAA,kBAAU,IAAI,GAAA,EAAK,CAAA;AAC7D,IAAA,QAAA,CAAS,GAAA,CAAI,QAAQ,CAAA,CAAG,GAAA,CAAI,OAAO,CAAA;AAAA,EACrC;AAMA,EAAA,MAAM,KAAA,uBAAY,GAAA,EAAoB;AACtC,EAAA,MAAM,QAAQ,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAO,CAAA,CAAA,KAAK,CAAC,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAE,EAAE,KAAK,OAAA,CAAQ,GAAA,CAAI,EAAE,EAAE,CAAA,CAAG,SAAS,CAAC,CAAA;AAC7F,EAAA,MAAM,KAAA,GAAkB,KAAA,CAAM,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,EAAE,CAAA;AAC3C,EAAA,KAAA,MAAW,EAAA,IAAM,KAAA,EAAO,KAAA,CAAM,GAAA,CAAI,IAAI,CAAC,CAAA;AAEvC,EAAA,MAAM,QAAA,GAAW,OAAA,CAAQ,OAAA,CAAQ,MAAA,GAAS,CAAA;AAC1C,EAAA,IAAI,EAAA,GAAK,CAAA;AACT,EAAA,OAAO,EAAA,GAAK,MAAM,MAAA,EAAQ;AACxB,IAAA,MAAM,EAAA,GAAK,MAAM,EAAA,EAAI,CAAA;AACrB,IAAA,MAAM,QAAA,GAAW,QAAA,CAAS,GAAA,CAAI,EAAE,CAAA;AAChC,IAAA,IAAI,CAAC,QAAA,EAAU;AACf,IAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,MAAA,MAAM,QAAA,GAAA,CAAY,KAAA,CAAM,GAAA,CAAI,EAAE,KAAK,CAAA,IAAK,CAAA;AACxC,MAAA,IAAI,WAAW,QAAA,EAAU;AACzB,MAAA,IAAI,CAAC,MAAM,GAAA,CAAI,OAAO,KAAK,KAAA,CAAM,GAAA,CAAI,OAAO,CAAA,GAAK,QAAA,EAAU;AACzD,QAAA,KAAA,CAAM,GAAA,CAAI,SAAS,QAAQ,CAAA;AAC3B,QAAA,KAAA,CAAM,KAAK,OAAO,CAAA;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,IAAA,IAAI,CAAC,KAAA,CAAM,GAAA,CAAI,GAAA,CAAI,EAAE,GAAG,KAAA,CAAM,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,CAAC,CAAA;AAAA,EAC7C;AAIA,EAAA,MAAM,QAAA,GAAW,IAAA,CAAK,GAAA,CAAI,GAAG,CAAC,GAAG,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAG,CAAC,CAAA;AACnD,EAAA,MAAM,WAAA,GAA0B,KAAA,CAAM,IAAA,CAAK,EAAE,MAAA,EAAQ,WAAW,CAAA,EAAE,EAAG,MAAM,EAAE,CAAA;AAC7E,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,IAAA,WAAA,CAAY,KAAA,CAAM,IAAI,GAAA,CAAI,EAAE,CAAE,CAAA,CAAG,IAAA,CAAK,IAAI,EAAE,CAAA;AAAA,EAC9C;AAGA,EAAA,MAAM,MAAA,uBAAa,GAAA,EAAyB;AAC5C,EAAA,IAAI,QAAA,GAAW,CAAA;AAEf,EAAA,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,EAAA,IAAM,QAAA,EAAU,EAAA,EAAA,EAAM;AACrC,IAAA,MAAM,KAAA,GAAQ,YAAY,EAAE,CAAA;AAC5B,IAAA,IAAI,KAAA,CAAM,WAAW,CAAA,EAAG;AAExB,IAAA,IAAI,QAAA,GAAW,CAAA;AACf,IAAA,IAAI,IAAA,GAAO,CAAA;AAEX,IAAA,KAAA,MAAW,MAAM,KAAA,EAAO;AACtB,MAAA,MAAM,GAAA,GAAM,SAAA,CAAU,GAAA,CAAI,EAAE,CAAA;AAC5B,MAAA,MAAM,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,EAAE,CAAA;AAC1B,MAAA,MAAM,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,EAAE,CAAA;AAC1B,MAAA,MAAA,CAAO,IAAI,EAAA,EAAI;AAAA,QACb,GAAA;AAAA,QACA,QAAA,EAAU,aAAA,CAAc,GAAA,CAAI,EAAE,CAAA;AAAA,QAC9B,CAAA,EAAG,QAAA;AAAA,QACH,CAAA,EAAG,QAAA;AAAA,QACH,KAAA,EAAO,CAAA;AAAA,QACP,MAAA,EAAQ;AAAA,OACT,CAAA;AACD,MAAA,QAAA,IAAY,CAAA,GAAI,IAAA;AAChB,MAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,CAAC,CAAA;AAAA,IACzB;AAEA,IAAA,QAAA,IAAY,IAAA,GAAO,IAAA;AAAA,EACrB;AAGA,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,KAAA,MAAW,CAAA,IAAK,MAAA,CAAO,MAAA,EAAO,EAAG;AAC/B,IAAA,MAAA,GAAS,KAAK,GAAA,CAAI,MAAA,EAAQ,CAAA,CAAE,CAAA,GAAI,EAAE,KAAK,CAAA;AACvC,IAAA,MAAA,GAAS,KAAK,GAAA,CAAI,MAAA,EAAQ,CAAA,CAAE,CAAA,GAAI,EAAE,MAAM,CAAA;AAAA,EAC1C;AAGA,EAAA,MAAA,IAAU,CAAA;AACV,EAAA,MAAA,IAAU,CAAA;AAEV,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG,SAAS,CAAC,CAAA;AAG9C,EAAA,KAAA,MAAW,CAAA,IAAK,MAAA,CAAO,MAAA,EAAO,EAAG;AAC/B,IAAA,MAAM,SAAA,GAAY,YAAA,CAAa,CAAA,CAAE,QAAA,EAAU,QAAQ,CAAA;AAEnD,IAAA,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,EAAA,GAAK,SAAA,CAAU,QAAQ,EAAA,EAAA,EAAM;AAC5C,MAAA,KAAA,IAAS,KAAK,CAAA,EAAG,EAAA,GAAK,UAAU,CAAC,CAAA,CAAG,QAAQ,EAAA,EAAA,EAAM;AAChD,QAAA,MAAM,EAAA,GAAK,SAAA,CAAU,EAAE,CAAA,CAAG,EAAE,CAAA;AAC5B,QAAA,IAAI,OAAO,GAAA,EAAK;AACd,UAAA,MAAM,EAAA,GAAK,EAAE,CAAA,GAAI,EAAA;AACjB,UAAA,MAAM,EAAA,GAAK,EAAE,CAAA,GAAI,EAAA;AACjB,UAAA,IAAI,EAAA,GAAK,MAAA,IAAU,EAAA,GAAK,MAAA,EAAQ;AAC9B,YAAA,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AAAA,UACpB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAC3B,EAAA,MAAM,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAC3B,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAC/B,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAE/B,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA;AACjC,IAAA,MAAM,GAAA,GAAM,MAAA,CAAO,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAC7B,IAAA,IAAI,CAAC,KAAA,IAAS,CAAC,GAAA,EAAK;AAEpB,IAAA,MAAM,MAAA,GAAS,YAAA,CAAa,GAAA,CAAI,IAAA,EAAM,IAAI,QAAQ,CAAA;AAClD,IAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,MAAA,GAAS,KAAA,GAAQ,CAAA;AACtC,IAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,MAAA,GAAS,KAAA,GAAQ,CAAA;AAGtC,IAAA,MAAM,SAAS,KAAA,CAAM,CAAA,GAAI,KAAK,KAAA,CAAM,KAAA,CAAM,QAAQ,CAAC,CAAA;AACnD,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,MAAA,GAAS,CAAA;AACxC,IAAA,MAAM,OAAO,GAAA,CAAI,CAAA,GAAI,KAAK,KAAA,CAAM,GAAA,CAAI,QAAQ,CAAC,CAAA;AAC7C,IAAA,MAAM,OAAO,GAAA,CAAI,CAAA;AAKjB,IAAA,IAAI,SAAS,IAAA,EAAM;AAEjB,MAAA,MAAM,OAAO,MAAA,GAAS,IAAA,CAAK,KAAA,CAAA,CAAO,IAAA,GAAO,UAAU,CAAC,CAAA;AAGpD,MAAA,KAAA,IAAS,CAAA,GAAI,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,MAAM,CAAA,EAAA,EAAK;AACvC,QAAA,IAAI,IAAI,MAAA,EAAQ,MAAA,CAAO,MAAM,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MACvC;AAGA,MAAA,IAAI,WAAW,IAAA,EAAM;AACnB,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA;AAChC,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA;AAChC,QAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,EAAA,EAAI,CAAA,EAAA,EAAK;AAC7B,UAAA,IAAI,CAAA,GAAI,UAAU,IAAA,GAAO,MAAA,SAAe,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,KAAA;AAAA,QACtD;AAEA,QAAA,IAAI,CAAC,QAAA,IAAY,IAAA,GAAO,MAAA,EAAQ;AAC9B,UAAA,IAAI,SAAS,IAAA,EAAM;AACjB,YAAA,MAAA,CAAO,MAAM,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AACxB,YAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AAAA,UACxB,CAAA,MAAO;AACL,YAAA,MAAA,CAAO,MAAM,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AACxB,YAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AAAA,UACxB;AAAA,QACF;AAAA,MACF;AAGA,MAAA,KAAA,IAAS,CAAA,GAAI,IAAA,GAAO,CAAA,EAAG,CAAA,GAAI,MAAM,CAAA,EAAA,EAAK;AACpC,QAAA,IAAI,IAAI,MAAA,EAAQ,MAAA,CAAO,IAAI,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MACrC;AAGA,MAAA,IAAI,MAAA,CAAO,aAAa,IAAA,EAAM;AAE5B,QAAA,MAAM,UAAA,GAAa,cAAA,CAAe,MAAA,CAAO,IAAA,EAAM,UAAU,MAAM,CAAA;AAC/D,QAAA,MAAM,KAAK,IAAA,GAAO,CAAA;AAClB,QAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ;AAC1B,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,KAAK,IAAA,GAAO,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACtD,YAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AACA,MAAA,IAAI,MAAA,CAAO,aAAa,MAAA,EAAQ;AAE9B,QAAA,MAAM,UAAA,GAAa,cAAA,CAAe,MAAA,CAAO,IAAA,EAAM,UAAU,MAAM,CAAA;AAC/D,QAAA,MAAM,KAAK,MAAA,GAAS,CAAA;AACpB,QAAA,IAAI,KAAK,MAAA,EAAQ;AACf,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,KAAK,MAAA,GAAS,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACxD,YAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AAAA,IACF,WAAW,GAAA,CAAI,CAAA,GAAI,IAAI,MAAA,GAAS,CAAA,GAAI,MAAM,CAAA,EAAG;AAE3C,MAAA,MAAM,SAAS,KAAA,CAAM,CAAA;AACrB,MAAA,MAAM,IAAA,GAAO,GAAA,CAAI,CAAA,GAAI,GAAA,CAAI,MAAA,GAAS,CAAA;AAClC,MAAA,MAAM,OAAO,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAElD,MAAA,KAAA,IAAS,CAAA,GAAI,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,MAAM,CAAA,EAAA,EAAK;AACvC,QAAA,IAAI,CAAA,IAAK,KAAK,CAAA,GAAI,MAAA,SAAe,MAAM,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MACjD;AAEA,MAAA,IAAI,WAAW,IAAA,EAAM;AACnB,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA;AAChC,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA;AAChC,QAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,EAAA,EAAI,CAAA,EAAA,EAAK;AAC7B,UAAA,IAAI,CAAA,GAAI,MAAA,IAAU,IAAA,IAAQ,CAAA,IAAK,IAAA,GAAO,QAAQ,MAAA,CAAO,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,KAAA;AAAA,QACnE;AACA,QAAA,IAAI,CAAC,QAAA,IAAY,IAAA,IAAQ,CAAA,IAAK,OAAO,MAAA,EAAQ;AAC3C,UAAA,IAAI,SAAS,IAAA,EAAM;AACjB,YAAA,MAAA,CAAO,MAAM,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AACxB,YAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AAAA,UACxB,CAAA,MAAO;AACL,YAAA,MAAA,CAAO,MAAM,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AACxB,YAAA,MAAA,CAAO,IAAI,CAAA,CAAG,IAAI,CAAA,GAAI,QAAA;AAAA,UACxB;AAAA,QACF;AAAA,MACF;AAEA,MAAA,KAAA,IAAS,CAAA,GAAI,IAAA,GAAO,CAAA,EAAG,CAAA,GAAI,MAAM,CAAA,EAAA,EAAK;AACpC,QAAA,IAAI,CAAA,IAAK,KAAK,CAAA,GAAI,MAAA,SAAe,IAAI,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MAC/C;AAGA,MAAA,IAAI,MAAA,CAAO,aAAa,MAAA,EAAQ;AAE9B,QAAA,MAAM,UAAA,GAAa,cAAA,CAAe,MAAA,CAAO,IAAA,EAAM,UAAU,IAAI,CAAA;AAC7D,QAAA,MAAM,KAAK,MAAA,GAAS,CAAA;AACpB,QAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ;AAC1B,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,KAAK,MAAA,GAAS,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACxD,YAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AACA,MAAA,IAAI,MAAA,CAAO,aAAa,IAAA,EAAM;AAI5B,QAAA,MAAM,cAAA,GAAiB,MAAA,CAAO,IAAA,KAAS,aAAA,IAAiB,OAAO,IAAA,KAAS,aAAA;AACxE,QAAA,MAAM,SAAA,GAAY,iBAAiB,MAAA,GAAS,IAAA;AAC5C,QAAA,MAAM,UAAA,GAAa,cAAA,CAAe,MAAA,CAAO,IAAA,EAAM,UAAU,SAAS,CAAA;AAClE,QAAA,MAAM,KAAK,IAAA,GAAO,CAAA;AAClB,QAAA,IAAI,KAAK,MAAA,EAAQ;AACf,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,KAAK,IAAA,GAAO,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACtD,YAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,MAAM,OAAA,GAAU,KAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA,GAAI,GAAA,CAAI,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AAC3D,MAAA,YAAA,CAAa,MAAA,EAAQ,MAAA,EAAQ,OAAA,GAAU,CAAC,CAAA;AAGxC,MAAA,KAAA,IAAS,CAAA,GAAI,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,SAAS,CAAA,EAAA,EAAK;AAC1C,QAAA,MAAA,CAAO,MAAM,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MACvB;AAEA,MAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA;AAChC,MAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,IAAI,CAAA;AAChC,MAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,EAAA,EAAI,CAAA,EAAA,EAAK;AAC7B,QAAA,MAAA,CAAO,CAAC,CAAA,CAAG,OAAO,CAAA,GAAI,KAAA;AAAA,MACxB;AAEA,MAAA,KAAA,IAAS,CAAA,GAAI,UAAU,CAAA,EAAG,CAAA,IAAK,IAAI,CAAA,GAAI,GAAA,CAAI,QAAQ,CAAA,EAAA,EAAK;AACtD,QAAA,MAAA,CAAO,IAAI,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MACrB;AAGA,MAAA,IAAI,MAAA,CAAO,aAAa,MAAA,EAAQ;AAE9B,QAAA,MAAM,UAAA,GAAa,cAAA,CAAe,MAAA,CAAO,IAAA,EAAM,UAAU,MAAM,CAAA;AAC/D,QAAA,MAAM,KAAK,MAAA,GAAS,CAAA;AACpB,QAAA,IAAI,KAAK,MAAA,EAAQ;AACf,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,KAAK,MAAA,GAAS,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACxD,YAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AACA,MAAA,IAAI,MAAA,CAAO,aAAa,IAAA,EAAM;AAE5B,QAAA,MAAM,UAAA,GAAa,cAAA,CAAe,MAAA,CAAO,IAAA,EAAM,UAAU,IAAI,CAAA;AAC7D,QAAA,MAAM,EAAA,GAAK,GAAA,CAAI,CAAA,GAAI,GAAA,CAAI,MAAA;AACvB,QAAA,IAAI,KAAK,MAAA,EAAQ;AACf,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,KAAK,IAAA,GAAO,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACtD,YAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAIA,IAAA,IAAI,IAAI,KAAA,EAAO;AACb,MAAA,MAAM,WAAA,GAAc,CAAA,CAAA,EAAI,GAAA,CAAI,KAAK,CAAA,CAAA,CAAA;AACjC,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAE3C,MAAA,IAAI,IAAA;AACJ,MAAA,IAAI,SAAS,IAAA,EAAM;AAEjB,QAAA,IAAA,GAAO,KAAK,KAAA,CAAA,CAAO,MAAA,GAAS,CAAA,GAAI,IAAA,GAAO,KAAK,CAAC,CAAA;AAAA,MAC/C,WAAW,GAAA,CAAI,CAAA,GAAI,IAAI,MAAA,GAAS,CAAA,GAAI,MAAM,CAAA,EAAG;AAE3C,QAAA,MAAM,IAAA,GAAO,GAAA,CAAI,CAAA,GAAI,GAAA,CAAI,MAAA,GAAS,CAAA;AAClC,QAAA,IAAA,GAAO,KAAK,KAAA,CAAA,CAAO,IAAA,GAAO,IAAI,KAAA,CAAM,CAAA,GAAI,KAAK,CAAC,CAAA;AAAA,MAChD,CAAA,MAAO;AAEL,QAAA,IAAA,GAAO,IAAA,CAAK,IAAI,MAAA,EAAQ,GAAA,CAAI,IAAI,GAAA,CAAI,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AAAA,MACpD;AACA,MAAA,MAAM,aAAa,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,WAAA,CAAY,SAAS,CAAC,CAAA;AAE3D,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,CAAY,QAAQ,CAAA,EAAA,EAAK;AAC3C,QAAA,MAAM,KAAK,UAAA,GAAa,CAAA;AACxB,QAAA,IAAI,MAAM,CAAA,IAAK,EAAA,GAAK,UAAU,IAAA,IAAQ,CAAA,IAAK,OAAO,MAAA,EAAQ;AACxD,UAAA,MAAA,CAAO,EAAE,CAAA,CAAG,IAAI,CAAA,GAAI,YAAY,CAAC,CAAA;AAAA,QACnC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,eAAe,MAAM,CAAA;AAC9B;;;ACxeO,SAAS,eAAe,KAAA,EAA4B;AACzD,EAAA,MAAM,OAAA,GAAqB;AAAA,IACzB,UAAU,EAAC;AAAA,IACX,eAAe;AAAC,GAClB;AAGA,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAsB;AAE5C,EAAA,IAAI,aAAA,GAAiC,IAAA;AAErC,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAGpB,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,IAAI,SAAS,GAAA,EAAK;AAChB,QAAA,aAAA,GAAgB,IAAA;AAChB,QAAA;AAAA,MACF;AAGA,MAAA,MAAM,IAAA,GAAO,eAAe,IAAI,CAAA;AAChC,MAAA,IAAI,IAAA,EAAM;AACR,QAAA,aAAA,CAAc,UAAA,CAAW,KAAK,IAAI,CAAA;AAAA,MACpC;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,KAAA,CAAM,cAAc,CAAA;AAClD,IAAA,IAAI,gBAAA,EAAkB;AACpB,MAAA,MAAM,EAAA,GAAK,iBAAiB,CAAC,CAAA;AAC7B,MAAA,MAAM,MAAA,GAAS,YAAA,CAAa,SAAA,EAAW,EAAE,CAAA;AACzC,MAAA,aAAA,GAAgB,MAAA;AAChB,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,GAAA,GAAM,sBAAsB,IAAI,CAAA;AACtC,IAAA,IAAI,GAAA,EAAK;AAEP,MAAA,YAAA,CAAa,SAAA,EAAW,IAAI,OAAO,CAAA;AACnC,MAAA,YAAA,CAAa,SAAA,EAAW,IAAI,OAAO,CAAA;AACnC,MAAA,OAAA,CAAQ,aAAA,CAAc,KAAK,GAAG,CAAA;AAC9B,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAA,CAAQ,QAAA,GAAW,CAAC,GAAG,SAAA,CAAU,QAAQ,CAAA;AACzC,EAAA,OAAO,OAAA;AACT;AAGA,SAAS,YAAA,CAAa,WAAkC,EAAA,EAAsB;AAC5E,EAAA,IAAI,MAAA,GAAS,SAAA,CAAU,GAAA,CAAI,EAAE,CAAA;AAC7B,EAAA,IAAI,CAAC,MAAA,EAAQ;AACX,IAAA,MAAA,GAAS,EAAE,EAAA,EAAI,KAAA,EAAO,EAAA,EAAI,UAAA,EAAY,EAAC,EAAE;AACzC,IAAA,SAAA,CAAU,GAAA,CAAI,IAAI,MAAM,CAAA;AAAA,EAC1B;AACA,EAAA,OAAO,MAAA;AACT;AAGA,SAAS,eAAe,IAAA,EAAkC;AAExD,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,6BAA6B,CAAA;AACtD,EAAA,IAAI,CAAC,OAAO,OAAO,IAAA;AAEnB,EAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,EAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,EAAA,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA,EAAG,MAAK,IAAK,EAAA;AAGjC,EAAA,MAAM,OAA4B,EAAC;AACnC,EAAA,IAAI,OAAA;AAGJ,EAAA,MAAM,YAAA,GAAe,IAAA,CAAK,KAAA,CAAM,WAAW,CAAA;AAC3C,EAAA,IAAI,YAAA,EAAc;AAChB,IAAA,OAAA,GAAU,aAAa,CAAC,CAAA;AAAA,EAC1B;AAGA,EAAA,MAAM,qBAAqB,IAAA,CAAK,OAAA,CAAQ,SAAA,EAAW,EAAE,EAAE,IAAA,EAAK;AAC5D,EAAA,KAAA,MAAW,IAAA,IAAQ,kBAAA,CAAmB,KAAA,CAAM,KAAK,CAAA,EAAG;AAClD,IAAA,MAAM,KAAA,GAAQ,KAAK,WAAA,EAAY;AAC/B,IAAA,IAAI,KAAA,KAAU,IAAA,IAAQ,KAAA,KAAU,IAAA,IAAQ,UAAU,IAAA,EAAM;AACtD,MAAA,IAAA,CAAK,KAAK,KAA2B,CAAA;AAAA,IACvC;AAAA,EACF;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,IAAA,EAAM,IAAA,EAAM,OAAA,EAAQ;AACrC;AAYA,SAAS,sBAAsB,IAAA,EAAqC;AAElE,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,0DAA0D,CAAA;AACnF,EAAA,IAAI,CAAC,OAAO,OAAO,IAAA;AAEnB,EAAA,MAAM,OAAA,GAAU,MAAM,CAAC,CAAA;AACvB,EAAA,MAAM,cAAA,GAAiB,MAAM,CAAC,CAAA;AAC9B,EAAA,MAAM,OAAA,GAAU,MAAM,CAAC,CAAA;AACvB,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,CAAC,CAAA,CAAG,IAAA,EAAK;AAG7B,EAAA,MAAM,SAAA,GAAY,cAAA,CAAe,KAAA,CAAM,gCAAgC,CAAA;AACvE,EAAA,IAAI,CAAC,WAAW,OAAO,IAAA;AAEvB,EAAA,MAAM,OAAA,GAAU,UAAU,CAAC,CAAA;AAC3B,EAAA,MAAM,SAAA,GAAY,UAAU,CAAC,CAAA;AAC7B,EAAA,MAAM,QAAA,GAAW,UAAU,CAAC,CAAA;AAE5B,EAAA,MAAM,YAAA,GAAe,iBAAiB,OAAO,CAAA;AAC7C,EAAA,MAAM,YAAA,GAAe,iBAAiB,QAAQ,CAAA;AAC9C,EAAA,MAAM,cAAc,SAAA,KAAc,IAAA;AAElC,EAAA,IAAI,CAAC,YAAA,IAAgB,CAAC,YAAA,EAAc,OAAO,IAAA;AAE3C,EAAA,OAAO,EAAE,OAAA,EAAS,OAAA,EAAS,YAAA,EAAc,YAAA,EAAc,OAAO,WAAA,EAAY;AAC5E;AAGA,SAAS,iBAAiB,GAAA,EAAiC;AAEzD,EAAA,MAAM,MAAA,GAAS,IAAI,KAAA,CAAM,EAAE,EAAE,IAAA,EAAK,CAAE,KAAK,EAAE,CAAA;AAG3C,EAAA,IAAI,MAAA,KAAW,MAAM,OAAO,KAAA;AAE5B,EAAA,IAAI,MAAA,KAAW,MAAM,OAAO,UAAA;AAE5B,EAAA,IAAI,MAAA,KAAW,IAAA,IAAQ,MAAA,KAAW,IAAA,EAAM,OAAO,MAAA;AAE/C,EAAA,IAAI,MAAA,KAAW,IAAA,IAAQ,MAAA,KAAW,IAAA,EAAM,OAAO,WAAA;AAE/C,EAAA,OAAO,IAAA;AACT;;;AC3JA,SAAS,gBAAgB,IAAA,EAA2B;AAClD,EAAA,MAAM,MAAA,GAAS,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAA,GAAI,KAAK,IAAA,CAAK,IAAA,CAAK,GAAG,CAAA,GAAI,GAAA,GAAM,KAAA;AAClE,EAAA,OAAO,GAAG,MAAM,CAAA,EAAG,KAAK,IAAI,CAAA,CAAA,EAAI,KAAK,IAAI,CAAA,CAAA;AAC3C;AAGA,SAAS,oBAAoB,MAAA,EAA8B;AACzD,EAAA,MAAM,MAAA,GAAS,CAAC,MAAA,CAAO,KAAK,CAAA;AAC5B,EAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,UAAA,CAAW,GAAA,CAAI,eAAe,CAAA;AACnD,EAAA,IAAI,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG,OAAO,CAAC,MAAM,CAAA;AACtC,EAAA,OAAO,CAAC,QAAQ,KAAK,CAAA;AACvB;AAgBA,SAAS,iBAAA,CAAkB,MAAmB,QAAA,EAA2B;AACvE,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,QAAQ,IAAA;AAAM,MACZ,KAAK,KAAA;AAAa,QAAA,OAAO,IAAA;AAAA,MACzB,KAAK,UAAA;AAAa,QAAA,OAAO,IAAA;AAAA,MACzB,KAAK,MAAA;AAAa,QAAA,OAAO,IAAA;AAAA,MACzB,KAAK,WAAA;AAAa,QAAA,OAAO,IAAA;AAAA;AAC3B,EACF,CAAA,MAAO;AACL,IAAA,QAAQ,IAAA;AAAM,MACZ,KAAK,KAAA;AAAa,QAAA,OAAO,QAAA;AAAA,MACzB,KAAK,UAAA;AAAa,QAAA,OAAO,SAAA;AAAA,MACzB,KAAK,MAAA;AAAa,QAAA,OAAO,QAAA;AAAA,MACzB,KAAK,WAAA;AAAa,QAAA,OAAO,SAAA;AAAA;AAC3B,EACF;AACF;AAwBO,SAAS,aAAA,CAAc,MAAc,MAAA,EAA6B;AACvE,EAAA,MAAM,KAAA,GAAQ,KAAK,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAA,EAAM,EAAE,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,MAAA,GAAS,CAAA,IAAK,CAAC,CAAA,CAAE,UAAA,CAAW,IAAI,CAAC,CAAA;AACjG,EAAA,MAAM,OAAA,GAAU,eAAe,KAAK,CAAA;AAEpC,EAAA,IAAI,OAAA,CAAQ,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG,OAAO,EAAA;AAE1C,EAAA,MAAM,WAAW,MAAA,CAAO,QAAA;AACxB,EAAA,MAAM,IAAA,GAAO,CAAA;AACb,EAAA,MAAM,IAAA,GAAO,CAAA;AAGb,EAAA,MAAM,cAAA,uBAAqB,GAAA,EAAwB;AACnD,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAoB;AAC3C,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAoB;AAE3C,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,QAAA,EAAU;AAClC,IAAA,MAAM,QAAA,GAAW,oBAAoB,GAAG,CAAA;AACxC,IAAA,cAAA,CAAe,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,QAAQ,CAAA;AAEnC,IAAA,IAAI,QAAA,GAAW,CAAA;AACf,IAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,MAAA,KAAA,MAAW,QAAQ,OAAA,EAAS,QAAA,GAAW,KAAK,GAAA,CAAI,QAAA,EAAU,KAAK,MAAM,CAAA;AAAA,IACvE;AACA,IAAA,MAAM,OAAO,QAAA,GAAW,CAAA;AAExB,IAAA,IAAI,UAAA,GAAa,CAAA;AACjB,IAAA,KAAA,MAAW,WAAW,QAAA,EAAU,UAAA,IAAc,KAAK,GAAA,CAAI,OAAA,CAAQ,QAAQ,CAAC,CAAA;AACxE,IAAA,MAAM,IAAA,GAAO,UAAA,IAAc,QAAA,CAAS,MAAA,GAAS,CAAA,CAAA,GAAK,CAAA;AAElD,IAAA,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,IAAI,CAAA;AAC3B,IAAA,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,IAAI,CAAA;AAAA,EAC7B;AAKA,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,MAAM,CAAC,CAAC,CAAA;AAE3E,EAAA,MAAM,MAAA,uBAAa,GAAA,EAA0B;AAC7C,EAAA,IAAI,QAAA,GAAW,CAAA;AACf,EAAA,IAAI,QAAA,GAAW,CAAA;AACf,EAAA,IAAI,OAAA,GAAU,CAAA;AACd,EAAA,IAAI,QAAA,GAAW,CAAA;AAEf,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,QAAA,EAAU;AAClC,IAAA,MAAM,CAAA,GAAI,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAC/B,IAAA,MAAM,CAAA,GAAI,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAE/B,IAAA,IAAI,YAAY,SAAA,EAAW;AAEzB,MAAA,QAAA,IAAY,OAAA,GAAU,IAAA;AACtB,MAAA,QAAA,GAAW,CAAA;AACX,MAAA,OAAA,GAAU,CAAA;AACV,MAAA,QAAA,GAAW,CAAA;AAAA,IACb;AAEA,IAAA,MAAA,CAAO,GAAA,CAAI,IAAI,EAAA,EAAI;AAAA,MACjB,MAAA,EAAQ,GAAA;AAAA,MACR,QAAA,EAAU,cAAA,CAAe,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAAA,MACnC,CAAA,EAAG,QAAA;AAAA,MACH,CAAA,EAAG,QAAA;AAAA,MACH,KAAA,EAAO,CAAA;AAAA,MACP,MAAA,EAAQ;AAAA,KACT,CAAA;AAED,IAAA,QAAA,IAAY,CAAA,GAAI,IAAA;AAChB,IAAA,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,OAAA,EAAS,CAAC,CAAA;AAC7B,IAAA,QAAA,EAAA;AAAA,EACF;AAGA,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,KAAA,MAAW,CAAA,IAAK,MAAA,CAAO,MAAA,EAAO,EAAG;AAC/B,IAAA,MAAA,GAAS,KAAK,GAAA,CAAI,MAAA,EAAQ,CAAA,CAAE,CAAA,GAAI,EAAE,KAAK,CAAA;AACvC,IAAA,MAAA,GAAS,KAAK,GAAA,CAAI,MAAA,EAAQ,CAAA,CAAE,CAAA,GAAI,EAAE,MAAM,CAAA;AAAA,EAC1C;AACA,EAAA,MAAA,IAAU,CAAA;AACV,EAAA,MAAA,IAAU,CAAA;AAEV,EAAA,MAAM,MAAA,GAAS,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG,SAAS,CAAC,CAAA;AAG9C,EAAA,KAAA,MAAW,CAAA,IAAK,MAAA,CAAO,MAAA,EAAO,EAAG;AAC/B,IAAA,MAAM,SAAA,GAAY,YAAA,CAAa,CAAA,CAAE,QAAA,EAAU,QAAQ,CAAA;AACnD,IAAA,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,EAAA,GAAK,SAAA,CAAU,QAAQ,EAAA,EAAA,EAAM;AAC5C,MAAA,KAAA,IAAS,KAAK,CAAA,EAAG,EAAA,GAAK,UAAU,CAAC,CAAA,CAAG,QAAQ,EAAA,EAAA,EAAM;AAChD,QAAA,MAAM,EAAA,GAAK,SAAA,CAAU,EAAE,CAAA,CAAG,EAAE,CAAA;AAC5B,QAAA,IAAI,OAAO,GAAA,EAAK;AACd,UAAA,MAAM,EAAA,GAAK,EAAE,CAAA,GAAI,EAAA;AACjB,UAAA,MAAM,EAAA,GAAK,EAAE,CAAA,GAAI,EAAA;AACjB,UAAA,IAAI,EAAA,GAAK,MAAA,IAAU,EAAA,GAAK,MAAA,EAAQ;AAC9B,YAAA,MAAA,CAAO,EAAE,CAAA,CAAG,EAAE,CAAA,GAAI,EAAA;AAAA,UACpB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAC3B,EAAA,MAAM,CAAA,GAAI,WAAW,GAAA,GAAM,QAAA;AAC3B,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAC/B,EAAA,MAAM,KAAA,GAAQ,WAAW,GAAA,GAAM,QAAA;AAE/B,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,MAAM,EAAA,GAAK,MAAA,CAAO,GAAA,CAAI,GAAA,CAAI,OAAO,CAAA;AACjC,IAAA,MAAM,EAAA,GAAK,MAAA,CAAO,GAAA,CAAI,GAAA,CAAI,OAAO,CAAA;AACjC,IAAA,IAAI,CAAC,EAAA,IAAM,CAAC,EAAA,EAAI;AAEhB,IAAA,MAAM,KAAA,GAAQ,GAAA,CAAI,WAAA,GAAc,CAAA,GAAI,KAAA;AACpC,IAAA,MAAM,KAAA,GAAQ,GAAA,CAAI,WAAA,GAAc,CAAA,GAAI,KAAA;AAKpC,IAAA,MAAM,OAAO,EAAA,CAAG,CAAA,GAAI,KAAK,KAAA,CAAM,EAAA,CAAG,QAAQ,CAAC,CAAA;AAC3C,IAAA,MAAM,OAAO,EAAA,CAAG,CAAA,GAAI,KAAK,KAAA,CAAM,EAAA,CAAG,SAAS,CAAC,CAAA;AAC5C,IAAA,MAAM,OAAO,EAAA,CAAG,CAAA,GAAI,KAAK,KAAA,CAAM,EAAA,CAAG,QAAQ,CAAC,CAAA;AAC3C,IAAA,MAAM,OAAO,EAAA,CAAG,CAAA,GAAI,KAAK,KAAA,CAAM,EAAA,CAAG,SAAS,CAAC,CAAA;AAG5C,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,IAAA,GAAO,IAAI,CAAA,GAAI,IAAA,CAAK,GAAA,CAAI,EAAA,CAAG,MAAA,EAAQ,EAAA,CAAG,MAAM,CAAA;AAErE,IAAA,IAAI,OAAA,EAAS;AAEX,MAAA,MAAM,CAAC,IAAA,EAAM,KAAK,CAAA,GAAI,IAAA,GAAO,IAAA,GAAO,CAAC,EAAA,EAAI,EAAE,CAAA,GAAI,CAAC,EAAA,EAAI,EAAE,CAAA;AACtD,MAAA,MAAM,CAAC,QAAA,EAAU,SAAS,CAAA,GAAI,IAAA,GAAO,OACjC,CAAC,GAAA,CAAI,YAAA,EAAc,GAAA,CAAI,YAAY,CAAA,GACnC,CAAC,GAAA,CAAI,YAAA,EAAc,IAAI,YAAY,CAAA;AAEvC,MAAA,MAAM,MAAA,GAAS,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAA;AAC7B,MAAA,MAAM,IAAA,GAAO,MAAM,CAAA,GAAI,CAAA;AACvB,MAAA,MAAM,QAAQ,IAAA,CAAK,CAAA,GAAI,KAAK,KAAA,CAAM,IAAA,CAAK,SAAS,CAAC,CAAA;AAGjD,MAAA,KAAA,IAAS,CAAA,GAAI,MAAA,EAAQ,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AACnC,QAAA,IAAI,IAAI,MAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAG,KAAK,CAAA,GAAI,KAAA;AAAA,MACtC;AAGA,MAAA,MAAM,SAAA,GAAY,iBAAA,CAAkB,QAAA,EAAU,QAAQ,CAAA;AACtD,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,CAAU,QAAQ,CAAA,EAAA,EAAK;AACzC,QAAA,MAAM,KAAK,MAAA,GAAS,CAAA;AACpB,QAAA,IAAI,EAAA,GAAK,QAAQ,MAAA,CAAO,EAAE,EAAG,KAAK,CAAA,GAAI,UAAU,CAAC,CAAA;AAAA,MACnD;AAEA,MAAA,MAAM,UAAA,GAAa,iBAAA,CAAkB,SAAA,EAAW,QAAQ,CAAA;AACxD,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,QAAA,MAAM,EAAA,GAAK,IAAA,GAAO,UAAA,CAAW,MAAA,GAAS,CAAA,GAAI,CAAA;AAC1C,QAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,KAAK,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,MAC/D;AAIA,MAAA,IAAI,IAAI,KAAA,EAAO;AACb,QAAA,MAAM,MAAA,GAAS,IAAA,CAAK,KAAA,CAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAC7C,QAAA,MAAM,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,MAAA,GAAS,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,KAAA,CAAM,MAAA,GAAS,CAAC,CAAC,CAAA;AAC7E,QAAA,MAAM,SAAS,KAAA,GAAQ,CAAA;AACvB,QAAA,IAAI,UAAU,CAAA,EAAG;AACf,UAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACzC,YAAA,MAAM,KAAK,UAAA,GAAa,CAAA;AACxB,YAAA,IAAI,EAAA,IAAM,MAAA,IAAU,EAAA,IAAM,IAAA,IAAQ,KAAK,MAAA,EAAQ;AAC7C,cAAA,MAAA,CAAO,EAAE,CAAA,CAAG,MAAM,CAAA,GAAI,GAAA,CAAI,MAAM,CAAC,CAAA;AAAA,YACnC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,MAAM,CAAC,KAAA,EAAO,KAAK,CAAA,GAAI,IAAA,GAAO,IAAA,GAAO,CAAC,EAAA,EAAI,EAAE,CAAA,GAAI,CAAC,EAAA,EAAI,EAAE,CAAA;AACvD,MAAA,MAAM,CAAC,SAAA,EAAW,SAAS,CAAA,GAAI,IAAA,GAAO,OAClC,CAAC,GAAA,CAAI,YAAA,EAAc,GAAA,CAAI,YAAY,CAAA,GACnC,CAAC,GAAA,CAAI,YAAA,EAAc,IAAI,YAAY,CAAA;AAEvC,MAAA,MAAM,MAAA,GAAS,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,MAAA;AAC/B,MAAA,MAAM,IAAA,GAAO,MAAM,CAAA,GAAI,CAAA;AACvB,MAAA,MAAM,QAAQ,KAAA,CAAM,CAAA,GAAI,KAAK,KAAA,CAAM,KAAA,CAAM,QAAQ,CAAC,CAAA;AAGlD,MAAA,KAAA,IAAS,CAAA,GAAI,MAAA,EAAQ,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AACnC,QAAA,IAAI,IAAI,MAAA,EAAQ,MAAA,CAAO,KAAK,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,MACtC;AAGA,MAAA,MAAM,UAAU,KAAA,CAAM,CAAA,GAAI,KAAK,KAAA,CAAM,KAAA,CAAM,QAAQ,CAAC,CAAA;AACpD,MAAA,IAAI,UAAU,OAAA,EAAS;AACrB,QAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAE3C,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,KAAA,EAAO,OAAO,CAAA;AAClC,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,KAAA,EAAO,OAAO,CAAA;AAClC,QAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,EAAA,EAAI,CAAA,EAAA,EAAK;AAC7B,UAAA,IAAI,CAAA,GAAI,UAAU,IAAA,GAAO,MAAA,SAAe,CAAC,CAAA,CAAG,IAAI,CAAA,GAAI,KAAA;AAAA,QACtD;AAEA,QAAA,KAAA,IAAS,CAAA,GAAI,IAAA,GAAO,CAAA,EAAG,CAAA,IAAK,MAAM,CAAA,EAAA,EAAK;AACrC,UAAA,IAAI,IAAI,MAAA,EAAQ,MAAA,CAAO,OAAO,CAAA,CAAG,CAAC,CAAA,GAAI,KAAA;AAAA,QACxC;AAAA,MACF;AAIA,MAAA,MAAM,UAAA,GAAa,iBAAA,CAAkB,SAAA,EAAW,QAAQ,CAAA;AACxD,MAAA,IAAI,SAAS,MAAA,EAAQ;AACnB,QAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,UAAA,MAAM,KAAK,KAAA,GAAQ,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACvD,UAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,MAAM,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,QAChE;AAAA,MACF;AAEA,MAAA,MAAM,OAAA,GAAU,KAAA,KAAU,OAAA,GAAU,OAAA,GAAU,KAAA;AAC9C,MAAA,MAAM,UAAA,GAAa,iBAAA,CAAkB,SAAA,EAAW,QAAQ,CAAA;AACxD,MAAA,IAAI,IAAA,IAAQ,CAAA,IAAK,IAAA,GAAO,MAAA,EAAQ;AAC9B,QAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,UAAA,MAAM,KAAK,OAAA,GAAU,IAAA,CAAK,MAAM,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA,GAAI,CAAA;AACzD,UAAA,IAAI,EAAA,IAAM,CAAA,IAAK,EAAA,GAAK,MAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAG,IAAI,CAAA,GAAI,UAAA,CAAW,CAAC,CAAA;AAAA,QAC9D;AAAA,MACF;AAIA,MAAA,IAAI,IAAI,KAAA,EAAO;AACb,QAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAC3C,QAAA,MAAM,SAAS,KAAA,GAAQ,CAAA;AACvB,QAAA,IAAI,QAAQ,CAAA,EAAG;AACb,UAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACzC,YAAA,MAAM,KAAK,MAAA,GAAS,CAAA;AACpB,YAAA,IAAI,MAAM,CAAA,EAAG;AACX,cAAA,YAAA,CAAa,MAAA,EAAQ,EAAA,GAAK,CAAA,EAAG,IAAA,GAAO,CAAC,CAAA;AACrC,cAAA,MAAA,CAAO,EAAE,CAAA,CAAG,IAAI,CAAA,GAAI,GAAA,CAAI,MAAM,CAAC,CAAA;AAAA,YACjC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,eAAe,MAAM,CAAA;AAC9B;;;AC5RA,SAAS,kBAAkB,IAAA,EAAyD;AAClF,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,IAAA,EAAK,CAAE,KAAA,CAAM,IAAI,CAAA,CAAE,CAAC,CAAA,EAAG,IAAA,EAAK,CAAE,WAAA,EAAY,IAAK,EAAA;AAEtE,EAAA,IAAI,sBAAA,CAAuB,IAAA,CAAK,SAAS,CAAA,EAAG,OAAO,UAAA;AACnD,EAAA,IAAI,mBAAA,CAAoB,IAAA,CAAK,SAAS,CAAA,EAAG,OAAO,OAAA;AAChD,EAAA,IAAI,gBAAA,CAAiB,IAAA,CAAK,SAAS,CAAA,EAAG,OAAO,IAAA;AAG7C,EAAA,OAAO,WAAA;AACT;AA4BO,SAAS,kBAAA,CACd,IAAA,EACA,OAAA,GAA8B,EAAC,EACvB;AACR,EAAA,MAAM,MAAA,GAAsB;AAAA,IAC1B,QAAA,EAAU,QAAQ,QAAA,IAAY,KAAA;AAAA,IAC9B,QAAA,EAAU,QAAQ,QAAA,IAAY,CAAA;AAAA,IAC9B,QAAA,EAAU,QAAQ,QAAA,IAAY,CAAA;AAAA,IAC9B,gBAAA,EAAkB,QAAQ,gBAAA,IAAoB,CAAA;AAAA,IAC9C,cAAA,EAAgB;AAAA;AAAA,GAClB;AAEA,EAAA,MAAM,WAAA,GAAc,kBAAkB,IAAI,CAAA;AAE1C,EAAA,QAAQ,WAAA;AAAa,IACnB,KAAK,UAAA;AACH,MAAA,OAAO,mBAAA,CAAoB,MAAM,MAAM,CAAA;AAAA,IAEzC,KAAK,OAAA;AACH,MAAA,OAAO,gBAAA,CAAiB,MAAM,MAAM,CAAA;AAAA,IAEtC,KAAK,IAAA;AACH,MAAA,OAAO,aAAA,CAAc,MAAM,MAAM,CAAA;AAAA,IAEnC,KAAK,WAAA;AAAA,IACL,SAAS;AAEP,MAAA,MAAM,MAAA,GAAS,aAAa,IAAI,CAAA;AAKhC,MAAA,IAAI,MAAA,CAAO,SAAA,KAAc,IAAA,IAAQ,MAAA,CAAO,cAAc,IAAA,EAAM;AAC1D,QAAA,MAAA,CAAO,cAAA,GAAiB,IAAA;AAAA,MAC1B,CAAA,MAAO;AACL,QAAA,MAAA,CAAO,cAAA,GAAiB,IAAA;AAAA,MAC1B;AAEA,MAAA,MAAM,KAAA,GAAQ,mBAAA,CAAoB,MAAA,EAAQ,MAAM,CAAA;AAChD,MAAA,aAAA,CAAc,KAAK,CAAA;AACnB,MAAA,SAAA,CAAU,KAAK,CAAA;AAIf,MAAA,IAAI,MAAA,CAAO,cAAc,IAAA,EAAM;AAC7B,QAAA,oBAAA,CAAqB,MAAM,MAAM,CAAA;AAAA,MACnC;AAEA,MAAA,OAAO,cAAA,CAAe,MAAM,MAAM,CAAA;AAAA,IACpC;AAAA;AAEJ;;;ACzHO,SAAS,iBAAA,CAAkB,IAAA,EAAc,QAAA,EAAkB,UAAA,EAA4B;AAG5F,EAAA,MAAM,aAAa,UAAA,IAAc,GAAA,GAAM,IAAA,GAAO,UAAA,IAAc,MAAM,IAAA,GAAO,IAAA;AACzE,EAAA,OAAO,IAAA,CAAK,SAAS,QAAA,GAAW,UAAA;AAClC;AAGO,SAAS,qBAAA,CAAsB,MAAc,QAAA,EAA0B;AAK5E,EAAA,OAAO,IAAA,CAAK,SAAS,QAAA,GAAW,GAAA;AAClC;AASO,IAAM,UAAA,GAAa;AAAA;AAAA,EAExB,SAAA,EAAW,EAAA;AAAA;AAAA,EAEX,SAAA,EAAW,EAAA;AAAA;AAAA,EAEX,WAAA,EAAa;AACf,CAAA;AAGO,IAAM,YAAA,GAAe;AAAA,EAC1B,SAAA,EAAW,GAAA;AAAA,EACX,SAAA,EAAW,GAAA;AAAA,EACX,WAAA,EAAa;AACf,CAAA;AAQO,IAAM,wBAAA,GAA2B,CAAA;AAGjC,IAAM,YAAA,GAAe;AAAA;AAAA,EAE1B,UAAA,EAAY,EAAA;AAAA;AAAA,EAEZ,QAAA,EAAU,EAAA;AAAA;AAAA,EAEV,YAAA,EAAc;AAChB,CAAA;AAGO,IAAM,aAAA,GAAgB;AAAA,EAC3B,QAAA,EAAU,CAAA;AAAA,EACV,QAAA,EAAU,IAAA;AAAA,EACV,SAAA,EAAW;AACb,CAAA;AAaO,IAAM,mBAAA,GAAsB,QAAA;AAG5B,IAAM,UAAA,GAAa;AAAA,EACxB,KAAA,EAAO,CAAA;AAAA,EACP,MAAA,EAAQ;AACV,CAAA;;;ACrEO,SAAS,eAAA,CAAgB,EAAA,EAAY,EAAA,EAAY,KAAA,EAAe,MAAA,EAAuB;AAC5F,EAAA,OAAO,EAAE,GAAG,EAAA,GAAK,KAAA,GAAQ,GAAG,CAAA,EAAG,EAAA,GAAK,SAAS,CAAA,EAAE;AACjD;AAeO,SAAS,qBAAA,CACd,KAAA,EACA,EAAA,EACA,EAAA,EACA,IACA,EAAA,EACO;AACP,EAAA,MAAM,EAAA,GAAK,MAAM,CAAA,GAAI,EAAA;AACrB,EAAA,MAAM,EAAA,GAAK,MAAM,CAAA,GAAI,EAAA;AAErB,EAAA,IAAI,IAAA,CAAK,GAAA,CAAI,EAAE,CAAA,GAAI,GAAA,IAAO,KAAK,GAAA,CAAI,EAAE,CAAA,GAAI,GAAA,EAAK,OAAO,KAAA;AAErD,EAAA,MAAM,KAAA,GAAQ,CAAA,IAAK,IAAA,CAAK,GAAA,CAAI,EAAE,IAAI,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,EAAE,CAAA,GAAI,EAAA,CAAA;AACtD,EAAA,OAAO,EAAE,GAAG,EAAA,GAAK,KAAA,GAAQ,IAAI,CAAA,EAAG,EAAA,GAAK,QAAQ,EAAA,EAAG;AAClD;AAcO,SAAS,oBAAA,CACd,KAAA,EACA,EAAA,EACA,EAAA,EACA,CAAA,EACO;AACP,EAAA,MAAM,EAAA,GAAK,MAAM,CAAA,GAAI,EAAA;AACrB,EAAA,MAAM,EAAA,GAAK,MAAM,CAAA,GAAI,EAAA;AACrB,EAAA,MAAMC,QAAO,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,EAAA,GAAK,KAAK,EAAE,CAAA;AAExC,EAAA,IAAIA,KAAAA,GAAO,KAAK,OAAO,KAAA;AACvB,EAAA,MAAM,QAAQ,CAAA,GAAIA,KAAAA;AAClB,EAAA,OAAO,EAAE,GAAG,EAAA,GAAK,KAAA,GAAQ,IAAI,CAAA,EAAG,EAAA,GAAK,QAAQ,EAAA,EAAG;AAClD;AAkBO,SAAS,gBAAA,CAAiB,MAAA,EAAiB,aAAA,GAAgB,IAAA,EAAe;AAC/E,EAAA,IAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,MAAA;AAE9B,EAAA,MAAM,MAAA,GAAkB,CAAC,MAAA,CAAO,CAAC,CAAE,CAAA;AAEnC,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,IAAA,MAAM,IAAA,GAAO,MAAA,CAAO,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA;AACrC,IAAA,MAAM,IAAA,GAAO,OAAO,CAAC,CAAA;AAErB,IAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,KAAK,CAAC,CAAA;AACnC,IAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,KAAK,CAAC,CAAA;AAGnC,IAAA,IAAI,EAAA,GAAK,CAAA,IAAK,EAAA,GAAK,CAAA,EAAG;AACpB,MAAA,MAAA,CAAO,KAAK,IAAI,CAAA;AAChB,MAAA;AAAA,IACF;AAKA,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,MAAA,CAAO,IAAA,CAAK,EAAE,CAAA,EAAG,IAAA,CAAK,GAAG,CAAA,EAAG,IAAA,CAAK,GAAG,CAAA;AAAA,IACtC,CAAA,MAAO;AACL,MAAA,MAAA,CAAO,IAAA,CAAK,EAAE,CAAA,EAAG,IAAA,CAAK,GAAG,CAAA,EAAG,IAAA,CAAK,GAAG,CAAA;AAAA,IACtC;AACA,IAAA,MAAA,CAAO,KAAK,IAAI,CAAA;AAAA,EAClB;AAKA,EAAA,OAAO,gBAAgB,MAAM,CAAA;AAC/B;AAGA,SAAS,gBAAgB,GAAA,EAAuB;AAC9C,EAAA,IAAI,GAAA,CAAI,MAAA,GAAS,CAAA,EAAG,OAAO,GAAA;AAC3B,EAAA,MAAM,GAAA,GAAe,CAAC,GAAA,CAAI,CAAC,CAAE,CAAA;AAC7B,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,MAAA,GAAS,GAAG,CAAA,EAAA,EAAK;AACvC,IAAA,MAAM,CAAA,GAAI,GAAA,CAAI,GAAA,CAAI,MAAA,GAAS,CAAC,CAAA;AAC5B,IAAA,MAAM,CAAA,GAAI,IAAI,CAAC,CAAA;AACf,IAAA,MAAM,CAAA,GAAI,GAAA,CAAI,CAAA,GAAI,CAAC,CAAA;AAEnB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,CAAA,CAAE,IAAI,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA,IAAK,KAAK,GAAA,CAAI,CAAA,CAAE,CAAA,GAAI,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA;AAC/D,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,CAAA,CAAE,IAAI,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA,IAAK,KAAK,GAAA,CAAI,CAAA,CAAE,CAAA,GAAI,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA;AAC/D,IAAA,IAAI,SAAS,KAAA,EAAO;AACpB,IAAA,GAAA,CAAI,KAAK,CAAC,CAAA;AAAA,EACZ;AACA,EAAA,GAAA,CAAI,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,MAAA,GAAS,CAAC,CAAE,CAAA;AAC7B,EAAA,OAAO,GAAA;AACT;AA0CO,SAAS,oBAAA,CACd,MAAA,EACA,UAAA,EACA,UAAA,EACS;AACT,EAAA,IAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,MAAA;AAC9B,EAAA,MAAM,SAAS,MAAA,CAAO,GAAA,CAAI,QAAM,EAAE,GAAG,GAAE,CAAE,CAAA;AAGzC,EAAA,IAAI,UAAA,EAAY;AACd,IAAA,MAAM,IAAA,GAAO,OAAO,MAAA,GAAS,CAAA;AAE7B,IAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG;AAGvB,MAAA,MAAM,KAAA,GAAQ,OAAO,CAAC,CAAA;AACtB,MAAA,MAAM,IAAA,GAAO,OAAO,IAAI,CAAA;AACxB,MAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,MAAM,CAAC,CAAA;AACpC,MAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,MAAM,CAAC,CAAA;AAEpC,MAAA,IAAI,MAAM,EAAA,EAAI;AAEZ,QAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,CAAA,GAAI,KAAA,CAAM,CAAA;AACvC,QAAA,MAAM,KAAA,GAAQ,kBACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAC/B,QAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,IAAA,CAAK,CAAA,EAAG,GAAG,KAAA,EAAM;AAAA,MACvC,CAAA,MAAO;AAEL,QAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,CAAA,GAAI,KAAA,CAAM,CAAA;AACxC,QAAA,MAAM,KAAA,GAAQ,mBACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAC/B,QAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,KAAK,CAAA,EAAE;AAAA,MACvC;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,MAAM,IAAA,GAAO,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA;AAC5B,MAAA,MAAM,IAAA,GAAO,OAAO,IAAI,CAAA;AACxB,MAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,KAAK,CAAC,CAAA;AACnC,MAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,KAAK,CAAC,CAAA;AAInC,MAAA,MAAM,oBAAA,GAAuB,EAAA,GAAK,CAAA,IAAK,EAAA,IAAM,CAAA;AAC7C,MAAA,MAAM,kBAAA,GAAqB,EAAA,GAAK,CAAA,IAAK,EAAA,IAAM,CAAA;AAC3C,MAAA,MAAM,qBAAA,GAAwB,CAAC,oBAAA,IAAwB,CAAC,sBAAsB,EAAA,GAAK,EAAA;AACnF,MAAA,MAAM,mBAAA,GAAsB,CAAC,oBAAA,IAAwB,CAAC,sBAAsB,EAAA,GAAK,EAAA;AAEjF,MAAA,IAAI,oBAAA,EAAsB;AAExB,QAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA;AACvC,QAAA,MAAM,KAAA,GAAQ,mBACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAC/B,QAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,WAAW,EAAA,EAAG;AAC5C,QAAA,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA,GAAI,EAAE,GAAG,IAAA,EAAM,CAAA,EAAG,WAAW,EAAA,EAAG;AAAA,MACjD,WAAW,kBAAA,EAAoB;AAE7B,QAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA;AACtC,QAAA,MAAM,KAAA,GAAQ,kBACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAC/B,QAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,UAAA,CAAW,EAAA,EAAI,GAAG,KAAA,EAAM;AAC5C,QAAA,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA,GAAI,EAAE,GAAG,IAAA,EAAM,CAAA,EAAG,WAAW,EAAA,EAAG;AAAA,MACjD,WAAW,qBAAA,EAAuB;AAEhC,QAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA;AACvC,QAAA,MAAM,KAAA,GAAQ,mBACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAE/B,QAAA,MAAM,oBAAA,GACJ,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA,IACrC,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA;AAEvC,QAAA,IAAI,oBAAA,EAAsB;AACxB,UAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,KAAK,CAAA,EAAE;AAAA,QACvC,CAAA,MAAO;AACL,UAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,WAAW,EAAA,EAAG;AAC5C,UAAA,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA,GAAI,EAAE,GAAG,IAAA,EAAM,CAAA,EAAG,WAAW,EAAA,EAAG;AAAA,QACjD;AAAA,MACF,WAAW,mBAAA,EAAqB;AAE9B,QAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA;AACtC,QAAA,MAAM,KAAA,GAAQ,kBACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAE/B,QAAA,MAAM,sBAAA,GACJ,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA,IACrC,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA;AAEvC,QAAA,IAAI,sBAAA,EAAwB;AAC1B,UAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,IAAA,CAAK,CAAA,EAAG,GAAG,KAAA,EAAM;AAAA,QACvC,CAAA,MAAO;AACL,UAAA,MAAA,CAAO,IAAI,CAAA,GAAI,EAAE,GAAG,UAAA,CAAW,EAAA,EAAI,GAAG,KAAA,EAAM;AAC5C,UAAA,MAAA,CAAO,IAAA,GAAO,CAAC,CAAA,GAAI,EAAE,GAAG,IAAA,EAAM,CAAA,EAAG,WAAW,EAAA,EAAG;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,UAAA,IAAc,MAAA,CAAO,MAAA,IAAU,CAAA,EAAG;AAEpC,IAAA,MAAM,KAAA,GAAQ,OAAO,CAAC,CAAA;AACtB,IAAA,MAAM,IAAA,GAAO,OAAO,CAAC,CAAA;AACrB,IAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,MAAM,CAAC,CAAA;AACpC,IAAA,MAAM,KAAK,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,CAAA,GAAI,MAAM,CAAC,CAAA;AAIpC,IAAA,MAAM,oBAAA,GAAuB,EAAA,GAAK,CAAA,IAAK,EAAA,IAAM,CAAA;AAC7C,IAAA,MAAM,kBAAA,GAAqB,EAAA,GAAK,CAAA,IAAK,EAAA,IAAM,CAAA;AAC3C,IAAA,MAAM,qBAAA,GAAwB,CAAC,oBAAA,IAAwB,CAAC,sBAAsB,EAAA,GAAK,EAAA;AACnF,IAAA,MAAM,mBAAA,GAAsB,CAAC,oBAAA,IAAwB,CAAC,sBAAsB,EAAA,GAAK,EAAA;AAEjF,IAAA,IAAI,oBAAA,EAAsB;AAExB,MAAA,MAAM,WAAA,GAAc,IAAA,CAAK,CAAA,GAAI,KAAA,CAAM,CAAA;AACnC,MAAA,MAAM,KAAA,GAAQ,cACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAC/B,MAAA,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,WAAW,EAAA,EAAG;AACzC,MAAA,MAAA,CAAO,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC,CAAA,EAAI,CAAA,EAAG,UAAA,CAAW,EAAA,EAAG;AAAA,IAChD,WAAW,kBAAA,EAAoB;AAE7B,MAAA,MAAM,YAAA,GAAe,IAAA,CAAK,CAAA,GAAI,KAAA,CAAM,CAAA;AACpC,MAAA,MAAM,KAAA,GAAQ,eACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAC/B,MAAA,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,UAAA,CAAW,EAAA,EAAI,GAAG,KAAA,EAAM;AACzC,MAAA,MAAA,CAAO,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC,CAAA,EAAI,CAAA,EAAG,UAAA,CAAW,EAAA,EAAG;AAAA,IAChD,WAAW,qBAAA,EAAuB;AAEhC,MAAA,MAAM,WAAA,GAAc,IAAA,CAAK,CAAA,GAAI,KAAA,CAAM,CAAA;AACnC,MAAA,MAAM,KAAA,GAAQ,cACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAE/B,MAAA,MAAM,oBAAA,GACJ,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA,IACrC,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA;AAEvC,MAAA,IAAI,oBAAA,EAAsB;AACxB,QAAA,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,KAAK,CAAA,EAAE;AAAA,MACpC,CAAA,MAAO;AACL,QAAA,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,KAAA,EAAO,CAAA,EAAG,WAAW,EAAA,EAAG;AACzC,QAAA,MAAA,CAAO,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC,CAAA,EAAI,CAAA,EAAG,UAAA,CAAW,EAAA,EAAG;AAAA,MAChD;AAAA,IACF,WAAW,mBAAA,EAAqB;AAE9B,MAAA,MAAM,YAAA,GAAe,IAAA,CAAK,CAAA,GAAI,KAAA,CAAM,CAAA;AACpC,MAAA,MAAM,KAAA,GAAQ,eACV,UAAA,CAAW,EAAA,GAAK,WAAW,EAAA,GAC3B,UAAA,CAAW,KAAK,UAAA,CAAW,EAAA;AAE/B,MAAA,MAAM,sBAAA,GACJ,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA,IACrC,IAAA,CAAK,CAAA,IAAK,UAAA,CAAW,EAAA,GAAK,UAAA,CAAW,EAAA;AAEvC,MAAA,IAAI,sBAAA,EAAwB;AAC1B,QAAA,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,IAAA,CAAK,CAAA,EAAG,GAAG,KAAA,EAAM;AAAA,MACpC,CAAA,MAAO;AACL,QAAA,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,UAAA,CAAW,EAAA,EAAI,GAAG,KAAA,EAAM;AACzC,QAAA,MAAA,CAAO,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC,CAAA,EAAI,CAAA,EAAG,UAAA,CAAW,EAAA,EAAG;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;;;ACnWA,IAAM,eAAA,uBAAsB,GAAA,CAAI,CAAC,UAAU,cAAA,EAAgB,aAAA,EAAe,WAAW,CAAC,CAAA;AAItF,IAAM,eAAA,uBAAsB,GAAA,CAAI,CAAC,WAAW,QAAA,EAAU,cAAA,EAAgB,aAAA,EAAe,WAAW,CAAC,CAAA;AAoBjG,IAAMC,SAAAA,GAA+F;AAAA,EACnG,IAAA,EAAM,OAAA;AAAA,EACN,OAAA,EAAS,EAAA;AAAA,EACT,WAAA,EAAa,EAAA;AAAA,EACb,YAAA,EAAc;AAChB,CAAA;AAqCA,SAAS,wBAAA,CACP,EAAA,EACA,KAAA,EACA,IAAA,EACqB;AACrB,EAAA,MAAM,IAAA,GAAO,IAAIC,sBAAA,CAAM,QAAA,CAAS,KAAA,CAAM,EAAE,QAAA,EAAU,IAAA,EAAM,QAAA,EAAU,IAAA,EAAM,CAAA;AACxE,EAAA,IAAA,CAAK,QAAA,CAAS;AAAA,IACZ,OAAA,EAAS,gBAAA,CAAiB,EAAA,CAAG,SAAU,CAAA;AAAA,IACvC,SAAA,EAAW,QAAA;AAAA,IACX,SAAS,IAAA,CAAK,WAAA;AAAA,IACd,SAAS,IAAA,CAAK,YAAA;AAAA;AAAA,IAEd,OAAA,EAAS,EAAA;AAAA,IACT,OAAA,EAAS;AAAA,GACV,CAAA;AACD,EAAA,IAAA,CAAK,mBAAA,CAAoB,OAAO,EAAC,CAAE,CAAA;AAGnC,EAAA,MAAM,OAAA,uBAAc,GAAA,EAAY;AAChC,EAAA,OAAA,CAAQ,GAAA,CAAI,GAAG,EAAE,CAAA;AACjB,EAAA,sBAAA,CAAuB,IAAI,OAAO,CAAA;AAGlC,EAAA,KAAA,MAAW,MAAA,IAAU,GAAG,OAAA,EAAS;AAC/B,IAAA,MAAM,IAAA,GAAO,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,MAAM,CAAA;AACnC,IAAA,IAAI,IAAA,EAAM;AACR,MAAA,MAAM,OAAO,gBAAA,CAAiB,MAAA,EAAQ,IAAA,CAAK,KAAA,EAAO,KAAK,KAAK,CAAA;AAC5D,MAAA,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ,EAAE,KAAA,EAAO,IAAA,CAAK,KAAA,EAAO,KAAA,EAAO,IAAA,CAAK,KAAA,EAAO,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ,CAAA;AAAA,IACpF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,kBAAA,CAAmB,IAAA,EAAM,OAAO,KAAK,CAAA;AAAA,EACvC;AAGA,EAAA,MAAM,mBAAA,uBAA0B,GAAA,EAAY;AAC5C,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AAC3C,IAAA,MAAM,IAAA,GAAO,KAAA,CAAM,KAAA,CAAM,CAAC,CAAA;AAC1B,IAAA,IAAI,OAAA,CAAQ,IAAI,IAAA,CAAK,MAAM,KAAK,OAAA,CAAQ,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG;AACxD,MAAA,mBAAA,CAAoB,IAAI,CAAC,CAAA;AACzB,MAAA,MAAM,SAAA,GAAqC,EAAE,MAAA,EAAQ,CAAA,EAAE;AACvD,MAAA,IAAI,KAAK,KAAA,EAAO;AACd,QAAA,SAAA,CAAU,QAAQ,IAAA,CAAK,KAAA;AACvB,QAAA,SAAA,CAAU,KAAA,GAAQ,kBAAkB,IAAA,CAAK,KAAA,EAAO,WAAW,SAAA,EAAW,YAAA,CAAa,SAAS,CAAA,GAAI,CAAA;AAChG,QAAA,SAAA,CAAU,MAAA,GAAS,WAAW,SAAA,GAAY,CAAA;AAC1C,QAAA,SAAA,CAAU,QAAA,GAAW,GAAA;AAAA,MACvB;AACA,MAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,QAAQ,SAAS,CAAA;AAAA,IAClD;AAAA,EACF;AAGA,EAAAA,sBAAA,CAAM,OAAO,IAAI,CAAA;AAGjB,EAAA,MAAM,aAAA,GAAgB,GAAG,SAAA,KAAc,IAAA,IAAQ,GAAG,SAAA,KAAc,IAAA,IAAQ,GAAG,SAAA,KAAc,IAAA;AAGzF,EAAA,MAAM,iBAAA,uBAAwB,GAAA,EAAY;AAC1C,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,qBAAA,CAAsB,OAAO,iBAAiB,CAAA;AAAA,EAChD;AAGA,EAAA,MAAM,QAA0B,EAAC;AACjC,EAAA,KAAA,MAAW,MAAA,IAAU,IAAA,CAAK,KAAA,EAAM,EAAG;AACjC,IAAA,IAAI,iBAAA,CAAkB,GAAA,CAAI,MAAM,CAAA,EAAG;AACnC,IAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,MAAM,CAAA;AACpC,IAAA,IAAI,CAAC,KAAA,EAAO;AACZ,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;AAClC,IAAA,IAAI,CAAC,SAAA,EAAW;AAChB,IAAA,MAAM,OAAA,GAAU,gBAAgB,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG,SAAA,CAAU,KAAA,EAAO,SAAA,CAAU,MAAM,CAAA;AAC3F,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,MACT,EAAA,EAAI,MAAA;AAAA,MACJ,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,OAAO,SAAA,CAAU,KAAA;AAAA,MACjB,QAAQ,SAAA,CAAU,MAAA;AAAA,MAClB,WAAA,EAAa,gBAAA,CAAiB,KAAA,EAAO,MAAM;AAAA,KAC5C,CAAA;AAAA,EACH;AAGA,EAAA,MAAM,KAAA,GAA0B,IAAA,CAAK,KAAA,EAAM,CAAE,IAAI,CAAA,OAAA,KAAW;AAC1D,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,IAAA,CAAK,OAAO,CAAA;AACnC,IAAA,MAAM,YAAA,GAAe,KAAA,CAAM,KAAA,CAAM,SAAA,CAAU,MAAgB,CAAA;AAC3D,IAAA,MAAM,SAAA,GAAqB,SAAA,CAAU,MAAA,IAAU,EAAC;AAKhD,IAAA,IAAI,SAAA,CAAU,SAAS,CAAA,EAAG;AACxB,MAAA,MAAMC,YAAW,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AAC7C,MAAA,IAAIA,cAAa,SAAA,EAAW;AAC1B,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC9B,QAAA,SAAA,CAAU,CAAC,CAAA,GAAI,qBAAA,CAAsB,SAAA,CAAU,CAAC,CAAA,EAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,GAAG,EAAA,CAAG,KAAA,GAAQ,CAAA,EAAG,EAAA,CAAG,SAAS,CAAC,CAAA;AAAA,MAC7F,CAAA,MAAA,IAAWA,SAAAA,IAAY,eAAA,CAAgB,GAAA,CAAIA,SAAQ,CAAA,EAAG;AACpD,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC9B,QAAA,SAAA,CAAU,CAAC,CAAA,GAAI,oBAAA,CAAqB,SAAA,CAAU,CAAC,GAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,CAAA,EAAG,KAAK,GAAA,CAAI,EAAA,CAAG,OAAO,EAAA,CAAG,MAAM,IAAI,CAAC,CAAA;AAAA,MAClG;AACA,MAAA,MAAMC,YAAW,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AAC7C,MAAA,IAAIA,cAAa,SAAA,EAAW;AAC1B,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC9B,QAAA,MAAM,IAAA,GAAO,UAAU,MAAA,GAAS,CAAA;AAChC,QAAA,SAAA,CAAU,IAAI,CAAA,GAAI,qBAAA,CAAsB,SAAA,CAAU,IAAI,CAAA,EAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,GAAG,EAAA,CAAG,KAAA,GAAQ,CAAA,EAAG,EAAA,CAAG,SAAS,CAAC,CAAA;AAAA,MACnG,CAAA,MAAA,IAAWA,SAAAA,IAAY,eAAA,CAAgB,GAAA,CAAIA,SAAQ,CAAA,EAAG;AACpD,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC9B,QAAA,MAAM,IAAA,GAAO,UAAU,MAAA,GAAS,CAAA;AAChC,QAAA,SAAA,CAAU,IAAI,CAAA,GAAI,oBAAA,CAAqB,SAAA,CAAU,IAAI,GAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,CAAA,EAAG,KAAK,GAAA,CAAI,EAAA,CAAG,OAAO,EAAA,CAAG,MAAM,IAAI,CAAC,CAAA;AAAA,MACxG;AAAA,IACF;AAEA,IAAA,MAAM,WAAA,GAAc,gBAAA,CAAiB,SAAA,EAAW,aAAa,CAAA;AAI7D,IAAA,MAAM,WAAW,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AAC7C,IAAA,MAAM,WAAW,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AAC7C,IAAA,MAAM,OAAA,GAAW,YAAY,CAAC,eAAA,CAAgB,IAAI,QAAQ,CAAA,IAAM,CAAC,QAAA,GAAA,CAC5D,MAAM;AAAE,MAAA,MAAM,EAAA,GAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAAG,MAAA,OAAO,KAAK,EAAE,EAAA,EAAI,EAAA,CAAG,CAAA,EAAG,IAAI,EAAA,CAAG,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,QAAQ,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,MAAA,GAAS,GAAE,GAAI,IAAA;AAAA,IAAK,IAAG,GAC5H,IAAA;AACJ,IAAA,MAAM,OAAA,GAAW,YAAY,CAAC,eAAA,CAAgB,IAAI,QAAQ,CAAA,IAAM,CAAC,QAAA,GAAA,CAC5D,MAAM;AAAE,MAAA,MAAM,EAAA,GAAK,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAAG,MAAA,OAAO,KAAK,EAAE,EAAA,EAAI,EAAA,CAAG,CAAA,EAAG,IAAI,EAAA,CAAG,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,QAAQ,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,MAAA,GAAS,GAAE,GAAI,IAAA;AAAA,IAAK,IAAG,GAC5H,IAAA;AACJ,IAAA,MAAM,MAAA,GAAS,oBAAA,CAAqB,WAAA,EAAa,OAAA,EAAS,OAAO,CAAA;AAEjE,IAAA,IAAI,aAAA;AACJ,IAAA,IAAI,aAAa,KAAA,IAAS,SAAA,CAAU,KAAK,IAAA,IAAQ,SAAA,CAAU,KAAK,IAAA,EAAM;AACpE,MAAA,aAAA,GAAgB,EAAE,CAAA,EAAG,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,UAAU,CAAA,EAAE;AAAA,IACnD;AAEA,IAAA,OAAO;AAAA,MACL,QAAQ,YAAA,CAAa,MAAA;AAAA,MACrB,QAAQ,YAAA,CAAa,MAAA;AAAA,MACrB,OAAO,YAAA,CAAa,KAAA;AAAA,MACpB,OAAO,YAAA,CAAa,KAAA;AAAA,MACpB,eAAe,YAAA,CAAa,aAAA;AAAA,MAC5B,aAAa,YAAA,CAAa,WAAA;AAAA,MAC1B,MAAA;AAAA,MACA;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AAGD,EAAA,MAAM,MAAA,GAA4B,GAAG,QAAA,CAAS,GAAA,CAAI,WAAS,YAAA,CAAa,IAAA,EAAM,KAAK,CAAC,CAAA;AAEpF,EAAA,MAAM,SAAA,GAAY,KAAK,KAAA,EAAM;AAC7B,EAAA,OAAO;AAAA,IACL,IAAI,EAAA,CAAG,EAAA;AAAA,IACP,OAAO,EAAA,CAAG,KAAA;AAAA,IACV,KAAA,EAAO,UAAU,KAAA,IAAS,GAAA;AAAA,IAC1B,MAAA,EAAQ,UAAU,MAAA,IAAU,GAAA;AAAA,IAC5B,KAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,IACA;AAAA,GACF;AACF;AAQA,eAAsB,WAAA,CACpB,KAAA,EACA,OAAA,GAAyB,EAAC,EACA;AAC1B,EAAA,MAAM,IAAA,GAAO,EAAE,GAAGH,SAAAA,EAAU,GAAG,OAAA,EAAQ;AAUvC,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAAiC;AACzD,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,IAAI,EAAA,CAAG,SAAA,IAAa,EAAA,CAAG,SAAA,KAAc,MAAM,SAAA,EAAW;AACpD,MAAA,WAAA,CAAY,IAAI,EAAA,CAAG,EAAA,EAAI,yBAAyB,EAAA,EAAI,KAAA,EAAO,IAAI,CAAC,CAAA;AAAA,IAClE;AAAA,EACF;AAMA,EAAA,MAAM,CAAA,GAAI,IAAIC,sBAAA,CAAM,QAAA,CAAS,KAAA,CAAM,EAAE,QAAA,EAAU,IAAA,EAAM,QAAA,EAAU,IAAA,EAAM,CAAA;AACrE,EAAA,CAAA,CAAE,QAAA,CAAS;AAAA,IACT,OAAA,EAAS,gBAAA,CAAiB,KAAA,CAAM,SAAS,CAAA;AAAA,IACzC,SAAA,EAAW,QAAA;AAAA,IACX,SAAS,IAAA,CAAK,WAAA;AAAA,IACd,SAAS,IAAA,CAAK,YAAA;AAAA,IACd,SAAS,IAAA,CAAK,OAAA;AAAA,IACd,SAAS,IAAA,CAAK;AAAA,GACf,CAAA;AACD,EAAA,CAAA,CAAE,mBAAA,CAAoB,OAAO,EAAC,CAAE,CAAA;AAOhC,EAAA,MAAM,eAAA,uBAAsB,GAAA,EAAY;AACxC,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,eAAA,CAAgB,GAAA,CAAI,GAAG,EAAE,CAAA;AACzB,IAAA,sBAAA,CAAuB,IAAI,eAAe,CAAA;AAAA,EAC5C;AAGA,EAAA,KAAA,MAAW,CAAC,EAAA,EAAI,IAAI,CAAA,IAAK,MAAM,KAAA,EAAO;AACpC,IAAA,IAAI,CAAC,eAAA,CAAgB,GAAA,CAAI,EAAE,CAAA,EAAG;AAC5B,MAAA,MAAM,OAAO,gBAAA,CAAiB,EAAA,EAAI,IAAA,CAAK,KAAA,EAAO,KAAK,KAAK,CAAA;AACxD,MAAA,CAAA,CAAE,OAAA,CAAQ,EAAA,EAAI,EAAE,KAAA,EAAO,IAAA,CAAK,KAAA,EAAO,KAAA,EAAO,IAAA,CAAK,KAAA,EAAO,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ,CAAA;AAAA,IAC7E;AAAA,EACF;AAIA,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,IAAI,WAAA,CAAY,GAAA,CAAI,EAAA,CAAG,EAAE,CAAA,EAAG;AAC1B,MAAA,MAAM,EAAA,GAAK,WAAA,CAAY,GAAA,CAAI,EAAA,CAAG,EAAE,CAAA;AAChC,MAAA,CAAA,CAAE,OAAA,CAAQ,EAAA,CAAG,EAAA,EAAI,EAAE,KAAA,EAAO,GAAG,KAAA,EAAO,MAAA,EAAQ,EAAA,CAAG,MAAA,EAAQ,CAAA;AAAA,IACzD,CAAA,MAAO;AACL,MAAA,kBAAA,CAAmB,CAAA,EAAG,IAAI,KAAK,CAAA;AAAA,IACjC;AAAA,EACF;AAMA,EAAA,MAAM,iBAAA,uBAAwB,GAAA,EAAoB;AAClD,EAAA,MAAM,gBAAA,uBAAuB,GAAA,EAAoB;AACjD,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,IAAI,CAAC,WAAA,CAAY,GAAA,CAAI,EAAA,CAAG,EAAE,CAAA,EAAG;AAC3B,MAAA,sBAAA,CAAuB,EAAA,EAAI,mBAAmB,gBAAgB,CAAA;AAAA,IAChE;AAAA,EACF;AAKA,EAAA,KAAA,MAAW,CAAC,IAAA,EAAM,EAAE,CAAA,IAAK,WAAA,EAAa;AACpC,IAAA,KAAA,MAAW,MAAA,IAAU,GAAG,OAAA,EAAS;AAC/B,MAAA,iBAAA,CAAkB,GAAA,CAAI,QAAQ,IAAI,CAAA;AAClC,MAAA,gBAAA,CAAiB,GAAA,CAAI,QAAQ,IAAI,CAAA;AAAA,IACnC;AAAA,EACF;AAIA,EAAA,MAAM,kBAAA,uBAAyB,GAAA,EAAY;AAC3C,EAAA,KAAA,MAAW,EAAA,IAAM,WAAA,CAAY,MAAA,EAAO,EAAG;AACrC,IAAA,KAAA,MAAW,GAAA,IAAO,EAAA,CAAG,mBAAA,EAAqB,kBAAA,CAAmB,IAAI,GAAG,CAAA;AAAA,EACtE;AASA,EAAA,MAAM,iBAAA,uBAAwB,GAAA,EAAY;AAE1C,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AAC3C,IAAA,IAAI,kBAAA,CAAmB,GAAA,CAAI,CAAC,CAAA,EAAG;AAE/B,IAAA,MAAM,IAAA,GAAO,KAAA,CAAM,KAAA,CAAM,CAAC,CAAA;AAC1B,IAAA,MAAM,SAAS,gBAAA,CAAiB,GAAA,CAAI,IAAA,CAAK,MAAM,KAAK,IAAA,CAAK,MAAA;AACzD,IAAA,MAAM,SAAS,iBAAA,CAAkB,GAAA,CAAI,IAAA,CAAK,MAAM,KAAK,IAAA,CAAK,MAAA;AAC1D,IAAA,MAAM,SAAA,GAAqC,EAAE,MAAA,EAAQ,CAAA,EAAE;AACvD,IAAA,IAAI,KAAK,KAAA,EAAO;AACd,MAAA,SAAA,CAAU,QAAQ,IAAA,CAAK,KAAA;AACvB,MAAA,SAAA,CAAU,KAAA,GAAQ,kBAAkB,IAAA,CAAK,KAAA,EAAO,WAAW,SAAA,EAAW,YAAA,CAAa,SAAS,CAAA,GAAI,CAAA;AAChG,MAAA,SAAA,CAAU,MAAA,GAAS,WAAW,SAAA,GAAY,CAAA;AAC1C,MAAA,SAAA,CAAU,QAAA,GAAW,GAAA;AAAA,IACvB;AAGA,IAAA,IAAI,CAAC,iBAAA,CAAkB,GAAA,CAAI,MAAM,CAAA,EAAG;AAClC,MAAA,SAAA,CAAU,MAAA,GAAS,CAAA;AACnB,MAAA,iBAAA,CAAkB,IAAI,MAAM,CAAA;AAAA,IAC9B;AAEA,IAAA,CAAA,CAAE,OAAA,CAAQ,MAAA,EAAQ,MAAA,EAAQ,SAAS,CAAA;AAAA,EACrC;AAKA,EAAA,IAAI;AACF,IAAAA,sBAAA,CAAM,OAAO,CAAC,CAAA;AAAA,EAChB,SAAS,GAAA,EAAK;AACZ,IAAA,MAAM,UAAU,GAAA,YAAe,KAAA,GAAQ,GAAA,CAAI,OAAA,GAAU,OAAO,GAAG,CAAA;AAC/D,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAwB,OAAO,CAAA,CAAE,CAAA;AAAA,EACnD;AAKA,EAAA,OAAO,sBAAA,CAAuB,CAAA,EAAG,KAAA,EAAO,IAAA,CAAK,SAAS,WAAW,CAAA;AACnE;AAOA,SAAS,iBAAiB,GAAA,EAAwC;AAChE,EAAA,QAAQ,GAAA;AAAK,IACX,KAAK,IAAA;AAAM,MAAA,OAAO,IAAA;AAAA,IAClB,KAAK,IAAA;AAAM,MAAA,OAAO,IAAA;AAAA,IAClB,KAAK,IAAA;AAAM,MAAA,OAAO,IAAA;AAAA,IAClB,KAAK,IAAA;AAAA,IACL,KAAK,IAAA;AAAA,IACL;AAAS,MAAA,OAAO,IAAA;AAAA;AAEpB;AAGA,SAAS,gBAAA,CAAiB,EAAA,EAAY,KAAA,EAAe,KAAA,EAAkD;AACrG,EAAA,MAAM,YAAY,iBAAA,CAAkB,KAAA,EAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AAEvF,EAAA,IAAI,KAAA,GAAQ,SAAA,GAAY,YAAA,CAAa,UAAA,GAAa,CAAA;AAClD,EAAA,IAAI,MAAA,GAAS,UAAA,CAAW,SAAA,GAAY,YAAA,CAAa,QAAA,GAAW,CAAA;AAG5D,EAAA,IAAI,UAAU,SAAA,EAAW;AACvB,IAAA,MAAM,OAAO,IAAA,CAAK,GAAA,CAAI,KAAA,EAAO,MAAM,IAAI,YAAA,CAAa,YAAA;AACpD,IAAA,KAAA,GAAQ,IAAA;AACR,IAAA,MAAA,GAAS,IAAA;AAAA,EACX;AAIA,EAAA,IAAI,KAAA,KAAU,QAAA,IAAY,KAAA,KAAU,cAAA,EAAgB;AAClD,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,QAAQ,KAAA,GAAQ,MAAA,GAAS,MAAM,CAAC,CAAA,GAAI,CAAA;AACzE,IAAA,KAAA,GAAQ,KAAA,KAAU,cAAA,GAAiB,QAAA,GAAW,EAAA,GAAK,QAAA;AACnD,IAAA,MAAA,GAAS,KAAA;AAAA,EACX;AAGA,EAAA,IAAI,UAAU,SAAA,EAAW;AACvB,IAAA,KAAA,IAAS,YAAA,CAAa,UAAA;AAAA,EACxB;AAGA,EAAA,IAAI,KAAA,KAAU,WAAA,IAAe,KAAA,KAAU,eAAA,EAAiB;AACtD,IAAA,KAAA,IAAS,YAAA,CAAa,UAAA;AAAA,EACxB;AAGA,EAAA,IAAI,UAAU,YAAA,EAAc;AAC1B,IAAA,KAAA,IAAS,EAAA;AAAA,EACX;AAGA,EAAA,IAAI,UAAU,UAAA,EAAY;AACxB,IAAA,MAAA,IAAU,EAAA;AAAA,EACZ;AAGA,EAAA,IAAI,KAAA,KAAU,aAAA,IAAiB,KAAA,KAAU,WAAA,EAAa;AACpD,IAAA,KAAA,GAAQ,EAAA;AACR,IAAA,MAAA,GAAS,EAAA;AAAA,EACX;AAGA,EAAA,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,KAAA,EAAO,EAAE,CAAA;AAC1B,EAAA,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,EAAE,CAAA;AAE5B,EAAA,OAAO,EAAE,OAAO,MAAA,EAAO;AACzB;AASA,SAAS,kBAAA,CACP,CAAA,EACA,EAAA,EACA,KAAA,EACA,QAAA,EACM;AAKN,EAAA,CAAA,CAAE,QAAQ,EAAA,CAAG,EAAA,EAAI,EAAE,KAAA,EAAO,EAAA,CAAG,OAAO,CAAA;AAGpC,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,CAAA,CAAE,SAAA,CAAU,EAAA,CAAG,EAAA,EAAI,QAAQ,CAAA;AAAA,EAC7B;AAGA,EAAA,KAAA,MAAW,MAAA,IAAU,GAAG,OAAA,EAAS;AAC/B,IAAA,MAAM,IAAA,GAAO,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,MAAM,CAAA;AACnC,IAAA,IAAI,IAAA,EAAM;AACR,MAAA,MAAM,OAAO,gBAAA,CAAiB,MAAA,EAAQ,IAAA,CAAK,KAAA,EAAO,KAAK,KAAK,CAAA;AAC5D,MAAA,CAAA,CAAE,OAAA,CAAQ,MAAA,EAAQ,EAAE,KAAA,EAAO,IAAA,CAAK,KAAA,EAAO,KAAA,EAAO,IAAA,CAAK,KAAA,EAAO,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ,CAAA;AAC/E,MAAA,CAAA,CAAE,SAAA,CAAU,MAAA,EAAQ,EAAA,CAAG,EAAE,CAAA;AAAA,IAC3B;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,kBAAA,CAAmB,CAAA,EAAG,KAAA,EAAO,KAAA,EAAO,EAAA,CAAG,EAAE,CAAA;AAAA,EAC3C;AACF;AAUA,SAAS,sBAAA,CACP,EAAA,EACA,QAAA,EACA,OAAA,EACM;AAGN,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,sBAAA,CAAuB,KAAA,EAAO,UAAU,OAAO,CAAA;AAAA,EACjD;AAGA,EAAA,MAAM,QAAA,GAAW,CAAC,GAAG,EAAA,CAAG,OAAA,EAAS,GAAG,EAAA,CAAG,QAAA,CAAS,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,EAAE,CAAC,CAAA;AAE9D,EAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AAKzB,IAAA,QAAA,CAAS,GAAA,CAAI,EAAA,CAAG,EAAA,EAAI,EAAA,CAAG,EAAE,CAAA;AACzB,IAAA,OAAA,CAAQ,GAAA,CAAI,EAAA,CAAG,EAAA,EAAI,EAAA,CAAG,EAAE,CAAA;AACxB,IAAA;AAAA,EACF;AAGA,EAAA,MAAM,UAAA,GAAa,SAAS,CAAC,CAAA;AAC7B,EAAA,MAAM,SAAA,GAAY,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAC,CAAA;AAC9C,EAAA,QAAA,CAAS,IAAI,EAAA,CAAG,EAAA,EAAI,SAAS,GAAA,CAAI,UAAU,KAAK,UAAU,CAAA;AAC1D,EAAA,OAAA,CAAQ,IAAI,EAAA,CAAG,EAAA,EAAI,QAAQ,GAAA,CAAI,SAAS,KAAK,SAAS,CAAA;AACxD;AAOA,SAAS,gBAAA,CAAiB,OAAqB,MAAA,EAAoD;AACjG,EAAA,MAAM,SAAA,GAAY,KAAA,CAAM,gBAAA,CAAiB,GAAA,CAAI,MAAM,CAAA;AACnD,EAAA,MAAM,aAAa,SAAA,GAAY,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,SAAS,CAAA,GAAI,MAAA;AAChE,EAAA,MAAM,WAAA,GAAc,KAAA,CAAM,UAAA,CAAW,GAAA,CAAI,MAAM,CAAA;AAC/C,EAAA,IAAI,CAAC,UAAA,IAAc,CAAC,WAAA,EAAa,OAAO,MAAA;AAExC,EAAA,OAAO,EAAE,GAAG,UAAA,EAAY,GAAG,WAAA,EAAY;AACzC;AAGA,SAAS,sBAAA,CAAuB,IAAqB,GAAA,EAAwB;AAC3E,EAAA,KAAA,MAAW,EAAA,IAAM,GAAG,OAAA,EAAS;AAC3B,IAAA,GAAA,CAAI,IAAI,EAAE,CAAA;AAAA,EACZ;AACA,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,sBAAA,CAAuB,OAAO,GAAG,CAAA;AAAA,EACnC;AACF;AAMA,SAAS,sBAAA,CACP,CAAA,EACA,KAAA,EACA,OAAA,EACA,WAAA,EACiB;AACjB,EAAA,MAAM,QAA0B,EAAC;AACjC,EAAA,MAAM,SAA4B,EAAC;AAGnC,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAAY;AACpC,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,qBAAA,CAAsB,IAAI,WAAW,CAAA;AAAA,EACvC;AAGA,EAAA,MAAM,kBAAA,uBAAyB,GAAA,EAAY;AAC3C,EAAA,IAAI,WAAA,EAAa;AACf,IAAA,KAAA,MAAW,EAAA,IAAM,WAAA,CAAY,MAAA,EAAO,EAAG;AACrC,MAAA,KAAA,MAAW,MAAA,IAAU,EAAA,CAAG,OAAA,EAAS,kBAAA,CAAmB,IAAI,MAAM,CAAA;AAAA,IAChE;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,MAAA,IAAU,CAAA,CAAE,KAAA,EAAM,EAAG;AAC9B,IAAA,IAAI,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,EAAG;AAE7B,IAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,MAAM,CAAA;AACpC,IAAA,IAAI,CAAC,KAAA,EAAO;AAEZ,IAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,MAAM,CAAA;AAC/B,IAAA,IAAI,CAAC,SAAA,EAAW;AAEhB,IAAA,MAAM,OAAA,GAAU,gBAAgB,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG,SAAA,CAAU,KAAA,EAAO,SAAA,CAAU,MAAM,CAAA;AAE3F,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,MACT,EAAA,EAAI,MAAA;AAAA,MACJ,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,OAAO,SAAA,CAAU,KAAA;AAAA,MACjB,QAAQ,SAAA,CAAU,MAAA;AAAA,MAClB,WAAA,EAAa,gBAAA,CAAiB,KAAA,EAAO,MAAM;AAAA,KAC5C,CAAA;AAAA,EACH;AAIA,EAAA,KAAA,MAAW,EAAA,IAAM,MAAM,SAAA,EAAW;AAChC,IAAA,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,CAAA,EAAG,EAAE,CAAC,CAAA;AAAA,EACjC;AAGA,EAAA,MAAM,aAAA,GAAgB,MAAM,SAAA,KAAc,IAAA,IAAQ,MAAM,SAAA,KAAc,IAAA,IAAQ,MAAM,SAAA,KAAc,IAAA;AAGlG,EAAA,MAAM,KAAA,GAA0B,CAAA,CAAE,KAAA,EAAM,CAAE,IAAI,CAAA,OAAA,KAAW;AACvD,IAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;AAEhC,IAAA,MAAM,YAAA,GAAe,KAAA,CAAM,KAAA,CAAM,SAAA,CAAU,MAAgB,CAAA;AAC3D,IAAA,MAAM,SAAA,GAAqB,SAAA,CAAU,MAAA,IAAU,EAAC;AAKhD,IAAA,IAAI,SAAA,CAAU,SAAS,CAAA,EAAG;AACxB,MAAA,MAAM,WAAW,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AAC7C,MAAA,IAAI,aAAa,SAAA,EAAW;AAC1B,QAAA,MAAM,EAAA,GAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC3B,QAAA,SAAA,CAAU,CAAC,CAAA,GAAI,qBAAA,CAAsB,SAAA,CAAU,CAAC,CAAA,EAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,GAAG,EAAA,CAAG,KAAA,GAAQ,CAAA,EAAG,EAAA,CAAG,SAAS,CAAC,CAAA;AAAA,MAC7F,CAAA,MAAA,IAAW,QAAA,IAAY,eAAA,CAAgB,GAAA,CAAI,QAAQ,CAAA,EAAG;AACpD,QAAA,MAAM,EAAA,GAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC3B,QAAA,SAAA,CAAU,CAAC,CAAA,GAAI,oBAAA,CAAqB,SAAA,CAAU,CAAC,GAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,CAAA,EAAG,KAAK,GAAA,CAAI,EAAA,CAAG,OAAO,EAAA,CAAG,MAAM,IAAI,CAAC,CAAA;AAAA,MAClG;AACA,MAAA,MAAM,WAAW,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AAC7C,MAAA,IAAI,aAAa,SAAA,EAAW;AAC1B,QAAA,MAAM,EAAA,GAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC3B,QAAA,MAAM,IAAA,GAAO,UAAU,MAAA,GAAS,CAAA;AAChC,QAAA,SAAA,CAAU,IAAI,CAAA,GAAI,qBAAA,CAAsB,SAAA,CAAU,IAAI,CAAA,EAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,GAAG,EAAA,CAAG,KAAA,GAAQ,CAAA,EAAG,EAAA,CAAG,SAAS,CAAC,CAAA;AAAA,MACnG,CAAA,MAAA,IAAW,QAAA,IAAY,eAAA,CAAgB,GAAA,CAAI,QAAQ,CAAA,EAAG;AACpD,QAAA,MAAM,EAAA,GAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAC3B,QAAA,MAAM,IAAA,GAAO,UAAU,MAAA,GAAS,CAAA;AAChC,QAAA,SAAA,CAAU,IAAI,CAAA,GAAI,oBAAA,CAAqB,SAAA,CAAU,IAAI,GAAI,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,CAAA,EAAG,KAAK,GAAA,CAAI,EAAA,CAAG,OAAO,EAAA,CAAG,MAAM,IAAI,CAAC,CAAA;AAAA,MACxG;AAAA,IACF;AAGA,IAAA,MAAM,WAAA,GAAc,gBAAA,CAAiB,SAAA,EAAW,aAAa,CAAA;AAI7D,IAAA,MAAM,kBAAkB,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AACpD,IAAA,MAAM,kBAAkB,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,KAAA;AACpD,IAAA,MAAM,OAAA,GAAW,mBAAmB,CAAC,eAAA,CAAgB,IAAI,eAAe,CAAA,IAAM,CAAC,eAAA,GAAA,CAC1E,MAAM;AAAE,MAAA,MAAM,EAAA,GAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAAG,MAAA,OAAO,KAAK,EAAE,EAAA,EAAI,EAAA,CAAG,CAAA,EAAG,IAAI,EAAA,CAAG,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,QAAQ,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,MAAA,GAAS,GAAE,GAAI,IAAA;AAAA,IAAK,IAAG,GACzH,IAAA;AACJ,IAAA,MAAM,OAAA,GAAW,mBAAmB,CAAC,eAAA,CAAgB,IAAI,eAAe,CAAA,IAAM,CAAC,eAAA,GAAA,CAC1E,MAAM;AAAE,MAAA,MAAM,EAAA,GAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAAG,MAAA,OAAO,KAAK,EAAE,EAAA,EAAI,EAAA,CAAG,CAAA,EAAG,IAAI,EAAA,CAAG,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,QAAQ,CAAA,EAAG,EAAA,EAAI,EAAA,CAAG,MAAA,GAAS,GAAE,GAAI,IAAA;AAAA,IAAK,IAAG,GACzH,IAAA;AACJ,IAAA,MAAM,MAAA,GAAS,oBAAA,CAAqB,WAAA,EAAa,OAAA,EAAS,OAAO,CAAA;AAGjE,IAAA,IAAI,aAAA;AACJ,IAAA,IAAI,aAAa,KAAA,IAAS,SAAA,CAAU,KAAK,IAAA,IAAQ,SAAA,CAAU,KAAK,IAAA,EAAM;AACpE,MAAA,aAAA,GAAgB,EAAE,CAAA,EAAG,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,UAAU,CAAA,EAAE;AAAA,IACnD;AAEA,IAAA,OAAO;AAAA,MACL,QAAQ,YAAA,CAAa,MAAA;AAAA,MACrB,QAAQ,YAAA,CAAa,MAAA;AAAA,MACrB,OAAO,YAAA,CAAa,KAAA;AAAA,MACpB,OAAO,YAAA,CAAa,KAAA;AAAA,MACpB,eAAe,YAAA,CAAa,aAAA;AAAA,MAC5B,aAAa,YAAA,CAAa,WAAA;AAAA,MAC1B,MAAA;AAAA,MACA;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AASD,EAAA,IAAI,WAAA,IAAe,WAAA,CAAY,IAAA,GAAO,CAAA,EAAG;AAEvC,IAAA,MAAM,eAAA,uBAAsB,GAAA,EAAwC;AACpE,IAAA,KAAA,MAAW,KAAK,KAAA,EAAO;AACrB,MAAA,eAAA,CAAgB,IAAI,CAAA,CAAE,EAAA,EAAI,EAAE,EAAA,EAAI,EAAE,CAAA,GAAI,CAAA,CAAE,KAAA,GAAQ,CAAA,EAAG,IAAI,CAAA,CAAE,CAAA,GAAI,CAAA,CAAE,MAAA,GAAS,GAAG,CAAA;AAAA,IAC7E;AAEA,IAAA,KAAA,MAAW,CAAC,IAAA,EAAM,EAAE,CAAA,IAAK,WAAA,EAAa;AAEpC,MAAA,MAAM,WAAA,GAAc,CAAA,CAAE,IAAA,CAAK,IAAI,CAAA;AAC/B,MAAA,IAAI,CAAC,WAAA,EAAa;AAClB,MAAA,MAAM,OAAA,GAAU,gBAAgB,WAAA,CAAY,CAAA,EAAG,YAAY,CAAA,EAAG,WAAA,CAAY,KAAA,EAAO,WAAA,CAAY,MAAM,CAAA;AAGnG,MAAA,KAAA,MAAW,MAAA,IAAU,GAAG,KAAA,EAAO;AAC7B,QAAA,MAAM,QAAA,GAAW;AAAA,UACf,GAAG,MAAA;AAAA,UACH,CAAA,EAAG,MAAA,CAAO,CAAA,GAAI,OAAA,CAAQ,CAAA;AAAA,UACtB,CAAA,EAAG,MAAA,CAAO,CAAA,GAAI,OAAA,CAAQ;AAAA,SACxB;AACA,QAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,QAAA,eAAA,CAAgB,GAAA,CAAI,SAAS,EAAA,EAAI;AAAA,UAC/B,EAAA,EAAI,QAAA,CAAS,CAAA,GAAI,QAAA,CAAS,KAAA,GAAQ,CAAA;AAAA,UAClC,EAAA,EAAI,QAAA,CAAS,CAAA,GAAI,QAAA,CAAS,MAAA,GAAS;AAAA,SACpC,CAAA;AAAA,MACH;AAGA,MAAA,KAAA,MAAW,MAAA,IAAU,GAAG,KAAA,EAAO;AAC7B,QAAA,KAAA,CAAM,IAAA,CAAK;AAAA,UACT,GAAG,MAAA;AAAA,UACH,QAAQ,MAAA,CAAO,MAAA,CAAO,GAAA,CAAI,CAAA,CAAA,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,OAAA,CAAQ,GAAG,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,OAAA,CAAQ,GAAE,CAAE,CAAA;AAAA,UAC3E,eAAe,MAAA,CAAO,aAAA,GAClB,EAAE,CAAA,EAAG,OAAO,aAAA,CAAc,CAAA,GAAI,OAAA,CAAQ,CAAA,EAAG,GAAG,MAAA,CAAO,aAAA,CAAc,CAAA,GAAI,OAAA,CAAQ,GAAE,GAC/E;AAAA,SACL,CAAA;AAAA,MACH;AAGA,MAAA,MAAM,KAAA,GAAQ,aAAA,CAAc,MAAA,EAAQ,IAAI,CAAA;AACxC,MAAA,IAAI,KAAA,IAAS,EAAA,CAAG,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;AACjC,QAAA,KAAA,CAAM,QAAA,GAAW,EAAA,CAAG,MAAA,CAAO,GAAA,CAAI,CAAA,EAAA,KAAM,WAAA,CAAY,EAAA,EAAI,OAAA,CAAQ,CAAA,EAAG,OAAA,CAAQ,CAAC,CAAC,CAAA;AAAA,MAC5E;AAAA,IACF;AAMA,IAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AAExB,MAAA,IAAI,kBAAA,CAAmB,IAAI,IAAA,CAAK,MAAM,KAAK,kBAAA,CAAmB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG;AAEhF,MAAA,IAAI,QAAA,GAAW,KAAA;AAGf,MAAA,IAAI,kBAAA,CAAmB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG;AACvC,QAAA,MAAM,GAAA,GAAM,eAAA,CAAgB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA;AAC3C,QAAA,IAAI,GAAA,IAAO,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;AACjC,UAAA,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,GAAI,EAAE,GAAG,GAAA,CAAI,EAAA,EAAI,CAAA,EAAG,GAAA,CAAI,EAAA,EAAG;AACxC,UAAA,QAAA,GAAW,IAAA;AAAA,QACb;AAAA,MACF;AAGA,MAAA,IAAI,kBAAA,CAAmB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG;AACvC,QAAA,MAAM,GAAA,GAAM,eAAA,CAAgB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA;AAC3C,QAAA,IAAI,GAAA,IAAO,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;AACjC,UAAA,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA,GAAI,EAAE,CAAA,EAAG,GAAA,CAAI,EAAA,EAAI,CAAA,EAAG,GAAA,CAAI,EAAA,EAAG;AAC7D,UAAA,QAAA,GAAW,IAAA;AAAA,QACb;AAAA,MACF;AAGA,MAAA,IAAI,QAAA,EAAU;AACZ,QAAA,IAAA,CAAK,MAAA,GAAS,gBAAA,CAAiB,IAAA,CAAK,MAAA,EAAQ,aAAa,CAAA;AAAA,MAC3D;AAAA,IACF;AAAA,EACF;AAaA,EAAA,MAAM,YAAA,GAAe,WAAW,WAAA,GAAc,EAAA;AAC9C,EAAA,sBAAA,CAAuB,QAAQ,YAAY,CAAA;AAI3C,EAAA,MAAM,UAAA,GAAa,iBAAiB,MAAM,CAAA;AAC1C,EAAA,MAAM,KAAA,GAAQ;AAAA,IACZ,GAAG,KAAA,CAAM,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,CAAC,CAAA;AAAA,IACrB,GAAG,UAAA,CAAW,GAAA,CAAI,CAAAG,EAAAA,KAAKA,GAAE,CAAC;AAAA,GAC5B;AACA,EAAA,MAAM,WAAA,GAAc,MAAM,MAAA,GAAS,CAAA,GAAI,KAAK,GAAA,CAAI,GAAG,KAAK,CAAA,GAAI,OAAA;AAC5D,EAAA,IAAI,UAAA,GAAa,CAAA,CAAE,KAAA,EAAM,CAAE,KAAA,IAAS,GAAA;AACpC,EAAA,IAAI,WAAA,GAAc,CAAA,CAAE,KAAA,EAAM,CAAE,MAAA,IAAU,GAAA;AAEtC,EAAA,IAAI,cAAc,OAAA,EAAS;AACzB,IAAA,MAAM,KAAK,OAAA,GAAU,WAAA;AACrB,IAAA,KAAA,MAAW,CAAA,IAAK,KAAA,EAAO,CAAA,CAAE,CAAA,IAAK,EAAA;AAC9B,IAAA,KAAA,MAAW,KAAK,KAAA,EAAO;AACrB,MAAA,KAAA,MAAW,CAAA,IAAK,CAAA,CAAE,MAAA,EAAQ,CAAA,CAAE,CAAA,IAAK,EAAA;AACjC,MAAA,IAAI,CAAA,CAAE,aAAA,EAAe,CAAA,CAAE,aAAA,CAAc,CAAA,IAAK,EAAA;AAAA,IAC5C;AACA,IAAA,KAAA,MAAW,EAAA,IAAM,UAAA,EAAY,EAAA,CAAG,CAAA,IAAK,EAAA;AACrC,IAAA,WAAA,IAAe,EAAA;AAAA,EACjB;AAGA,EAAA,MAAM,YAAY,IAAA,CAAK,GAAA;AAAA,IACrB,GAAG,KAAA,CAAM,GAAA,CAAI,OAAK,CAAA,CAAE,CAAA,GAAI,EAAE,MAAM,CAAA;AAAA,IAChC,GAAG,WAAW,GAAA,CAAI,CAAAA,OAAKA,EAAAA,CAAE,CAAA,GAAIA,GAAE,MAAM,CAAA;AAAA,IACrC,GAAG,KAAA,CAAM,OAAA,CAAQ,CAAA,CAAA,KAAK,CAAA,CAAE,OAAO,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,CAAC,CAAC;AAAA,GAC9C;AACA,EAAA,IAAI,SAAA,GAAY,UAAU,WAAA,EAAa;AACrC,IAAA,WAAA,GAAc,SAAA,GAAY,OAAA;AAAA,EAC5B;AAEA,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,UAAA;AAAA,IACP,MAAA,EAAQ,WAAA;AAAA,IACR,KAAA;AAAA,IACA,KAAA;AAAA,IACA;AAAA,GACF;AACF;AAOA,SAAS,YAAA,CACP,GACA,EAAA,EACiB;AACjB,EAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,EAAA,CAAG,EAAE,CAAA;AAC9B,EAAA,MAAM,UAAU,SAAA,GACZ,eAAA,CAAgB,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG,SAAA,CAAU,KAAA,EAAO,SAAA,CAAU,MAAM,CAAA,GAC3E,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAEjB,EAAA,OAAO;AAAA,IACL,IAAI,EAAA,CAAG,EAAA;AAAA,IACP,OAAO,EAAA,CAAG,KAAA;AAAA,IACV,GAAG,OAAA,CAAQ,CAAA;AAAA,IACX,GAAG,OAAA,CAAQ,CAAA;AAAA,IACX,KAAA,EAAO,WAAW,KAAA,IAAS,CAAA;AAAA,IAC3B,MAAA,EAAQ,WAAW,MAAA,IAAU,CAAA;AAAA,IAC7B,QAAA,EAAU,GAAG,QAAA,CAAS,GAAA,CAAI,WAAS,YAAA,CAAa,CAAA,EAAG,KAAK,CAAC;AAAA,GAC3D;AACF;AAcA,SAAS,sBAAA,CAAuB,QAA2B,YAAA,EAA4B;AACrF,EAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,IAAA,oBAAA,CAAqB,OAAO,YAAY,CAAA;AAAA,EAC1C;AACF;AAUA,SAAS,oBAAA,CAAqB,OAAwB,YAAA,EAA4B;AAEhF,EAAA,KAAA,MAAW,KAAA,IAAS,MAAM,QAAA,EAAU;AAClC,IAAA,oBAAA,CAAqB,OAAO,YAAY,CAAA;AAAA,EAC1C;AAIA,EAAA,IAAI,KAAA,CAAM,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG;AAC7B,IAAA,IAAI,OAAO,KAAA,CAAM,CAAA;AACjB,IAAA,IAAI,IAAA,GAAO,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,MAAA;AAC3B,IAAA,KAAA,MAAW,KAAA,IAAS,MAAM,QAAA,EAAU;AAClC,MAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,KAAA,CAAM,CAAC,CAAA;AAC7B,MAAA,IAAA,GAAO,KAAK,GAAA,CAAI,IAAA,EAAM,KAAA,CAAM,CAAA,GAAI,MAAM,MAAM,CAAA;AAAA,IAC9C;AACA,IAAA,KAAA,CAAM,SAAS,IAAA,GAAO,IAAA;AACtB,IAAA,KAAA,CAAM,CAAA,GAAI,IAAA;AAAA,EACZ;AAMA,EAAA,IAAI,MAAM,KAAA,EAAO;AACf,IAAA,MAAM,YAAY,YAAA,GAAe,wBAAA;AACjC,IAAA,KAAA,CAAM,CAAA,IAAK,SAAA;AACX,IAAA,KAAA,CAAM,MAAA,IAAU,SAAA;AAAA,EAClB;AACF;AAGA,SAAS,iBAAiB,MAAA,EAA8C;AACtE,EAAA,MAAM,SAA4B,EAAC;AACnC,EAAA,KAAA,MAAW,KAAK,MAAA,EAAQ;AACtB,IAAA,MAAA,CAAO,KAAK,CAAC,CAAA;AACb,IAAA,MAAA,CAAO,IAAA,CAAK,GAAG,gBAAA,CAAiB,CAAA,CAAE,QAAQ,CAAC,CAAA;AAAA,EAC7C;AACA,EAAA,OAAO,MAAA;AACT;AAGA,SAAS,aAAA,CAAc,QAA2B,EAAA,EAAyC;AACzF,EAAA,KAAA,MAAW,KAAK,MAAA,EAAQ;AACtB,IAAA,IAAI,CAAA,CAAE,EAAA,KAAO,EAAA,EAAI,OAAO,CAAA;AACxB,IAAA,MAAM,KAAA,GAAQ,aAAA,CAAc,CAAA,CAAE,QAAA,EAAU,EAAE,CAAA;AAC1C,IAAA,IAAI,OAAO,OAAO,KAAA;AAAA,EACpB;AACA,EAAA,OAAO,MAAA;AACT;AAGA,SAAS,WAAA,CAAY,KAAA,EAAwB,EAAA,EAAY,EAAA,EAA6B;AACpF,EAAA,OAAO;AAAA,IACL,GAAG,KAAA;AAAA,IACH,CAAA,EAAG,MAAM,CAAA,GAAI,EAAA;AAAA,IACb,CAAA,EAAG,MAAM,CAAA,GAAI,EAAA;AAAA,IACb,QAAA,EAAU,MAAM,QAAA,CAAS,GAAA,CAAI,OAAK,WAAA,CAAY,CAAA,EAAG,EAAA,EAAI,EAAE,CAAC;AAAA,GAC1D;AACF;AAGA,SAAS,qBAAA,CAAsB,IAAqB,GAAA,EAAwB;AAC1E,EAAA,GAAA,CAAI,GAAA,CAAI,GAAG,EAAE,CAAA;AACb,EAAA,KAAA,MAAW,KAAA,IAAS,GAAG,QAAA,EAAU;AAC/B,IAAA,qBAAA,CAAsB,OAAO,GAAG,CAAA;AAAA,EAClC;AACF;;;ACh5BO,SAAS,UACd,KAAA,EACA,MAAA,EACA,IAAA,GAAe,OAAA,EACf,cAAuB,KAAA,EACf;AACR,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA,CAAK,WAAW,KAAA,CAAM,KAAA,EAAO,MAAM,MAAA,EAAQ,MAAA,EAAQ,WAAW,CAAC,CAAA;AACrE,EAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,KAAK,CAAC,CAAA;AACvC,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,EAAA,KAAA,CAAM,IAAA,CAAK,iBAAiB,CAAA;AAC5B,EAAA,KAAA,CAAM,KAAK,SAAS,CAAA;AAGpB,EAAA,KAAA,MAAW,KAAA,IAAS,MAAM,MAAA,EAAQ;AAChC,IAAA,KAAA,CAAM,IAAA,CAAK,WAAA,CAAY,KAAW,CAAC,CAAA;AAAA,EACrC;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,KAAA,CAAM,IAAA,CAAK,UAAA,CAAW,IAAI,CAAC,CAAA;AAAA,EAC7B;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,IAAI,KAAK,KAAA,EAAO;AACd,MAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAU,CAAC,CAAA;AAAA,IACxC;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAI,CAAC,CAAA;AAAA,EAClC;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,MAAM,KAAA,EAAO;AAC9B,IAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAU,CAAC,CAAA;AAAA,EACxC;AAEA,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AAEnB,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAWA,SAAS,eAAA,GAA0B;AACjC,EAAA,MAAM,IAAI,UAAA,CAAW,KAAA;AACrB,EAAA,MAAM,IAAI,UAAA,CAAW,MAAA;AACrB,EAAA;AAAA;AAAA,IAEE,CAAA,sCAAA,EAAyC,CAAC,CAAA,gBAAA,EAAmB,CAAC,WAAW,CAAC,CAAA,QAAA,EAAW,IAAI,CAAC,CAAA;AAAA,0BAAA,EAC3D,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,CAAC,OAAO,CAAC,CAAA;AAAA;AAAA,4CAAA,EAGA,CAAC,CAAA,gBAAA,EAAmB,CAAC,CAAA,iBAAA,EAAoB,IAAI,CAAC,CAAA;AAAA,qBAAA,EACrE,CAAC,CAAA,MAAA,EAAS,CAAA,GAAI,CAAC,CAAA,EAAA,EAAK,CAAC,IAAI,CAAC,CAAA;AAAA,WAAA;AAAA;AAGxD;AAMA,SAAS,WAAA,CAAY,OAAwB,IAAA,EAAsB;AACjE,EAAA,MAAM,YAAA,GAAe,WAAW,WAAA,GAAc,EAAA;AAC9C,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,KAAA,CAAM,CAAC,CAAA,KAAA,EAAQ,MAAM,CAAC,CAAA,SAAA,EAAY,KAAA,CAAM,KAAK,CAAA,UAAA,EAAa,KAAA,CAAM,MAAM,CAAA,qFAAA,EACI,cAAc,QAAQ,CAAA,IAAA;AAAA,GAC9G;AAGA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,KAAA,CAAM,CAAC,CAAA,KAAA,EAAQ,KAAA,CAAM,CAAC,CAAA,SAAA,EAAY,KAAA,CAAM,KAAK,CAAA,UAAA,EAAa,YAAY,CAAA,oFAAA,EACG,cAAc,QAAQ,CAAA,IAAA;AAAA,GAC7G;AAGA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,MAAM,CAAA,GAAI,EAAE,QAAQ,KAAA,CAAM,CAAA,GAAI,eAAe,CAAC,CAAA,MAAA,EACnD,mBAAmB,CAAA,aAAA,EAAgB,UAAA,CAAW,WAAW,CAAA,eAAA,EAAkB,YAAA,CAAa,WAAW,CAAA,0BAAA,EAC/E,SAAA,CAAU,KAAA,CAAM,KAAK,CAAC,CAAA,OAAA;AAAA,GACnD;AAGA,EAAA,KAAA,MAAW,KAAA,IAAS,MAAM,QAAA,EAAU;AAClC,IAAA,KAAA,CAAM,IAAA,CAAK,WAAA,CAAY,KAAW,CAAC,CAAA;AAAA,EACrC;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAMA,SAAS,WAAW,IAAA,EAA8B;AAChD,EAAA,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,EAAA;AAEnC,EAAA,MAAM,QAAA,GAAW,oBAAA,CAAqB,IAAA,CAAK,MAAM,CAAA;AACjD,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA,KAAU,QAAA,GAAW,yBAAA,GAA4B,EAAA;AACxE,EAAA,MAAM,cAAc,IAAA,CAAK,KAAA,KAAU,UAAU,aAAA,CAAc,SAAA,GAAY,IAAI,aAAA,CAAc,SAAA;AAGzF,EAAA,IAAI,OAAA,GAAU,EAAA;AACd,EAAA,IAAI,IAAA,CAAK,aAAa,OAAA,IAAW,+BAAA;AACjC,EAAA,IAAI,IAAA,CAAK,eAAe,OAAA,IAAW,uCAAA;AAEnC,EAAA,OACE,qBAAqB,QAAQ,CAAA,kDAAA,EACZ,WAAW,CAAA,CAAA,EAAI,SAAS,GAAG,OAAO,CAAA,GAAA,CAAA;AAEvD;AAGA,SAAS,qBAAqB,MAAA,EAAyB;AACrD,EAAA,OAAO,MAAA,CAAO,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,EAAG,CAAA,CAAE,CAAC,CAAA,CAAA,EAAI,CAAA,CAAE,CAAC,CAAA,CAAE,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AAClD;AAEA,SAAS,eAAA,CAAgB,MAAsB,IAAA,EAAsB;AAGnE,EAAA,MAAM,GAAA,GAAM,IAAA,CAAK,aAAA,IAAiB,YAAA,CAAa,KAAK,MAAM,CAAA;AAC1D,EAAA,MAAM,QAAQ,IAAA,CAAK,KAAA;AACnB,EAAA,MAAM,YAAY,iBAAA,CAAkB,KAAA,EAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AACvF,EAAA,MAAM,OAAA,GAAU,CAAA;AAGhB,EAAA,MAAM,OAAA,GAAU,YAAY,OAAA,GAAU,CAAA;AACtC,EAAA,MAAM,QAAA,GAAW,UAAA,CAAW,SAAA,GAAY,OAAA,GAAU,CAAA;AAElD,EAAA,OACE,CAAA,SAAA,EAAY,GAAA,CAAI,CAAA,GAAI,OAAA,GAAU,CAAC,CAAA,KAAA,EAAQ,GAAA,CAAI,CAAA,GAAI,QAAA,GAAW,CAAC,CAAA,SAAA,EACjD,OAAO,aAAa,QAAQ,CAAA;AAAA,SAAA,EAE1B,IAAI,CAAC,CAAA,KAAA,EAAQ,GAAA,CAAI,CAAC,8BAA8B,mBAAmB,CAAA,aAAA,EACjE,UAAA,CAAW,SAAS,kBAAkB,YAAA,CAAa,SAAS,CAAA,4BAAA,EAC7C,SAAA,CAAU,KAAK,CAAC,CAAA,OAAA,CAAA;AAEjD;AAGA,SAAS,aAAa,MAAA,EAAwB;AAC5C,EAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG,OAAO,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC7C,EAAA,IAAI,MAAA,CAAO,MAAA,KAAW,CAAA,EAAG,OAAO,OAAO,CAAC,CAAA;AAGxC,EAAA,IAAI,WAAA,GAAc,CAAA;AAClB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,IAAA,WAAA,IAAe,KAAK,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,EAAI,MAAA,CAAO,CAAC,CAAE,CAAA;AAAA,EAChD;AAGA,EAAA,IAAI,YAAY,WAAA,GAAc,CAAA;AAC9B,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,IAAA,MAAM,MAAA,GAAS,KAAK,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,EAAI,MAAA,CAAO,CAAC,CAAE,CAAA;AAC9C,IAAA,IAAI,aAAa,MAAA,EAAQ;AACvB,MAAA,MAAM,IAAI,SAAA,GAAY,MAAA;AACtB,MAAA,OAAO;AAAA,QACL,CAAA,EAAG,MAAA,CAAO,CAAA,GAAI,CAAC,EAAG,CAAA,GAAI,CAAA,IAAK,MAAA,CAAO,CAAC,CAAA,CAAG,CAAA,GAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,CAAA,CAAA;AAAA,QACzD,CAAA,EAAG,MAAA,CAAO,CAAA,GAAI,CAAC,EAAG,CAAA,GAAI,CAAA,IAAK,MAAA,CAAO,CAAC,CAAA,CAAG,CAAA,GAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,CAAA;AAAA,OAC3D;AAAA,IACF;AACA,IAAA,SAAA,IAAa,MAAA;AAAA,EACf;AAEA,EAAA,OAAO,MAAA,CAAO,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA;AACjC;AAEA,SAAS,IAAA,CAAK,GAAU,CAAA,EAAkB;AACxC,EAAA,OAAO,IAAA,CAAK,IAAA,CAAA,CAAM,CAAA,CAAE,CAAA,GAAI,CAAA,CAAE,CAAA,KAAM,CAAA,GAAA,CAAK,CAAA,CAAE,CAAA,GAAI,CAAA,CAAE,CAAA,KAAM,CAAC,CAAA;AACtD;AAMA,SAAS,gBAAgB,IAAA,EAA8B;AACrD,EAAA,MAAM,EAAE,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,KAAA,EAAO,aAAY,GAAI,IAAA;AAKpD,EAAA,MAAM,IAAA,GAAO,SAAA,CAAU,WAAA,EAAa,IAAA,IAAQ,mBAAmB,CAAA;AAC/D,EAAA,MAAM,MAAA,GAAS,SAAA,CAAU,WAAA,EAAa,MAAA,IAAU,qBAAqB,CAAA;AACrE,EAAA,MAAM,EAAA,GAAK,UAAU,WAAA,GAAc,cAAc,KAAK,MAAA,CAAO,aAAA,CAAc,QAAQ,CAAC,CAAA;AAEpF,EAAA,QAAQ,KAAA;AAAO,IACb,KAAK,SAAA;AACH,MAAA,OAAO,cAAc,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC5D,KAAK,SAAA;AACH,MAAA,OAAO,kBAAkB,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAChE,KAAK,SAAA;AACH,MAAA,OAAO,cAAc,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC5D,KAAK,QAAA;AACH,MAAA,OAAO,aAAa,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC3D,KAAK,YAAA;AACH,MAAA,OAAO,iBAAiB,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC/D,KAAK,cAAA;AACH,MAAA,OAAO,mBAAmB,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IACjE,KAAK,SAAA;AACH,MAAA,OAAO,cAAc,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC5D,KAAK,UAAA;AACH,MAAA,OAAO,eAAe,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC7D,KAAK,YAAA;AACH,MAAA,OAAO,iBAAiB,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC/D,KAAK,WAAA;AACH,MAAA,OAAO,gBAAgB,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IAC9D,KAAK,eAAA;AACH,MAAA,OAAO,mBAAmB,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA,IACjE,KAAK,aAAA;AACH,MAAA,OAAO,gBAAA,CAAiB,CAAA,EAAG,CAAA,EAAG,KAAA,EAAO,MAAM,CAAA;AAAA,IAC7C,KAAK,WAAA;AACH,MAAA,OAAO,cAAA,CAAe,CAAA,EAAG,CAAA,EAAG,KAAA,EAAO,MAAM,CAAA;AAAA,IAC3C,KAAK,WAAA;AAAA,IACL;AACE,MAAA,OAAO,WAAW,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,IAAA,EAAM,QAAQ,EAAE,CAAA;AAAA;AAE7D;AAIA,SAAS,WAAW,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AAChH,EAAA,OACE,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,CAAC,CAAA,UAAA,EAAa,CAAC,CAAA,sBAAA,EAC1B,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAEvE;AAEA,SAAS,kBAAkB,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACvH,EAAA,OACE,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,CAAC,CAAA,UAAA,EAAa,CAAC,CAAA,sBAAA,EAC1B,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAEvE;AAEA,SAAS,cAAc,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACnH,EAAA,MAAM,IAAI,CAAA,GAAI,CAAA;AACd,EAAA,OACE,YAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,CAAC,CAAA,UAAA,EAAa,CAAC,CAAA,MAAA,EAC1C,CAAC,SAAS,CAAC,CAAA,QAAA,EAAW,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAE7E;AAEA,SAAS,aAAa,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AAClH,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,CAAA,GAAI,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,CAAC,CAAA,GAAI,CAAA;AAC3B,EAAA,OACE,CAAA,YAAA,EAAe,EAAE,CAAA,MAAA,EAAS,EAAE,CAAA,KAAA,EAAQ,CAAC,CAAA,QAAA,EAC5B,IAAI,CAAA,UAAA,EAAa,MAAM,CAAA,gBAAA,EAAmB,EAAE,CAAA,IAAA,CAAA;AAEzD;AAEA,SAAS,cAAc,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACnH,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,KAAK,CAAA,GAAI,CAAA;AACf,EAAA,MAAM,KAAK,CAAA,GAAI,CAAA;AACf,EAAA,MAAM,MAAA,GAAS;AAAA,IACb,CAAA,EAAG,EAAE,CAAA,CAAA,EAAI,EAAA,GAAK,EAAE,CAAA,CAAA;AAAA;AAAA,IAChB,CAAA,EAAG,EAAA,GAAK,EAAE,CAAA,CAAA,EAAI,EAAE,CAAA,CAAA;AAAA;AAAA,IAChB,CAAA,EAAG,EAAE,CAAA,CAAA,EAAI,EAAA,GAAK,EAAE,CAAA,CAAA;AAAA;AAAA,IAChB,CAAA,EAAG,EAAA,GAAK,EAAE,CAAA,CAAA,EAAI,EAAE,CAAA;AAAA;AAAA,GAClB,CAAE,KAAK,GAAG,CAAA;AAEV,EAAA,OACE,oBAAoB,MAAM,CAAA,QAAA,EAAW,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAErF;AAKA,SAAS,iBAAiB,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACtH,EAAA,MAAM,KAAA,GAAQ,CAAA;AACd,EAAA,OACE,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,CAAC,CAAA,UAAA,EAAa,CAAC,CAAA,sBAAA,EAC1B,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA;AAAA,UAAA,EACpD,CAAA,GAAI,KAAK,CAAA,MAAA,EAAS,CAAC,CAAA,MAAA,EAAS,CAAA,GAAI,KAAK,CAAA,MAAA,EAAS,CAAA,GAAI,CAAC,CAAA,UAAA,EACvD,MAAM,mBAAmB,EAAE,CAAA;AAAA,UAAA,EACvB,CAAA,GAAI,CAAA,GAAI,KAAK,CAAA,MAAA,EAAS,CAAC,CAAA,MAAA,EAAS,CAAA,GAAI,CAAA,GAAI,KAAK,SAAS,CAAA,GAAI,CAAC,CAAA,UAAA,EAC/D,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAE1C;AAGA,SAAS,mBAAmB,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACxH,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,CAAC,CAAA,GAAI,CAAA;AAChC,EAAA,MAAM,SAAS,MAAA,GAAS,CAAA;AACxB,EAAA,OACE,CAAA,YAAA,EAAe,EAAE,CAAA,MAAA,EAAS,EAAE,CAAA,KAAA,EAAQ,MAAM,CAAA,QAAA,EACjC,IAAI,CAAA,UAAA,EAAa,MAAM,CAAA,gBAAA,EAAmB,EAAE,CAAA;AAAA,YAAA,EACpC,EAAE,CAAA,MAAA,EAAS,EAAE,CAAA,KAAA,EAAQ,MAAM,WACnC,IAAI,CAAA,UAAA,EAAa,MAAM,CAAA,gBAAA,EAAmB,EAAE,CAAA,IAAA,CAAA;AAEzD;AAGA,SAAS,cAAc,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACnH,EAAA,MAAM,QAAQ,CAAA,GAAI,CAAA;AAClB,EAAA,MAAM,MAAA,GAAS;AAAA,IACb,CAAA,EAAG,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACjB,CAAA,EAAG,CAAA,GAAI,CAAA,GAAI,KAAK,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACrB,GAAG,CAAA,GAAI,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACrB,GAAG,CAAA,GAAI,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACzB,CAAA,EAAG,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACrB,CAAA,EAAG,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,IAAI,CAAC,CAAA;AAAA;AAAA,GACnB,CAAE,KAAK,GAAG,CAAA;AAEV,EAAA,OAAO,oBAAoB,MAAM,CAAA,QAAA,EAAW,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAC1F;AAKA,SAAS,eAAe,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACpH,EAAA,MAAM,EAAA,GAAK,CAAA;AACX,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,UAAU,CAAA,GAAI,EAAA;AACpB,EAAA,MAAM,KAAA,GAAQ,IAAI,CAAA,GAAI,EAAA;AAEtB,EAAA;AAAA;AAAA,IAEE,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,OAAO,YAAY,CAAC,CAAA,UAAA,EAAa,KAAK,CAAA,QAAA,EAClD,IAAI,CAAA;AAAA,UAAA,EAEE,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,MAAA,EAAS,CAAC,CAAA,MAAA,EAAS,OAAA,GAAU,KAAK,CAAA,UAAA,EAAa,MAAM,CAAA,gBAAA,EAAmB,EAAE,CAAA;AAAA,UAAA,EAC3F,CAAA,GAAI,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,MAAA,EAAS,CAAA,GAAI,CAAC,CAAA,MAAA,EAAS,OAAA,GAAU,KAAK,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA;AAAA,aAAA,EAEhG,EAAE,CAAA,MAAA,EAAS,CAAA,GAAI,CAAA,GAAI,EAAE,CAAA,MAAA,EAAS,CAAA,GAAI,CAAC,CAAA,MAAA,EAAS,EAAE,CAAA,QAAA,EACvD,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA;AAAA,aAAA,EAEnC,EAAE,CAAA,MAAA,EAAS,OAAO,CAAA,MAAA,EAAS,CAAA,GAAI,CAAC,CAAA,MAAA,EAAS,EAAE,CAAA,QAAA,EACpD,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA;AAAA;AAEzD;AAGA,SAAS,iBAAiB,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACtH,EAAA,MAAM,MAAA,GAAS,EAAA;AACf,EAAA,MAAM,MAAA,GAAS;AAAA,IACb,CAAA,EAAG,CAAA,GAAI,MAAM,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IAClB,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACb,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACjB,CAAA,EAAG,CAAA,GAAI,MAAM,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACtB,CAAA,EAAG,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,IAAI,CAAC,CAAA;AAAA;AAAA,GACnB,CAAE,KAAK,GAAG,CAAA;AAEV,EAAA,OAAO,oBAAoB,MAAM,CAAA,QAAA,EAAW,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAC1F;AAGA,SAAS,gBAAgB,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACrH,EAAA,MAAM,QAAQ,CAAA,GAAI,IAAA;AAClB,EAAA,MAAM,MAAA,GAAS;AAAA,IACb,CAAA,EAAG,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACjB,CAAA,EAAG,CAAA,GAAI,CAAA,GAAI,KAAK,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACrB,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACjB,CAAA,EAAG,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,CAAC,CAAA;AAAA;AAAA,GACf,CAAE,KAAK,GAAG,CAAA;AAEV,EAAA,OAAO,oBAAoB,MAAM,CAAA,QAAA,EAAW,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAC1F;AAGA,SAAS,mBAAmB,CAAA,EAAW,CAAA,EAAW,GAAW,CAAA,EAAW,IAAA,EAAc,QAAgB,EAAA,EAAoB;AACxH,EAAA,MAAM,QAAQ,CAAA,GAAI,IAAA;AAClB,EAAA,MAAM,MAAA,GAAS;AAAA,IACb,CAAA,EAAG,CAAC,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACT,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACb,GAAG,CAAA,GAAI,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA;AAAA;AAAA,IACzB,CAAA,EAAG,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA;AAAA;AAAA,GACvB,CAAE,KAAK,GAAG,CAAA;AAEV,EAAA,OAAO,oBAAoB,MAAM,CAAA,QAAA,EAAW,IAAI,CAAA,UAAA,EAAa,MAAM,mBAAmB,EAAE,CAAA,IAAA,CAAA;AAC1F;AAKA,SAAS,gBAAA,CAAiB,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,CAAA,EAAmB;AAC5E,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,IAAI,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,CAAC,IAAI,CAAA,GAAI,CAAA;AAC/B,EAAA,OAAO,CAAA,YAAA,EAAe,EAAE,CAAA,MAAA,EAAS,EAAE,QAAQ,CAAC,CAAA,sCAAA,CAAA;AAC9C;AAGA,SAAS,cAAA,CAAe,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,CAAA,EAAmB;AAC1E,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,EAAA,GAAK,IAAI,CAAA,GAAI,CAAA;AACnB,EAAA,MAAM,SAAS,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,CAAC,IAAI,CAAA,GAAI,CAAA;AACpC,EAAA,MAAM,SAAS,MAAA,GAAS,CAAA;AACxB,EAAA,OACE,CAAA,YAAA,EAAe,EAAE,CAAA,MAAA,EAAS,EAAE,QAAQ,MAAM,CAAA,kDAAA,EACS,aAAA,CAAc,QAAA,GAAW,CAAC,CAAA;AAAA,YAAA,EAC5D,EAAE,CAAA,MAAA,EAAS,EAAE,CAAA,KAAA,EAAQ,MAAM,CAAA,sCAAA,CAAA;AAEhD;AAMA,SAAS,eAAA,CAAgB,MAAsB,IAAA,EAAsB;AAEnE,EAAA,IAAI,IAAA,CAAK,KAAA,KAAU,aAAA,IAAiB,IAAA,CAAK,UAAU,WAAA,EAAa;AAC9D,IAAA,IAAI,CAAC,IAAA,CAAK,KAAA,EAAO,OAAO,EAAA;AAAA,EAC1B;AAEA,EAAA,MAAM,EAAA,GAAK,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAA,GAAQ,CAAA;AACjC,EAAA,MAAM,EAAA,GAAK,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,MAAA,GAAS,CAAA;AAGlC,EAAA,MAAM,SAAA,GAAY,SAAA,CAAU,IAAA,CAAK,WAAA,EAAa,SAAS,cAAc,CAAA;AAErE,EAAA,OACE,YAAY,EAAE,CAAA,KAAA,EAAQ,EAAE,CAAA,2BAAA,EAA8B,mBAAmB,gBAC3D,UAAA,CAAW,SAAS,CAAA,eAAA,EAAkB,YAAA,CAAa,SAAS,CAAA,QAAA,EACjE,SAAS,KAAK,SAAA,CAAU,IAAA,CAAK,KAAK,CAAC,CAAA,OAAA,CAAA;AAEhD;AAOA,SAAS,UAAU,IAAA,EAAsB;AACvC,EAAA,OAAO,KACJ,OAAA,CAAQ,IAAA,EAAM,OAAO,CAAA,CACrB,OAAA,CAAQ,MAAM,MAAM,CAAA,CACpB,QAAQ,IAAA,EAAM,MAAM,EACpB,OAAA,CAAQ,IAAA,EAAM,QAAQ,CAAA,CACtB,OAAA,CAAQ,MAAM,OAAO,CAAA;AAC1B;;;ACldA,IAAM,GAAA,GAAM;AAAA;AAAA,EAEV,OAAA,EAAS,EAAA;AAAA;AAAA,EAET,QAAA,EAAU,GAAA;AAAA;AAAA,EAEV,WAAA,EAAa,EAAA;AAAA;AAAA,EAEb,SAAA,EAAW,EAAA;AAAA;AAAA,EAEX,SAAA,EAAW,EAAA;AAAA;AAAA,EAEX,gBAAA,EAAkB,EAAA;AAAA;AAAA,EAElB,iBAAA,EAAmB,EAAA;AAAA;AAAA,EAEnB,eAAA,EAAiB,EAAA;AAAA;AAAA,EAEjB,SAAA,EAAW,EAAA;AAAA,EACX,WAAA,EAAa,EAAA;AAAA,EACb,cAAA,EAAgB,CAAA;AAAA;AAAA,EAEhB,gBAAA,EAAkB,EAAA;AAAA;AAAA,EAElB,YAAA,EAAc,EAAA;AAAA;AAAA,EAEd,SAAA,EAAW,GAAA;AAAA,EACX,WAAA,EAAa,CAAA;AAAA,EACb,OAAA,EAAS;AACX,CAAA;AAMO,SAAS,qBAAA,CACd,OAAA,EACA,QAAA,GAA0B,EAAC,EACA;AAC3B,EAAA,IAAI,OAAA,CAAQ,MAAA,CAAO,MAAA,KAAW,CAAA,EAAG;AAC/B,IAAA,OAAO,EAAE,OAAO,CAAA,EAAG,MAAA,EAAQ,GAAG,MAAA,EAAQ,EAAC,EAAG,SAAA,EAAW,EAAC,EAAG,UAAU,EAAC,EAAG,aAAa,EAAC,EAAG,QAAQ,EAAC,EAAG,KAAA,EAAO,EAAC,EAAE;AAAA,EAChH;AAGA,EAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,MAAA,CAAO,GAAA,CAAI,CAAA,CAAA,KAAK;AAC1C,IAAA,MAAM,QAAQ,iBAAA,CAAkB,CAAA,CAAE,OAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AACrF,IAAA,OAAO,KAAK,GAAA,CAAI,KAAA,GAAQ,GAAA,CAAI,SAAA,GAAY,GAAG,EAAE,CAAA;AAAA,EAC/C,CAAC,CAAA;AAGD,EAAA,MAAM,eAAyB,EAAC;AAChC,EAAA,IAAI,QAAA,GAAW,GAAA,CAAI,OAAA,GAAU,WAAA,CAAY,CAAC,CAAA,GAAK,CAAA;AAC/C,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,IAAI,IAAI,CAAA,EAAG;AACT,MAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,QAAA,EAAA,CAAW,WAAA,CAAY,CAAA,GAAI,CAAC,CAAA,GAAK,WAAA,CAAY,CAAC,CAAA,IAAM,IAAI,EAAE,CAAA;AACtF,MAAA,QAAA,IAAY,MAAA;AAAA,IACd;AACA,IAAA,YAAA,CAAa,KAAK,QAAQ,CAAA;AAAA,EAC5B;AAGA,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAoB;AAC3C,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,UAAA,CAAW,IAAI,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,CAAG,IAAI,CAAC,CAAA;AAAA,EACzC;AAGA,EAAA,MAAM,SAAS,GAAA,CAAI,OAAA;AACnB,EAAA,MAAM,SAA4B,OAAA,CAAQ,MAAA,CAAO,GAAA,CAAI,CAAC,GAAG,CAAA,MAAO;AAAA,IAC9D,IAAI,CAAA,CAAE,EAAA;AAAA,IACN,OAAO,CAAA,CAAE,KAAA;AAAA,IACT,MAAM,CAAA,CAAE,IAAA;AAAA,IACR,CAAA,EAAG,aAAa,CAAC,CAAA;AAAA,IACjB,CAAA,EAAG,MAAA;AAAA,IACH,KAAA,EAAO,YAAY,CAAC,CAAA;AAAA,IACpB,QAAQ,GAAA,CAAI;AAAA,GACd,CAAE,CAAA;AAGF,EAAA,IAAI,QAAA,GAAW,MAAA,GAAS,GAAA,CAAI,WAAA,GAAc,GAAA,CAAI,SAAA;AAC9C,EAAA,MAAM,WAAgC,EAAC;AAMvC,EAAA,MAAM,gBAAA,uBAAuB,GAAA,EAAoB;AACjD,EAAA,KAAA,MAAW,KAAA,IAAS,QAAQ,MAAA,EAAQ;AAElC,IAAA,MAAM,IAAA,GAAO,gBAAA,CAAiB,GAAA,CAAI,KAAA,CAAM,UAAU,CAAA,IAAK,CAAA;AACvD,IAAA,gBAAA,CAAiB,GAAA,CAAI,MAAM,UAAA,EAAY,IAAA,CAAK,IAAI,IAAA,EAAM,GAAA,CAAI,gBAAgB,CAAC,CAAA;AAG3E,IAAA,KAAA,MAAW,GAAA,IAAO,MAAM,QAAA,EAAU;AAChC,MAAA,MAAM,OAAA,GAAU,gBAAA,CAAiB,GAAA,CAAI,GAAA,CAAI,KAAK,CAAA,IAAK,CAAA;AACnD,MAAA,gBAAA,CAAiB,GAAA,CAAI,IAAI,KAAA,EAAO,IAAA,CAAK,IAAI,OAAA,EAAS,GAAA,CAAI,YAAY,CAAC,CAAA;AAAA,IACrE;AAAA,EACF;AAGA,EAAA,MAAM,gBAAA,uBAAuB,GAAA,EAAsB;AACnD,EAAA,MAAM,cAA4B,EAAC;AAEnC,EAAA,KAAA,IAAS,SAAS,CAAA,EAAG,MAAA,GAAS,OAAA,CAAQ,QAAA,CAAS,QAAQ,MAAA,EAAA,EAAU;AAC/D,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,QAAA,CAAS,MAAM,CAAA;AACnC,IAAA,MAAM,OAAA,GAAU,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA,IAAK,CAAA;AAC5C,IAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA,IAAK,CAAA;AACxC,IAAA,MAAM,MAAA,GAAS,GAAA,CAAI,IAAA,KAAS,GAAA,CAAI,EAAA;AAGhC,IAAA,MAAM,KAAA,GAAQ,gBAAA,CAAiB,GAAA,CAAI,MAAM,CAAA,IAAK,CAAA;AAC9C,IAAA,IAAI,KAAA,GAAQ,GAAG,QAAA,IAAY,KAAA;AAE3B,IAAA,MAAM,EAAA,GAAK,aAAa,OAAO,CAAA;AAC/B,IAAA,MAAM,EAAA,GAAK,aAAa,KAAK,CAAA;AAE7B,IAAA,QAAA,CAAS,IAAA,CAAK;AAAA,MACZ,MAAM,GAAA,CAAI,IAAA;AAAA,MACV,IAAI,GAAA,CAAI,EAAA;AAAA,MACR,OAAO,GAAA,CAAI,KAAA;AAAA,MACX,WAAW,GAAA,CAAI,SAAA;AAAA,MACf,WAAW,GAAA,CAAI,SAAA;AAAA,MACf,EAAA;AAAA,MAAI,EAAA;AAAA,MACJ,CAAA,EAAG,QAAA;AAAA,MACH;AAAA,KACD,CAAA;AAGD,IAAA,IAAI,IAAI,QAAA,EAAU;AAChB,MAAA,IAAI,CAAC,gBAAA,CAAiB,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA,EAAG;AACjC,QAAA,gBAAA,CAAiB,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,EAAE,CAAA;AAAA,MACjC;AACA,MAAA,gBAAA,CAAiB,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA,CAAG,KAAK,QAAQ,CAAA;AAAA,IAC7C;AAEA,IAAA,IAAI,IAAI,UAAA,EAAY;AAClB,MAAA,MAAM,KAAA,GAAQ,gBAAA,CAAiB,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA;AAC3C,MAAA,IAAI,KAAA,IAAS,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;AAC7B,QAAA,MAAM,MAAA,GAAS,MAAM,GAAA,EAAI;AACzB,QAAA,MAAM,GAAA,GAAM,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA,IAAK,CAAA;AACxC,QAAA,WAAA,CAAY,IAAA,CAAK;AAAA,UACf,SAAS,GAAA,CAAI,IAAA;AAAA,UACb,CAAA,EAAG,YAAA,CAAa,GAAG,CAAA,GAAK,IAAI,eAAA,GAAkB,CAAA;AAAA,UAC9C,IAAA,EAAM,MAAA;AAAA,UACN,OAAA,EAAS,QAAA;AAAA,UACT,OAAO,GAAA,CAAI;AAAA,SACZ,CAAA;AAAA,MACH;AAAA,IACF;AAEA,IAAA,QAAA,IAAY,MAAA,GAAS,GAAA,CAAI,iBAAA,GAAoB,GAAA,CAAI,mBAAmB,GAAA,CAAI,gBAAA;AAAA,EAC1E;AAGA,EAAA,KAAA,MAAW,CAAC,OAAA,EAAS,KAAK,CAAA,IAAK,gBAAA,EAAkB;AAC/C,IAAA,KAAA,MAAW,UAAU,KAAA,EAAO;AAC1B,MAAA,MAAM,GAAA,GAAM,UAAA,CAAW,GAAA,CAAI,OAAO,CAAA,IAAK,CAAA;AACvC,MAAA,WAAA,CAAY,IAAA,CAAK;AAAA,QACf,OAAA;AAAA,QACA,CAAA,EAAG,YAAA,CAAa,GAAG,CAAA,GAAK,IAAI,eAAA,GAAkB,CAAA;AAAA,QAC9C,IAAA,EAAM,MAAA;AAAA,QACN,OAAA,EAAS,QAAA,GAAW,GAAA,CAAI,gBAAA,GAAmB,CAAA;AAAA,QAC3C,OAAO,GAAA,CAAI;AAAA,OACZ,CAAA;AAAA,IACH;AAAA,EACF;AAGA,EAAA,MAAM,MAAA,GAA4B,OAAA,CAAQ,MAAA,CAAO,GAAA,CAAI,CAAA,KAAA,KAAS;AAE5D,IAAA,MAAM,QAAA,GAAW,QAAA,CAAS,KAAA,CAAM,UAAU,CAAA;AAC1C,IAAA,MAAM,MAAA,GAAS,QAAA,CAAS,KAAA,CAAM,QAAQ,CAAA;AACtC,IAAA,MAAM,QAAA,GAAA,CAAY,QAAA,EAAU,CAAA,IAAK,QAAA,IAAY,GAAA,CAAI,WAAA;AACjD,IAAA,MAAM,WAAA,GAAA,CAAe,MAAA,EAAQ,CAAA,IAAK,QAAA,IAAY,IAAI,cAAA,GAAiB,EAAA;AAGnE,IAAA,MAAM,cAAA,uBAAqB,GAAA,EAAY;AACvC,IAAA,KAAA,IAAS,KAAK,KAAA,CAAM,UAAA,EAAY,EAAA,IAAM,KAAA,CAAM,UAAU,EAAA,EAAA,EAAM;AAC1D,MAAA,MAAM,CAAA,GAAI,OAAA,CAAQ,QAAA,CAAS,EAAE,CAAA;AAC7B,MAAA,IAAI,CAAA,EAAG;AACL,QAAA,cAAA,CAAe,IAAI,UAAA,CAAW,GAAA,CAAI,CAAA,CAAE,IAAI,KAAK,CAAC,CAAA;AAC9C,QAAA,cAAA,CAAe,IAAI,UAAA,CAAW,GAAA,CAAI,CAAA,CAAE,EAAE,KAAK,CAAC,CAAA;AAAA,MAC9C;AAAA,IACF;AAEA,IAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,MAAA,KAAA,IAAS,EAAA,GAAK,GAAG,EAAA,GAAK,OAAA,CAAQ,OAAO,MAAA,EAAQ,EAAA,EAAA,EAAM,cAAA,CAAe,GAAA,CAAI,EAAE,CAAA;AAAA,IAC1E;AACA,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,GAAG,cAAc,CAAA;AACzC,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,GAAG,cAAc,CAAA;AACzC,IAAA,MAAM,SAAA,GAAY,aAAa,MAAM,CAAA,GAAK,YAAY,MAAM,CAAA,GAAK,IAAI,GAAA,CAAI,SAAA;AACzE,IAAA,MAAM,UAAA,GAAa,aAAa,MAAM,CAAA,GAAK,YAAY,MAAM,CAAA,GAAK,IAAI,GAAA,CAAI,SAAA;AAY1E,IAAA,MAAM,QAAA,GAAW,KAAA,CAAM,QAAA,CAAS,GAAA,CAAI,CAAA,CAAA,KAAK;AACvC,MAAA,MAAM,GAAA,GAAM,QAAA,CAAS,CAAA,CAAE,KAAK,CAAA;AAC5B,MAAA,MAAM,IAAA,GAAO,KAAK,CAAA,IAAK,QAAA;AACvB,MAAA,IAAI,MAAA,GAAS,EAAA;AAKb,MAAA,IAAI,CAAA,CAAE,KAAA,IAAS,GAAA,EAAK,KAAA,EAAO;AACzB,QAAA,MAAM,YAAA,GAAe,CAAA,CAAA,EAAI,CAAA,CAAE,KAAK,CAAA,CAAA,CAAA;AAChC,QAAA,MAAM,YAAY,iBAAA,CAAkB,YAAA,EAAc,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AAC9F,QAAA,MAAM,eAAe,SAAA,GAAY,CAAA;AACjC,QAAA,MAAM,gBAAgB,YAAA,GAAe,SAAA;AAErC,QAAA,MAAM,YAAY,iBAAA,CAAkB,GAAA,CAAI,OAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AAG3F,QAAA,MAAM,YAAA,GAAe,GAAA,CAAI,MAAA,GACrB,GAAA,CAAI,EAAA,GAAK,EAAA,GAAA,CACR,GAAA,CAAI,EAAA,GAAK,GAAA,CAAI,EAAA,IAAM,CAAA,GAAI,SAAA,GAAY,CAAA;AACxC,QAAA,MAAM,gBAAgB,YAAA,GAAe,SAAA;AAErC,QAAA,IAAI,aAAA,GAAgB,YAAA,IAAgB,YAAA,GAAe,aAAA,EAAe;AAChE,UAAA,MAAA,GAAS,EAAA;AAAA,QACX;AAAA,MACF;AAEA,MAAA,OAAO,EAAE,CAAA,EAAG,IAAA,GAAO,MAAA,EAAQ,KAAA,EAAO,EAAE,KAAA,EAAM;AAAA,IAC5C,CAAC,CAAA;AAED,IAAA,OAAO;AAAA,MACL,MAAM,KAAA,CAAM,IAAA;AAAA,MACZ,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,CAAA,EAAG,SAAA;AAAA,MACH,CAAA,EAAG,QAAA;AAAA,MACH,OAAO,UAAA,GAAa,SAAA;AAAA,MACpB,QAAQ,WAAA,GAAc,QAAA;AAAA,MACtB;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AAGD,EAAA,MAAM,KAAA,GAA0B,OAAA,CAAQ,KAAA,CAAM,GAAA,CAAI,CAAA,IAAA,KAAQ;AACxD,IAAA,MAAM,QAAQ,IAAA,CAAK,GAAA;AAAA,MACjB,GAAA,CAAI,SAAA;AAAA,MACJ,iBAAA,CAAkB,KAAK,IAAA,EAAM,UAAA,CAAW,WAAW,YAAA,CAAa,SAAS,CAAA,GAAI,GAAA,CAAI,WAAA,GAAc;AAAA,KACjG;AACA,IAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,SAAA,GAAY,GAAA,CAAI,WAAA,GAAc,CAAA;AAGvD,IAAA,MAAM,MAAA,GAAS,QAAA,CAAS,IAAA,CAAK,UAAU,CAAA;AACvC,IAAA,MAAM,KAAA,GAAA,CAAS,MAAA,EAAQ,CAAA,IAAK,MAAA,GAAS,IAAI,WAAA,IAAe,CAAA;AAGxD,IAAA,MAAM,aAAA,GAAgB,WAAW,GAAA,CAAI,IAAA,CAAK,SAAS,CAAC,CAAA,IAAK,EAAE,CAAA,IAAK,CAAA;AAChE,IAAA,IAAI,KAAA;AACJ,IAAA,IAAI,IAAA,CAAK,aAAa,MAAA,EAAQ;AAC5B,MAAA,KAAA,GAAQ,YAAA,CAAa,aAAa,CAAA,GAAK,WAAA,CAAY,aAAa,CAAA,GAAK,CAAA,GAAI,QAAQ,GAAA,CAAI,OAAA;AAAA,IACvF,CAAA,MAAA,IAAW,IAAA,CAAK,QAAA,KAAa,OAAA,EAAS;AACpC,MAAA,KAAA,GAAQ,aAAa,aAAa,CAAA,GAAK,YAAY,aAAa,CAAA,GAAK,IAAI,GAAA,CAAI,OAAA;AAAA,IAC/E,CAAA,MAAO;AAEL,MAAA,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG;AAC5B,QAAA,MAAM,YAAA,GAAe,UAAA,CAAW,GAAA,CAAI,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAA,CAAS,MAAA,GAAS,CAAC,CAAA,IAAK,EAAE,CAAA,IAAK,aAAA;AACtF,QAAA,KAAA,GAAA,CAAS,aAAa,aAAa,CAAA,GAAK,aAAa,YAAY,CAAA,IAAM,IAAI,KAAA,GAAQ,CAAA;AAAA,MACrF,CAAA,MAAO;AACL,QAAA,KAAA,GAAQ,YAAA,CAAa,aAAa,CAAA,GAAK,KAAA,GAAQ,CAAA;AAAA,MACjD;AAAA,IACF;AAEA,IAAA,OAAO,EAAE,IAAA,EAAM,IAAA,CAAK,IAAA,EAAM,CAAA,EAAG,KAAA,EAAO,CAAA,EAAG,KAAA,EAAO,KAAA,EAAO,KAAA,EAAO,MAAA,EAAQ,KAAA,EAAM;AAAA,EAC5E,CAAC,CAAA;AAQD,EAAA,MAAM,aAAA,GAAgB,WAAW,GAAA,CAAI,OAAA;AAGrC,EAAA,IAAI,aAAa,GAAA,CAAI,OAAA;AACrB,EAAA,IAAI,UAAA,GAAa,CAAA;AACjB,EAAA,KAAA,MAAW,KAAK,MAAA,EAAQ;AACtB,IAAA,UAAA,GAAa,KAAK,GAAA,CAAI,UAAA,EAAY,EAAE,CAAA,GAAI,CAAA,CAAE,QAAQ,CAAC,CAAA;AACnD,IAAA,UAAA,GAAa,KAAK,GAAA,CAAI,UAAA,EAAY,EAAE,CAAA,GAAI,CAAA,CAAE,QAAQ,CAAC,CAAA;AAAA,EACrD;AACA,EAAA,KAAA,MAAW,KAAK,MAAA,EAAQ;AACtB,IAAA,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,UAAA,EAAY,CAAA,CAAE,CAAC,CAAA;AACrC,IAAA,UAAA,GAAa,KAAK,GAAA,CAAI,UAAA,EAAY,CAAA,CAAE,CAAA,GAAI,EAAE,KAAK,CAAA;AAAA,EACjD;AACA,EAAA,KAAA,MAAW,KAAK,KAAA,EAAO;AACrB,IAAA,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,UAAA,EAAY,CAAA,CAAE,CAAC,CAAA;AACrC,IAAA,UAAA,GAAa,KAAK,GAAA,CAAI,UAAA,EAAY,CAAA,CAAE,CAAA,GAAI,EAAE,KAAK,CAAA;AAAA,EACjD;AAGA,EAAA,MAAM,SAAS,UAAA,GAAa,GAAA,CAAI,OAAA,GAAU,GAAA,CAAI,UAAU,UAAA,GAAa,CAAA;AACrE,EAAA,IAAI,SAAS,CAAA,EAAG;AACd,IAAA,KAAA,MAAW,CAAA,IAAK,MAAA,EAAQ,CAAA,CAAE,CAAA,IAAK,MAAA;AAC/B,IAAA,KAAA,MAAW,KAAK,QAAA,EAAU;AAAE,MAAA,CAAA,CAAE,EAAA,IAAM,MAAA;AAAQ,MAAA,CAAA,CAAE,EAAA,IAAM,MAAA;AAAA,IAAO;AAC3D,IAAA,KAAA,MAAW,GAAA,IAAO,WAAA,EAAa,GAAA,CAAI,CAAA,IAAK,MAAA;AACxC,IAAA,KAAA,MAAW,KAAK,MAAA,EAAQ;AAAE,MAAA,CAAA,CAAE,CAAA,IAAK,MAAA;AAAA,IAAQ;AACzC,IAAA,KAAA,MAAW,CAAA,IAAK,KAAA,EAAO,CAAA,CAAE,CAAA,IAAK,MAAA;AAE9B,IAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,YAAA,CAAa,QAAQ,CAAA,EAAA,EAAK,YAAA,CAAa,CAAC,CAAA,IAAM,MAAA;AAAA,EACpE;AAGA,EAAA,MAAM,YAAwB,OAAA,CAAQ,MAAA,CAAO,GAAA,CAAI,CAAC,GAAG,CAAA,MAAO;AAAA,IAC1D,SAAS,CAAA,CAAE,EAAA;AAAA,IACX,CAAA,EAAG,aAAa,CAAC,CAAA;AAAA,IACjB,IAAA,EAAM,SAAS,GAAA,CAAI,WAAA;AAAA,IACnB,OAAA,EAAS,gBAAgB,GAAA,CAAI;AAAA,GAC/B,CAAE,CAAA;AAGF,EAAA,MAAM,YAAA,GAAe,UAAA,GAAa,MAAA,GAAS,GAAA,CAAI,OAAA;AAC/C,EAAA,MAAM,aAAA,GAAgB,aAAA;AAEtB,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,IAAA,CAAK,GAAA,CAAI,YAAA,EAAc,GAAG,CAAA;AAAA,IACjC,MAAA,EAAQ,IAAA,CAAK,GAAA,CAAI,aAAA,EAAe,GAAG,CAAA;AAAA,IACnC,MAAA;AAAA,IACA,SAAA;AAAA,IACA,QAAA;AAAA,IACA,WAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,GACF;AACF;;;ACtUO,SAAS,kBACd,OAAA,EACA,MAAA,EACA,IAAA,GAAe,OAAA,EACf,cAAuB,KAAA,EACf;AACR,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA,CAAK,WAAW,OAAA,CAAQ,KAAA,EAAO,QAAQ,MAAA,EAAQ,MAAA,EAAQ,WAAW,CAAC,CAAA;AACzE,EAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,KAAK,CAAC,CAAA;AACvC,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AAGnB,EAAA,KAAA,CAAM,IAAA,CAAKC,kBAAiB,CAAA;AAC5B,EAAA,KAAA,CAAM,KAAK,SAAS,CAAA;AAGpB,EAAA,KAAA,MAAW,KAAA,IAAS,QAAQ,MAAA,EAAQ;AAClC,IAAA,KAAA,CAAM,IAAA,CAAK,WAAA,CAAY,KAAK,CAAC,CAAA;AAAA,EAC/B;AAGA,EAAA,KAAA,MAAW,QAAA,IAAY,QAAQ,SAAA,EAAW;AACxC,IAAA,KAAA,CAAM,IAAA,CAAK,cAAA,CAAe,QAAQ,CAAC,CAAA;AAAA,EACrC;AAGA,EAAA,KAAA,MAAW,UAAA,IAAc,QAAQ,WAAA,EAAa;AAC5C,IAAA,KAAA,CAAM,IAAA,CAAK,gBAAA,CAAiB,UAAU,CAAC,CAAA;AAAA,EACzC;AAGA,EAAA,KAAA,MAAW,OAAA,IAAW,QAAQ,QAAA,EAAU;AACtC,IAAA,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,OAAO,CAAC,CAAA;AAAA,EACnC;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,QAAQ,KAAA,EAAO;AAChC,IAAA,KAAA,CAAM,IAAA,CAAK,UAAA,CAAW,IAAI,CAAC,CAAA;AAAA,EAC7B;AAGA,EAAA,KAAA,MAAW,KAAA,IAAS,QAAQ,MAAA,EAAQ;AAClC,IAAA,KAAA,CAAM,IAAA,CAAK,WAAA,CAAY,KAAK,CAAC,CAAA;AAAA,EAC/B;AAEA,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAMA,SAASA,gBAAAA,GAA0B;AACjC,EAAA,MAAM,IAAI,UAAA,CAAW,KAAA;AACrB,EAAA,MAAM,IAAI,UAAA,CAAW,MAAA;AACrB,EAAA,OACE,CAAA,sCAAA,EAAyC,CAAC,CAAA,gBAAA,EAAmB,CAAC,WAAW,CAAC,CAAA,QAAA,EAAW,IAAI,CAAC,CAAA;AAAA,0BAAA,EAC3D,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,CAAC,OAAO,CAAC,CAAA;AAAA;AAAA,2CAAA,EAGD,CAAC,CAAA,gBAAA,EAAmB,CAAC,WAAW,CAAC,CAAA,QAAA,EAAW,IAAI,CAAC,CAAA;AAAA,2BAAA,EACjE,CAAC,CAAA,CAAA,EAAI,CAAA,GAAI,CAAC,OAAO,CAAC,CAAA;AAAA,WAAA,CAAA;AAGtD;AAOA,SAAS,YAAY,KAAA,EAAgC;AACnD,EAAA,MAAM,EAAE,CAAA,EAAG,CAAA,EAAG,OAAO,MAAA,EAAQ,KAAA,EAAO,MAAK,GAAI,KAAA;AAE7C,EAAA,IAAI,SAAS,OAAA,EAAS;AAKpB,IAAA,MAAM,CAAA,GAAK,SAAS,EAAA,GAAM,GAAA;AAC1B,IAAA,MAAM,EAAA,GAAK,IAAI,EAAA,GAAK,CAAA;AACpB,IAAA,MAAM,EAAA,GAAK,CAAA,GAAA,CAAK,MAAA,GAAS,EAAA,GAAK,CAAA,IAAK,CAAA;AACnC,IAAA,MAAM,EAAA,GAAK,cAAc,QAAA,GAAW,CAAA;AACpC,IAAA,MAAM,UAAA,GAAa,cAAA;AAEnB,IAAA,OACE,CAAA,wBAAA,EAA2B,EAAE,CAAA,CAAA,EAAI,EAAE,WAAW,CAAC,CAAA;AAAA,kJAAA,EAEwG,UAAU,mBAAmB,EAAE,CAAA;AAAA,kJAAA,EAE/B,UAAU,mBAAmB,EAAE,CAAA;AAAA,0HAAA,EAEvD,UAAU,mBAAmB,EAAE,CAAA;AAAA;AAAA,SAAA,EAGhJ,CAAC,CAAA,KAAA,EAAQ,CAAA,GAAI,MAAA,GAAS,EAAE,CAAA,kCAAA,EAAqC,UAAA,CAAW,SAAS,CAAA,eAAA,EAAkB,YAAA,CAAa,SAAS,CAAA,sBAAA,EAAyBC,UAAAA,CAAU,KAAK,CAAC,CAAA,OAAA,CAAA;AAAA,EAEpL;AAGA,EAAA,MAAM,IAAA,GAAO,IAAI,KAAA,GAAQ,CAAA;AACzB,EAAA,OACE,CAAA,SAAA,EAAY,IAAI,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,KAAK,CAAA,UAAA,EAAa,MAAM,CAAA,oFAAA,EACU,aAAA,CAAc,QAAQ,CAAA;AAAA,SAAA,EAC/E,CAAC,CAAA,KAAA,EAAQ,CAAA,GAAI,MAAA,GAAS,CAAC,8BAA8B,mBAAmB,CAAA,aAAA,EACxE,UAAA,CAAW,SAAS,kBAAkB,YAAA,CAAa,SAAS,CAAA,sBAAA,EAAyBA,UAAAA,CAAU,KAAK,CAAC,CAAA,OAAA,CAAA;AAEvH;AAGA,SAAS,eAAe,QAAA,EAA4B;AAClD,EAAA,OACE,CAAA,UAAA,EAAa,QAAA,CAAS,CAAC,CAAA,MAAA,EAAS,QAAA,CAAS,IAAI,CAAA,MAAA,EAAS,QAAA,CAAS,CAAC,CAAA,MAAA,EAAS,QAAA,CAAS,OAAO,CAAA,qEAAA,CAAA;AAG7F;AAGA,SAAS,iBAAiB,UAAA,EAAgC;AACxD,EAAA,OACE,YAAY,UAAA,CAAW,CAAC,CAAA,KAAA,EAAQ,UAAA,CAAW,IAAI,CAAA,SAAA,EAAY,UAAA,CAAW,KAAK,CAAA,UAAA,EAAa,WAAW,OAAA,GAAU,UAAA,CAAW,IAAI,CAAA,sEAAA,EACrD,cAAc,QAAQ,CAAA,IAAA,CAAA;AAEjG;AAGA,SAAS,cAAc,GAAA,EAAgC;AACrD,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,SAAA,GAAY,GAAA,CAAI,SAAA,KAAc,QAAA,GAAW,yBAAA,GAA4B,EAAA;AAC3E,EAAA,MAAM,QAAA,GAAW,GAAA,CAAI,SAAA,KAAc,QAAA,GAAW,WAAA,GAAc,gBAAA;AAE5D,EAAA,IAAI,IAAI,MAAA,EAAQ;AAEd,IAAA,MAAM,KAAA,GAAQ,EAAA;AACd,IAAA,MAAM,KAAA,GAAQ,EAAA;AACd,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,kBAAA,EAAqB,GAAA,CAAI,EAAE,CAAA,CAAA,EAAI,IAAI,CAAC,CAAA,CAAA,EAAI,GAAA,CAAI,EAAA,GAAK,KAAK,CAAA,CAAA,EAAI,GAAA,CAAI,CAAC,CAAA,CAAA,EAAI,IAAI,EAAA,GAAK,KAAK,CAAA,CAAA,EAAI,GAAA,CAAI,CAAA,GAAI,KAAK,CAAA,CAAA,EAAI,GAAA,CAAI,EAAE,CAAA,CAAA,EAAI,GAAA,CAAI,CAAA,GAAI,KAAK,qDAC1E,aAAA,CAAc,SAAS,CAAA,CAAA,EAAI,SAAS,qBAAqB,QAAQ,CAAA,KAAA;AAAA,KACtH;AAEA,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,SAAA,EAAY,IAAI,EAAA,GAAK,KAAA,GAAQ,CAAC,CAAA,KAAA,EAAQ,GAAA,CAAI,CAAA,GAAI,KAAA,GAAQ,CAAC,CAAA,MAAA,EAAS,mBAAmB,CAAA,aAAA,EACrE,UAAA,CAAW,SAAS,CAAA,eAAA,EAAkB,YAAA,CAAa,SAAS,CAAA,4BAAA,EAA+BA,UAAAA,CAAU,GAAA,CAAI,KAAK,CAAC,CAAA,OAAA;AAAA,KAC/H;AAAA,EACF,CAAA,MAAO;AAEL,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,aAAa,GAAA,CAAI,EAAE,SAAS,GAAA,CAAI,CAAC,SAAS,GAAA,CAAI,EAAE,CAAA,MAAA,EAAS,GAAA,CAAI,CAAC,CAAA,sCAAA,EACvB,aAAA,CAAc,SAAS,CAAA,CAAA,EAAI,SAAS,qBAAqB,QAAQ,CAAA,KAAA;AAAA,KAC1G;AAEA,IAAA,MAAM,IAAA,GAAA,CAAQ,GAAA,CAAI,EAAA,GAAK,GAAA,CAAI,EAAA,IAAM,CAAA;AACjC,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,YAAY,IAAI,CAAA,KAAA,EAAQ,GAAA,CAAI,CAAA,GAAI,CAAC,CAAA,kCAAA,EACnB,UAAA,CAAW,SAAS,CAAA,eAAA,EAAkB,aAAa,SAAS,CAAA,4BAAA,EAA+BA,UAAAA,CAAU,GAAA,CAAI,KAAK,CAAC,CAAA,OAAA;AAAA,KAC/H;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAGA,SAAS,YAAY,KAAA,EAAgC;AACnD,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,KAAA,CAAM,CAAC,CAAA,KAAA,EAAQ,MAAM,CAAC,CAAA,SAAA,EAAY,KAAA,CAAM,KAAK,CAAA,UAAA,EAAa,KAAA,CAAM,MAAM,CAAA,uEAAA,EACV,cAAc,QAAQ,CAAA,IAAA;AAAA,GAChG;AAGA,EAAA,MAAM,SAAA,GAAY,CAAA,EAAG,KAAA,CAAM,IAAI,CAAA,EAAG,KAAA,CAAM,KAAA,GAAQ,CAAA,EAAA,EAAK,KAAA,CAAM,KAAK,CAAA,CAAA,CAAA,GAAM,EAAE,CAAA,CAAA;AACxE,EAAA,MAAM,WAAW,iBAAA,CAAkB,SAAA,EAAW,WAAW,SAAA,EAAW,YAAA,CAAa,WAAW,CAAA,GAAI,EAAA;AAChG,EAAA,MAAM,SAAA,GAAY,EAAA;AAElB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,KAAA,CAAM,CAAC,CAAA,KAAA,EAAQ,KAAA,CAAM,CAAC,CAAA,SAAA,EAAY,QAAQ,CAAA,UAAA,EAAa,SAAS,CAAA,sEAAA,EACL,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GAC/F;AACA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,MAAM,CAAA,GAAI,CAAC,QAAQ,KAAA,CAAM,CAAA,GAAI,YAAY,CAAC,CAAA,MAAA,EAAS,mBAAmB,CAAA,aAAA,EACpE,UAAA,CAAW,SAAS,CAAA,eAAA,EAAkB,YAAA,CAAa,WAAW,CAAA,0BAAA,EAA6BA,UAAAA,CAAU,SAAS,CAAC,CAAA,OAAA;AAAA,GAC/H;AAGA,EAAA,KAAA,MAAW,OAAA,IAAW,MAAM,QAAA,EAAU;AACpC,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,UAAA,EAAa,KAAA,CAAM,CAAC,CAAA,MAAA,EAAS,OAAA,CAAQ,CAAC,CAAA,MAAA,EAAS,KAAA,CAAM,CAAA,GAAI,KAAA,CAAM,KAAK,CAAA,MAAA,EAAS,QAAQ,CAAC,CAAA,qEAAA;AAAA,KAExF;AACA,IAAA,IAAI,QAAQ,KAAA,EAAO;AACjB,MAAA,KAAA,CAAM,IAAA;AAAA,QACJ,YAAY,KAAA,CAAM,CAAA,GAAI,CAAC,CAAA,KAAA,EAAQ,OAAA,CAAQ,IAAI,EAAE,CAAA,aAAA,EAAgB,UAAA,CAAW,SAAS,kBACjE,YAAA,CAAa,SAAS,gCAAgCA,UAAAA,CAAU,OAAA,CAAQ,KAAK,CAAC,CAAA,QAAA;AAAA,OAChG;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAGA,SAAS,WAAW,IAAA,EAA8B;AAEhD,EAAA,MAAM,QAAA,GAAW,CAAA;AACjB,EAAA,OACE,CAAA,SAAA,EAAY,IAAA,CAAK,CAAC,CAAA,KAAA,EAAQ,KAAK,CAAC,CAAA,SAAA,EAAY,IAAA,CAAK,KAAK,CAAA,UAAA,EAAa,IAAA,CAAK,MAAM,CAAA,sEAAA,EACP,cAAc,QAAQ,CAAA;AAAA,iBAAA,EAEvE,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAA,GAAQ,QAAQ,CAAA,CAAA,EAAI,IAAA,CAAK,CAAC,CAAA,CAAA,EAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAK,IAAI,IAAA,CAAK,CAAA,GAAI,QAAQ,CAAA,CAAA,EAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,KAAA,GAAQ,QAAQ,CAAA,CAAA,EAAI,IAAA,CAAK,CAAA,GAAI,QAAQ,CAAA;AAAA,SAAA,EAGnJ,IAAA,CAAK,IAAI,IAAA,CAAK,KAAA,GAAQ,CAAC,CAAA,KAAA,EAAQ,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,MAAA,GAAS,CAAC,8BAA8B,mBAAmB,CAAA,aAAA,EACxG,UAAA,CAAW,SAAS,CAAA,eAAA,EAAkB,YAAA,CAAa,SAAS,CAAA,4BAAA,EAA+BA,UAAAA,CAAU,IAAA,CAAK,IAAI,CAAC,CAAA,OAAA,CAAA;AAEjI;AAMA,SAASA,WAAU,IAAA,EAAsB;AACvC,EAAA,OAAO,KACJ,OAAA,CAAQ,IAAA,EAAM,OAAO,CAAA,CACrB,OAAA,CAAQ,MAAM,MAAM,CAAA,CACpB,QAAQ,IAAA,EAAM,MAAM,EACpB,OAAA,CAAQ,IAAA,EAAM,QAAQ,CAAA,CACtB,OAAA,CAAQ,MAAM,OAAO,CAAA;AAC1B;AC7OO,IAAM,GAAA,GAAM;AAAA;AAAA,EAEjB,OAAA,EAAS,EAAA;AAAA;AAAA,EAET,OAAA,EAAS,CAAA;AAAA;AAAA,EAET,gBAAA,EAAkB,EAAA;AAAA;AAAA,EAElB,gBAAA,EAAkB,EAAA;AAAA;AAAA,EAElB,eAAA,EAAiB,EAAA;AAAA;AAAA,EAEjB,WAAA,EAAa,CAAA;AAAA;AAAA,EAEb,kBAAA,EAAoB,CAAA;AAAA;AAAA,EAEpB,QAAA,EAAU,GAAA;AAAA;AAAA,EAEV,cAAA,EAAgB,EAAA;AAAA,EAEE;AAAA,EAElB,WAAA,EAAa,EAAA;AAAA;AAAA,EAEb,YAAA,EAAc;AAChB,CAAA;AAQA,eAAsB,kBAAA,CACpB,OAAA,EACA,QAAA,GAA0B,EAAC,EACM;AACjC,EAAA,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;AAChC,IAAA,OAAO,EAAE,KAAA,EAAO,CAAA,EAAG,MAAA,EAAQ,CAAA,EAAG,SAAS,EAAC,EAAG,aAAA,EAAe,EAAC,EAAE;AAAA,EAC/D;AAGA,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAA+G;AAEtI,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,IAAA,MAAM,eAAe,GAAA,CAAI,UAAA,GACrB,IAAI,gBAAA,GAAmB,GAAA,CAAI,mBAC3B,GAAA,CAAI,gBAAA;AAER,IAAA,MAAM,UAAA,GAAa,GAAA,CAAI,UAAA,CAAW,MAAA,GAAS,CAAA,GACvC,GAAA,CAAI,UAAA,CAAW,MAAA,GAAS,GAAA,CAAI,eAAA,GAAkB,GAAA,CAAI,WAAA,GAClD,GAAA,CAAI,kBAAA;AAER,IAAA,MAAM,YAAA,GAAe,GAAA,CAAI,OAAA,CAAQ,MAAA,GAAS,CAAA,GACtC,GAAA,CAAI,OAAA,CAAQ,MAAA,GAAS,GAAA,CAAI,eAAA,GAAkB,GAAA,CAAI,WAAA,GAC/C,GAAA,CAAI,kBAAA;AAGR,IAAA,MAAM,cAAc,iBAAA,CAAkB,GAAA,CAAI,OAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AAC7F,IAAA,MAAM,QAAA,GAAW,cAAA,CAAe,GAAA,CAAI,UAAU,CAAA;AAC9C,IAAA,MAAM,UAAA,GAAa,cAAA,CAAe,GAAA,CAAI,OAAO,CAAA;AAC7C,IAAA,MAAM,QAAQ,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,QAAA,EAAU,cAAc,GAAA,CAAI,OAAA,GAAU,CAAA,EAAG,QAAA,GAAW,IAAI,OAAA,GAAU,CAAA,EAAG,UAAA,GAAa,GAAA,CAAI,UAAU,CAAC,CAAA;AAE5H,IAAA,MAAM,MAAA,GAAS,eAAe,UAAA,GAAa,YAAA;AAE3C,IAAA,UAAA,CAAW,GAAA,CAAI,IAAI,EAAA,EAAI,EAAE,OAAO,MAAA,EAAQ,YAAA,EAAc,UAAA,EAAY,YAAA,EAAc,CAAA;AAAA,EAClF;AAGA,EAAA,MAAM,CAAA,GAAI,IAAIL,sBAAAA,CAAM,QAAA,CAAS,MAAM,EAAE,QAAA,EAAU,MAAM,CAAA;AACrD,EAAA,CAAA,CAAE,QAAA,CAAS;AAAA,IACT,OAAA,EAAS,IAAA;AAAA,IACT,SAAA,EAAW,QAAA;AAAA;AAAA,IACX,SAAS,GAAA,CAAI,WAAA;AAAA,IACb,SAAS,GAAA,CAAI,YAAA;AAAA,IACb,SAAS,GAAA,CAAI,OAAA;AAAA,IACb,SAAS,GAAA,CAAI;AAAA,GACd,CAAA;AACD,EAAA,CAAA,CAAE,mBAAA,CAAoB,OAAO,EAAC,CAAE,CAAA;AAEhC,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,IAAA,MAAM,IAAA,GAAO,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAClC,IAAA,CAAA,CAAE,OAAA,CAAQ,GAAA,CAAI,EAAA,EAAI,EAAE,KAAA,EAAO,KAAK,KAAA,EAAO,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ,CAAA;AAAA,EAC9D;AAGA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,aAAA,CAAc,QAAQ,CAAA,EAAA,EAAK;AACrD,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,aAAA,CAAc,CAAC,CAAA;AACnC,IAAA,MAAM,SAAA,GAAqC,EAAE,MAAA,EAAQ,CAAA,EAAE;AACvD,IAAA,IAAI,IAAI,KAAA,EAAO;AACb,MAAA,SAAA,CAAU,QAAQ,GAAA,CAAI,KAAA;AACtB,MAAA,SAAA,CAAU,KAAA,GAAQ,kBAAkB,GAAA,CAAI,KAAA,EAAO,WAAW,SAAA,EAAW,YAAA,CAAa,SAAS,CAAA,GAAI,CAAA;AAC/F,MAAA,SAAA,CAAU,MAAA,GAAS,WAAW,SAAA,GAAY,CAAA;AAC1C,MAAA,SAAA,CAAU,QAAA,GAAW,GAAA;AAAA,IACvB;AACA,IAAA,CAAA,CAAE,OAAA,CAAQ,GAAA,CAAI,IAAA,EAAM,GAAA,CAAI,IAAI,SAAS,CAAA;AAAA,EACvC;AAIA,EAAA,IAAI;AACF,IAAAA,sBAAAA,CAAM,OAAO,CAAC,CAAA;AAAA,EAChB,SAAS,GAAA,EAAK;AACZ,IAAA,MAAM,UAAU,GAAA,YAAe,KAAA,GAAQ,GAAA,CAAI,OAAA,GAAU,OAAO,GAAG,CAAA;AAC/D,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qCAAA,EAAwC,OAAO,CAAA,CAAE,CAAA;AAAA,EACnE;AAGA,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAAuB;AAC/C,EAAA,KAAA,MAAW,OAAO,OAAA,CAAQ,OAAA,cAAqB,GAAA,CAAI,GAAA,CAAI,IAAI,GAAG,CAAA;AAE9D,EAAA,MAAM,iBAAA,GAA2C,OAAA,CAAQ,OAAA,CAAQ,GAAA,CAAI,CAAA,GAAA,KAAO;AAC1E,IAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,GAAA,CAAI,EAAE,CAAA;AAC/B,IAAA,MAAM,IAAA,GAAO,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA;AAClC,IAAA,MAAM,OAAA,GAAU,gBAAgB,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG,SAAA,CAAU,KAAA,EAAO,SAAA,CAAU,MAAM,CAAA;AAC3F,IAAA,OAAO;AAAA,MACL,IAAI,GAAA,CAAI,EAAA;AAAA,MACR,OAAO,GAAA,CAAI,KAAA;AAAA,MACX,YAAY,GAAA,CAAI,UAAA;AAAA,MAChB,YAAY,GAAA,CAAI,UAAA;AAAA,MAChB,SAAS,GAAA,CAAI,OAAA;AAAA,MACb,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,KAAA,EAAO,SAAA,CAAU,KAAA,IAAS,IAAA,CAAK,KAAA;AAAA,MAC/B,MAAA,EAAQ,SAAA,CAAU,MAAA,IAAU,IAAA,CAAK,MAAA;AAAA,MACjC,cAAc,IAAA,CAAK,YAAA;AAAA,MACnB,YAAY,IAAA,CAAK,UAAA;AAAA,MACjB,cAAc,IAAA,CAAK;AAAA,KACrB;AAAA,EACF,CAAC,CAAA;AAGD,EAAA,MAAM,aAAA,GAA+C,CAAA,CAAE,KAAA,EAAM,CAAE,IAAI,CAAA,OAAA,KAAW;AAC5E,IAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;AAChC,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,aAAA,CAAc,SAAA,CAAU,MAAgB,CAAA;AAC5D,IAAA,MAAM,SAAA,GAAY,SAAA,CAAU,MAAA,IAAU,EAAC;AAEvC,IAAA,MAAM,WAAA,GAAc,gBAAA,CAAiB,SAAA,EAAW,IAAI,CAAA;AAMpD,IAAA,MAAM,OAAA,GAAU,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAChC,IAAA,MAAM,OAAA,GAAU,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAChC,IAAA,MAAM,MAAA,GAAS,oBAAA;AAAA,MACb,WAAA;AAAA,MACA,UAAU,EAAE,EAAA,EAAI,OAAA,CAAQ,CAAA,EAAG,IAAI,OAAA,CAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,QAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,MAAA,GAAS,GAAE,GAAI,IAAA;AAAA,MAC5F,UAAU,EAAE,EAAA,EAAI,OAAA,CAAQ,CAAA,EAAG,IAAI,OAAA,CAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,QAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,MAAA,GAAS,GAAE,GAAI;AAAA,KAC9F;AAGA,IAAA,IAAI,aAAA;AACJ,IAAA,IAAI,IAAI,KAAA,IAAS,SAAA,CAAU,KAAK,IAAA,IAAQ,SAAA,CAAU,KAAK,IAAA,EAAM;AAC3D,MAAA,aAAA,GAAgB,EAAE,CAAA,EAAG,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,UAAU,CAAA,EAAE;AAAA,IACnD;AAEA,IAAA,OAAO;AAAA,MACL,MAAM,GAAA,CAAI,IAAA;AAAA,MACV,IAAI,GAAA,CAAI,EAAA;AAAA,MACR,MAAM,GAAA,CAAI,IAAA;AAAA,MACV,UAAU,GAAA,CAAI,QAAA;AAAA,MACd,OAAO,GAAA,CAAI,KAAA;AAAA,MACX,iBAAiB,GAAA,CAAI,eAAA;AAAA,MACrB,eAAe,GAAA,CAAI,aAAA;AAAA,MACnB,MAAA;AAAA,MACA;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,CAAA,CAAE,KAAA,EAAM,CAAE,KAAA,IAAS,GAAA;AAAA,IAC1B,MAAA,EAAQ,CAAA,CAAE,KAAA,EAAM,CAAE,MAAA,IAAU,GAAA;AAAA,IAC5B,OAAA,EAAS,iBAAA;AAAA,IACT;AAAA,GACF;AACF;AAGA,SAAS,eAAe,OAAA,EAAgC;AACtD,EAAA,IAAI,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG,OAAO,CAAA;AACjC,EAAA,IAAI,IAAA,GAAO,CAAA;AACX,EAAA,KAAA,MAAW,KAAK,OAAA,EAAS;AACvB,IAAA,MAAM,IAAA,GAAO,eAAe,CAAC,CAAA;AAE7B,IAAA,MAAM,CAAA,GAAI,qBAAA,CAAsB,IAAA,EAAM,GAAA,CAAI,cAAc,CAAA;AACxD,IAAA,IAAI,CAAA,GAAI,MAAM,IAAA,GAAO,CAAA;AAAA,EACvB;AACA,EAAA,OAAO,IAAA;AACT;AAGO,SAAS,eAAe,CAAA,EAAwB;AACrD,EAAA,MAAM,MAAM,CAAA,CAAE,UAAA,GAAa,CAAA,EAAG,CAAA,CAAE,UAAU,CAAA,CAAA,CAAA,GAAM,EAAA;AAChD,EAAA,MAAM,OAAO,CAAA,CAAE,IAAA,GAAO,CAAA,EAAA,EAAK,CAAA,CAAE,IAAI,CAAA,CAAA,GAAK,EAAA;AACtC,EAAA,OAAO,GAAG,GAAG,CAAA,EAAG,CAAA,CAAE,IAAI,GAAG,IAAI,CAAA,CAAA;AAC/B;;;ACrMA,IAAM,QAAA,GAAW;AAAA,EACf,UAAA,EAAY,EAAA;AAAA,EACZ,YAAA,EAAc,GAAA;AAAA,EACd,cAAA,EAAgB,EAAA;AAAA,EAChB,gBAAA,EAAkB;AACpB,CAAA;AAQO,SAAS,eACd,OAAA,EACA,MAAA,EACA,IAAA,GAAe,OAAA,EACf,cAAuB,KAAA,EACf;AACR,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA,CAAK,WAAW,OAAA,CAAQ,KAAA,EAAO,QAAQ,MAAA,EAAQ,MAAA,EAAQ,WAAW,CAAC,CAAA;AACzE,EAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,IAAI,CAAC,CAAA;AACtC,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,EAAA,KAAA,CAAM,IAAA,CAAK,wBAAwB,CAAA;AACnC,EAAA,KAAA,CAAM,KAAK,SAAS,CAAA;AAGpB,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,KAAA,CAAM,IAAA,CAAK,kBAAA,CAAmB,GAAG,CAAC,CAAA;AAAA,EACpC;AAGA,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,IAAA,KAAA,CAAM,IAAA,CAAK,cAAA,CAAe,GAAG,CAAC,CAAA;AAAA,EAChC;AAGA,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,KAAA,CAAM,IAAA,CAAK,wBAAA,CAAyB,GAAG,CAAC,CAAA;AAAA,EAC1C;AAEA,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAkBA,SAAS,sBAAA,GAAiC;AACxC,EAAA;AAAA;AAAA,IAEE,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAA;AAAA;AAgBJ;AAOA,SAAS,eAAe,GAAA,EAAkC;AACxD,EAAA,MAAM,EAAE,GAAG,CAAA,EAAG,KAAA,EAAO,QAAQ,YAAA,EAAc,UAAA,EAAY,cAAa,GAAI,GAAA;AACxE,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,KAAK,CAAA,UAAA,EAAa,MAAM,CAAA,oFAAA,EAC2B,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GAC7G;AAGA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,KAAK,CAAA,UAAA,EAAa,YAAY,CAAA,oFAAA,EACqB,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GAC7G;AAGA,EAAA,IAAI,KAAA,GAAQ,IAAI,YAAA,GAAe,CAAA;AAC/B,EAAA,IAAI,IAAI,UAAA,EAAY;AAClB,IAAA,MAAM,SAAS,CAAA,GAAI,EAAA;AACnB,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,YAAY,CAAA,GAAI,KAAA,GAAQ,CAAC,CAAA,KAAA,EAAQ,MAAM,8BAA8B,mBAAmB,CAAA,aAAA,EAC1E,QAAA,CAAS,cAAc,kBAAkB,QAAA,CAAS,gBAAgB,2DACvBK,UAAAA,CAAU,GAAA,CAAI,UAAU,CAAC,CAAA,eAAA;AAAA,KACpF;AACA,IAAA,KAAA,GAAQ,CAAA,GAAI,eAAe,CAAA,GAAI,CAAA;AAAA,EACjC;AAGA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,CAAA,GAAI,KAAA,GAAQ,CAAC,QAAQ,KAAK,CAAA,2BAAA,EAA8B,mBAAmB,CAAA,aAAA,EACzE,WAAW,SAAS,CAAA,wCAAA,EAA2CA,UAAAA,CAAU,GAAA,CAAI,KAAK,CAAC,CAAA,OAAA;AAAA,GACnG;AAGA,EAAA,MAAM,UAAU,CAAA,GAAI,YAAA;AACpB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,UAAA,EAAa,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,MAAA,EAAS,CAAA,GAAI,KAAK,CAAA,MAAA,EAAS,OAAO,CAAA,6CAAA,EAClB,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GACtE;AAGA,EAAA,MAAM,UAAA,GAAa,EAAA;AACnB,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC9C,IAAA,MAAM,MAAA,GAAS,GAAA,CAAI,UAAA,CAAW,CAAC,CAAA;AAC/B,IAAA,MAAM,OAAA,GAAU,OAAA,GAAU,CAAA,GAAI,CAAA,GAAI,aAAa,UAAA,GAAa,CAAA;AAC5D,IAAA,KAAA,CAAM,KAAK,YAAA,CAAa,MAAA,EAAQ,IAAI,GAAA,CAAI,OAAA,EAAS,OAAO,CAAC,CAAA;AAAA,EAC3D;AAGA,EAAA,MAAM,YAAY,OAAA,GAAU,UAAA;AAC5B,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,UAAA,EAAa,CAAC,CAAA,MAAA,EAAS,SAAS,CAAA,MAAA,EAAS,CAAA,GAAI,KAAK,CAAA,MAAA,EAAS,SAAS,CAAA,6CAAA,EACtB,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GACtE;AAGA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,OAAA,CAAQ,QAAQ,CAAA,EAAA,EAAK;AAC3C,IAAA,MAAM,MAAA,GAAS,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA;AAC5B,IAAA,MAAM,OAAA,GAAU,SAAA,GAAY,CAAA,GAAI,CAAA,GAAI,aAAa,UAAA,GAAa,CAAA;AAC9D,IAAA,KAAA,CAAM,KAAK,YAAA,CAAa,MAAA,EAAQ,IAAI,GAAA,CAAI,OAAA,EAAS,OAAO,CAAC,CAAA;AAAA,EAC3D;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAUA,SAAS,YAAA,CAAa,MAAA,EAAqB,CAAA,EAAW,CAAA,EAAmB;AACvE,EAAA,MAAM,SAAA,GAAY,MAAA,CAAO,UAAA,GAAa,sBAAA,GAAyB,EAAA;AAC/D,EAAA,MAAM,UAAA,GAAa,MAAA,CAAO,QAAA,GAAW,8BAAA,GAAiC,EAAA;AAGtE,EAAA,MAAM,QAAkB,EAAC;AAEzB,EAAA,IAAI,OAAO,UAAA,EAAY;AACrB,IAAA,KAAA,CAAM,KAAK,CAAA,iCAAA,EAAoCA,UAAAA,CAAU,MAAA,CAAO,UAAU,CAAC,CAAA,SAAA,CAAW,CAAA;AAAA,EACxF;AAEA,EAAA,KAAA,CAAM,KAAK,CAAA,+BAAA,EAAkCA,UAAAA,CAAU,MAAA,CAAO,IAAI,CAAC,CAAA,QAAA,CAAU,CAAA;AAE7E,EAAA,IAAI,OAAO,IAAA,EAAM;AACf,IAAA,KAAA,CAAM,KAAK,CAAA,2CAAA,CAA6C,CAAA;AACxD,IAAA,KAAA,CAAM,KAAK,CAAA,iCAAA,EAAoCA,UAAAA,CAAU,MAAA,CAAO,IAAI,CAAC,CAAA,QAAA,CAAU,CAAA;AAAA,EACjF;AAEA,EAAA,OACE,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,sBAAsB,mBAAmB,CAAA,aAAA,EACjD,SAAS,UAAU,CAAA,eAAA,EAAkB,SAAS,YAAY,CAAA,CAAA,EAAI,SAAS,CAAA,EAAG,UAAU,IAC/F,KAAA,CAAM,IAAA,CAAK,EAAE,CAAC,CAAA,OAAA,CAAA;AAErB;AAOA,SAAS,mBAAmB,GAAA,EAA0C;AACpE,EAAA,IAAI,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,EAAA;AAElC,EAAA,MAAM,QAAA,GAAW,GAAA,CAAI,MAAA,CAAO,GAAA,CAAI,OAAK,CAAA,EAAG,CAAA,CAAE,CAAC,CAAA,CAAA,EAAI,CAAA,CAAE,CAAC,CAAA,CAAE,CAAA,CAAE,KAAK,GAAG,CAAA;AAC9D,EAAA,MAAM,QAAA,GAAW,GAAA,CAAI,IAAA,KAAS,YAAA,IAAgB,IAAI,IAAA,KAAS,aAAA;AAC3D,EAAA,MAAM,SAAA,GAAY,WAAW,yBAAA,GAA4B,EAAA;AAGzD,EAAA,MAAM,OAAA,GAAU,sBAAA,CAAuB,GAAA,CAAI,IAAA,EAAM,IAAI,QAAQ,CAAA;AAE7D,EAAA,OACE,CAAA,kBAAA,EAAqB,QAAQ,CAAA,kDAAA,EACZ,aAAA,CAAc,SAAS,CAAA,CAAA,EAAI,SAAS,GAAG,OAAO,CAAA,GAAA,CAAA;AAEnE;AAQA,SAAS,sBAAA,CAAuB,MAAwB,QAAA,EAAiC;AACvF,EAAA,MAAM,QAAA,GAAW,eAAe,IAAI,CAAA;AACpC,EAAA,IAAI,CAAC,UAAU,OAAO,EAAA;AAEtB,EAAA,IAAI,aAAa,MAAA,EAAQ;AACvB,IAAA,OAAO,uBAAuB,QAAQ,CAAA,EAAA,CAAA;AAAA,EACxC,CAAA,MAAO;AACL,IAAA,OAAO,qBAAqB,QAAQ,CAAA,EAAA,CAAA;AAAA,EACtC;AACF;AAGA,SAAS,eAAe,IAAA,EAAuC;AAC7D,EAAA,QAAQ,IAAA;AAAM,IACZ,KAAK,aAAA;AAAA,IACL,KAAK,aAAA;AACH,MAAA,OAAO,aAAA;AAAA,IACT,KAAK,aAAA;AACH,MAAA,OAAO,iBAAA;AAAA,IACT,KAAK,aAAA;AACH,MAAA,OAAO,iBAAA;AAAA,IACT,KAAK,aAAA;AAAA,IACL,KAAK,YAAA;AACH,MAAA,OAAO,WAAA;AAAA,IACT;AACE,MAAA,OAAO,IAAA;AAAA;AAEb;AAGA,SAAS,yBAAyB,GAAA,EAA0C;AAC1E,EAAA,IAAI,CAAC,IAAI,KAAA,IAAS,CAAC,IAAI,eAAA,IAAmB,CAAC,GAAA,CAAI,aAAA,EAAe,OAAO,EAAA;AACrE,EAAA,IAAI,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,EAAA;AAElC,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,IAAI,IAAI,KAAA,EAAO;AACb,IAAA,MAAM,GAAA,GAAM,GAAA,CAAI,aAAA,IAAiB,QAAA,CAAS,IAAI,MAAM,CAAA;AACpD,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,YAAY,GAAA,CAAI,CAAC,CAAA,KAAA,EAAQ,GAAA,CAAI,IAAI,CAAC,CAAA,kCAAA,EACpB,UAAA,CAAW,SAAS,kBAAkB,YAAA,CAAa,SAAS,+BAC7CA,UAAAA,CAAU,GAAA,CAAI,KAAK,CAAC,CAAA,OAAA;AAAA,KACnD;AAAA,EACF;AAGA,EAAA,IAAI,IAAI,eAAA,EAAiB;AACvB,IAAA,MAAM,CAAA,GAAI,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA;AACtB,IAAA,MAAM,IAAA,GAAO,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA;AACzB,IAAA,MAAM,MAAA,GAAS,iBAAA,CAAkB,CAAA,EAAG,IAAI,CAAA;AACxC,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,SAAA,EAAY,EAAE,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA,KAAA,EAAQ,CAAA,CAAE,IAAI,MAAA,CAAO,CAAC,qCAClC,UAAA,CAAW,SAAS,kBAAkB,YAAA,CAAa,SAAS,+BAC7CA,UAAAA,CAAU,GAAA,CAAI,eAAe,CAAC,CAAA,OAAA;AAAA,KAC7D;AAAA,EACF;AAGA,EAAA,IAAI,IAAI,aAAA,EAAe;AACrB,IAAA,MAAM,IAAI,GAAA,CAAI,MAAA,CAAO,GAAA,CAAI,MAAA,CAAO,SAAS,CAAC,CAAA;AAC1C,IAAA,MAAM,OAAO,GAAA,CAAI,MAAA,CAAO,GAAA,CAAI,MAAA,CAAO,SAAS,CAAC,CAAA;AAC7C,IAAA,MAAM,MAAA,GAAS,iBAAA,CAAkB,CAAA,EAAG,IAAI,CAAA;AACxC,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,SAAA,EAAY,EAAE,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA,KAAA,EAAQ,CAAA,CAAE,IAAI,MAAA,CAAO,CAAC,qCAClC,UAAA,CAAW,SAAS,kBAAkB,YAAA,CAAa,SAAS,+BAC7CA,UAAAA,CAAU,GAAA,CAAI,aAAa,CAAC,CAAA,OAAA;AAAA,KAC3D;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAGA,SAAS,SAAS,MAAA,EAAmE;AACnF,EAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG,OAAO,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC7C,EAAA,MAAM,GAAA,GAAM,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,SAAS,CAAC,CAAA;AACxC,EAAA,OAAO,OAAO,GAAG,CAAA;AACnB;AAGA,SAAS,iBAAA,CACP,MACA,EAAA,EAC0B;AAC1B,EAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAA,GAAI,IAAA,CAAK,CAAA;AACvB,EAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAA,GAAI,IAAA,CAAK,CAAA;AAEvB,EAAA,IAAI,KAAK,GAAA,CAAI,EAAE,IAAI,IAAA,CAAK,GAAA,CAAI,EAAE,CAAA,EAAG;AAE/B,IAAA,OAAO,EAAE,CAAA,EAAG,EAAA,GAAK,IAAI,EAAA,GAAK,GAAA,EAAK,GAAG,GAAA,EAAI;AAAA,EACxC;AAEA,EAAA,OAAO,EAAE,CAAA,EAAG,GAAA,EAAK,GAAG,EAAA,GAAK,CAAA,GAAI,KAAK,GAAA,EAAI;AACxC;AAMA,SAASA,WAAU,IAAA,EAAsB;AACvC,EAAA,OAAO,KACJ,OAAA,CAAQ,IAAA,EAAM,OAAO,CAAA,CACrB,OAAA,CAAQ,MAAM,MAAM,CAAA,CACpB,QAAQ,IAAA,EAAM,MAAM,EACpB,OAAA,CAAQ,IAAA,EAAM,QAAQ,CAAA,CACtB,OAAA,CAAQ,MAAM,OAAO,CAAA;AAC1B;AClUA,IAAM,EAAA,GAAK;AAAA,EACT,OAAA,EAAS,EAAA;AAAA,EACT,OAAA,EAAS,EAAA;AAAA,EACT,YAAA,EAAc,EAAA;AAAA,EACd,SAAA,EAAW,EAAA;AAAA,EACX,QAAA,EAAU,GAAA;AAAA,EACV,YAAA,EAAc,EAAA;AAAA,EAEd,WAAA,EAAa,EAAA;AAAA,EACb,YAAA,EAAc;AAChB,CAAA;AAQA,eAAsB,eAAA,CACpB,OAAA,EACA,QAAA,GAA0B,EAAC,EACG;AAC9B,EAAA,IAAI,OAAA,CAAQ,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AACjC,IAAA,OAAO,EAAE,KAAA,EAAO,CAAA,EAAG,MAAA,EAAQ,CAAA,EAAG,UAAU,EAAC,EAAG,aAAA,EAAe,EAAC,EAAE;AAAA,EAChE;AAGA,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAA+C;AAEvE,EAAA,KAAA,MAAW,MAAA,IAAU,QAAQ,QAAA,EAAU;AAErC,IAAA,MAAM,cAAc,iBAAA,CAAkB,MAAA,CAAO,OAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AAIhG,IAAA,IAAI,QAAA,GAAW,CAAA;AACf,IAAA,KAAA,MAAW,IAAA,IAAQ,OAAO,UAAA,EAAY;AACpC,MAAA,MAAM,WAAW,CAAA,EAAG,IAAA,CAAK,IAAI,CAAA,EAAA,EAAK,IAAA,CAAK,IAAI,CAAA,EAAG,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,IAAI,IAAA,GAAO,IAAA,CAAK,KAAK,IAAA,CAAK,GAAG,IAAI,EAAE,CAAA,CAAA;AACpG,MAAA,MAAM,CAAA,GAAI,qBAAA,CAAsB,QAAA,EAAU,EAAA,CAAG,YAAY,CAAA;AACzD,MAAA,IAAI,CAAA,GAAI,UAAU,QAAA,GAAW,CAAA;AAAA,IAC/B;AAEA,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,EAAA,CAAG,QAAA,EAAU,WAAA,GAAc,EAAA,CAAG,OAAA,GAAU,CAAA,EAAG,QAAA,GAAW,EAAA,CAAG,OAAA,GAAU,CAAC,CAAA;AAC3F,IAAA,MAAM,MAAA,GAAS,EAAA,CAAG,YAAA,GAAe,IAAA,CAAK,GAAA,CAAI,OAAO,UAAA,CAAW,MAAA,EAAQ,CAAC,CAAA,GAAI,EAAA,CAAG,SAAA;AAE5E,IAAA,WAAA,CAAY,IAAI,MAAA,CAAO,EAAA,EAAI,EAAE,KAAA,EAAO,QAAQ,CAAA;AAAA,EAC9C;AAGA,EAAA,MAAM,CAAA,GAAI,IAAIL,sBAAAA,CAAM,QAAA,CAAS,MAAM,EAAE,QAAA,EAAU,MAAM,CAAA;AACrD,EAAA,CAAA,CAAE,QAAA,CAAS;AAAA,IACT,OAAA,EAAS,IAAA;AAAA,IACT,SAAA,EAAW,QAAA;AAAA;AAAA,IACX,SAAS,EAAA,CAAG,WAAA;AAAA,IACZ,SAAS,EAAA,CAAG,YAAA;AAAA,IACZ,SAAS,EAAA,CAAG,OAAA;AAAA,IACZ,SAAS,EAAA,CAAG;AAAA,GACb,CAAA;AACD,EAAA,CAAA,CAAE,mBAAA,CAAoB,OAAO,EAAC,CAAE,CAAA;AAEhC,EAAA,KAAA,MAAW,MAAA,IAAU,QAAQ,QAAA,EAAU;AACrC,IAAA,MAAM,IAAA,GAAO,WAAA,CAAY,GAAA,CAAI,MAAA,CAAO,EAAE,CAAA;AACtC,IAAA,CAAA,CAAE,OAAA,CAAQ,MAAA,CAAO,EAAA,EAAI,EAAE,KAAA,EAAO,KAAK,KAAA,EAAO,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ,CAAA;AAAA,EACjE;AAEA,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,aAAA,CAAc,QAAQ,CAAA,EAAA,EAAK;AACrD,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,aAAA,CAAc,CAAC,CAAA;AACnC,IAAA,CAAA,CAAE,OAAA,CAAQ,GAAA,CAAI,OAAA,EAAS,GAAA,CAAI,OAAA,EAAS;AAAA,MAClC,MAAA,EAAQ,CAAA;AAAA,MACR,OAAO,GAAA,CAAI,KAAA;AAAA,MACX,KAAA,EAAO,kBAAkB,GAAA,CAAI,KAAA,EAAO,WAAW,SAAA,EAAW,YAAA,CAAa,SAAS,CAAA,GAAI,CAAA;AAAA,MACpF,MAAA,EAAQ,WAAW,SAAA,GAAY,CAAA;AAAA,MAC/B,QAAA,EAAU;AAAA,KACX,CAAA;AAAA,EACH;AAIA,EAAA,IAAI;AACF,IAAAA,sBAAAA,CAAM,OAAO,CAAC,CAAA;AAAA,EAChB,SAAS,GAAA,EAAK;AACZ,IAAA,MAAM,UAAU,GAAA,YAAe,KAAA,GAAQ,GAAA,CAAI,OAAA,GAAU,OAAO,GAAG,CAAA;AAC/D,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kCAAA,EAAqC,OAAO,CAAA,CAAE,CAAA;AAAA,EAChE;AAGA,EAAA,MAAM,YAAA,uBAAmB,GAAA,EAAsB;AAC/C,EAAA,KAAA,MAAW,UAAU,OAAA,CAAQ,QAAA,eAAuB,GAAA,CAAI,MAAA,CAAO,IAAI,MAAM,CAAA;AAEzE,EAAA,MAAM,kBAAA,GAA2C,OAAA,CAAQ,QAAA,CAAS,GAAA,CAAI,CAAA,MAAA,KAAU;AAC9E,IAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,MAAA,CAAO,EAAE,CAAA;AAClC,IAAA,MAAM,OAAA,GAAU,gBAAgB,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA,EAAG,SAAA,CAAU,KAAA,EAAO,SAAA,CAAU,MAAM,CAAA;AAC3F,IAAA,OAAO;AAAA,MACL,IAAI,MAAA,CAAO,EAAA;AAAA,MACX,OAAO,MAAA,CAAO,KAAA;AAAA,MACd,YAAY,MAAA,CAAO,UAAA;AAAA,MACnB,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,GAAG,OAAA,CAAQ,CAAA;AAAA,MACX,OAAO,SAAA,CAAU,KAAA,IAAS,YAAY,GAAA,CAAI,MAAA,CAAO,EAAE,CAAA,CAAG,KAAA;AAAA,MACtD,QAAQ,SAAA,CAAU,MAAA,IAAU,YAAY,GAAA,CAAI,MAAA,CAAO,EAAE,CAAA,CAAG,MAAA;AAAA,MACxD,cAAc,EAAA,CAAG,YAAA;AAAA,MACjB,WAAW,EAAA,CAAG;AAAA,KAChB;AAAA,EACF,CAAC,CAAA;AAGD,EAAA,MAAM,aAAA,GAA4C,CAAA,CAAE,KAAA,EAAM,CAAE,IAAI,CAAA,OAAA,KAAW;AACzE,IAAA,MAAM,SAAA,GAAY,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;AAChC,IAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,aAAA,CAAc,SAAA,CAAU,MAAgB,CAAA;AAC5D,IAAA,MAAM,SAAA,GAAY,SAAA,CAAU,MAAA,IAAU,EAAC;AAEvC,IAAA,MAAM,WAAA,GAAc,gBAAA,CAAiB,SAAA,EAAW,KAAK,CAAA;AAMrD,IAAA,MAAM,OAAA,GAAU,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAChC,IAAA,MAAM,OAAA,GAAU,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA;AAChC,IAAA,MAAM,MAAA,GAAS,oBAAA;AAAA,MACb,WAAA;AAAA,MACA,UAAU,EAAE,EAAA,EAAI,OAAA,CAAQ,CAAA,EAAG,IAAI,OAAA,CAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,QAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,MAAA,GAAS,GAAE,GAAI,IAAA;AAAA,MAC5F,UAAU,EAAE,EAAA,EAAI,OAAA,CAAQ,CAAA,EAAG,IAAI,OAAA,CAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,QAAQ,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,MAAA,GAAS,GAAE,GAAI;AAAA,KAC9F;AAEA,IAAA,OAAO;AAAA,MACL,SAAS,GAAA,CAAI,OAAA;AAAA,MACb,SAAS,GAAA,CAAI,OAAA;AAAA,MACb,cAAc,GAAA,CAAI,YAAA;AAAA,MAClB,cAAc,GAAA,CAAI,YAAA;AAAA,MAClB,OAAO,GAAA,CAAI,KAAA;AAAA,MACX,aAAa,GAAA,CAAI,WAAA;AAAA,MACjB;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,CAAA,CAAE,KAAA,EAAM,CAAE,KAAA,IAAS,GAAA;AAAA,IAC1B,MAAA,EAAQ,CAAA,CAAE,KAAA,EAAM,CAAE,MAAA,IAAU,GAAA;AAAA,IAC5B,QAAA,EAAU,kBAAA;AAAA,IACV;AAAA,GACF;AACF;;;AC/IA,IAAM,OAAA,GAAU;AAAA,EACd,QAAA,EAAU,EAAA;AAAA,EACV,UAAA,EAAY,GAAA;AAAA,EACZ,OAAA,EAAS,CAAA;AAAA,EACT,SAAA,EAAW;AACb,CAAA;AAQO,SAAS,YACd,OAAA,EACA,MAAA,EACA,IAAA,GAAe,OAAA,EACf,cAAuB,KAAA,EACf;AACR,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA,CAAK,WAAW,OAAA,CAAQ,KAAA,EAAO,QAAQ,MAAA,EAAQ,MAAA,EAAQ,WAAW,CAAC,CAAA;AACzE,EAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,IAAI,CAAC,CAAA;AACtC,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,EAAA,KAAA,CAAM,KAAK,SAAS,CAAA;AAGpB,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,KAAA,CAAM,IAAA,CAAK,sBAAA,CAAuB,GAAG,CAAC,CAAA;AAAA,EACxC;AAGA,EAAA,KAAA,MAAW,MAAA,IAAU,QAAQ,QAAA,EAAU;AACrC,IAAA,KAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,MAAM,CAAC,CAAA;AAAA,EACpC;AAGA,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,KAAA,CAAM,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAC,CAAA;AAAA,EACnC;AAGA,EAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,aAAA,EAAe;AACvC,IAAA,KAAA,CAAM,IAAA,CAAK,uBAAA,CAAwB,GAAG,CAAC,CAAA;AAAA,EACzC;AAEA,EAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAOA,SAAS,gBAAgB,MAAA,EAAoC;AAC3D,EAAA,MAAM,EAAE,GAAG,CAAA,EAAG,KAAA,EAAO,QAAQ,YAAA,EAAc,SAAA,EAAW,KAAA,EAAO,UAAA,EAAW,GAAI,MAAA;AAC5E,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,KAAK,CAAA,UAAA,EAAa,MAAM,CAAA,oFAAA,EAC2B,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GAC7G;AAGA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,SAAA,EAAY,CAAC,CAAA,KAAA,EAAQ,CAAC,CAAA,SAAA,EAAY,KAAK,CAAA,UAAA,EAAa,YAAY,CAAA,oFAAA,EACqB,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GAC7G;AAGA,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,YAAY,CAAA,GAAI,KAAA,GAAQ,CAAC,CAAA,KAAA,EAAQ,IAAI,YAAA,GAAe,CAAC,CAAA,2BAAA,EAA8B,mBAAmB,gBACxF,UAAA,CAAW,SAAS,CAAA,wCAAA,EAA2CK,UAAAA,CAAU,KAAK,CAAC,CAAA,OAAA;AAAA,GAC/F;AAGA,EAAA,MAAM,UAAU,CAAA,GAAI,YAAA;AACpB,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,CAAA,UAAA,EAAa,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,MAAA,EAAS,CAAA,GAAI,KAAK,CAAA,MAAA,EAAS,OAAO,CAAA,6CAAA,EAClB,aAAA,CAAc,QAAQ,CAAA,IAAA;AAAA,GACtE;AAGA,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,IAAA,MAAM,IAAA,GAAO,WAAW,CAAC,CAAA;AACzB,IAAA,MAAM,IAAA,GAAO,OAAA,GAAU,CAAA,GAAI,SAAA,GAAY,SAAA,GAAY,CAAA;AACnD,IAAA,KAAA,CAAM,KAAK,eAAA,CAAgB,IAAA,EAAM,CAAA,EAAG,IAAA,EAAM,KAAK,CAAC,CAAA;AAAA,EAClD;AAGA,EAAA,IAAI,UAAA,CAAW,WAAW,CAAA,EAAG;AAC3B,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,SAAA,EAAY,CAAA,GAAI,KAAA,GAAQ,CAAC,CAAA,KAAA,EAAQ,OAAA,GAAU,SAAA,GAAY,CAAC,CAAA,2BAAA,EAA8B,mBAAmB,CAAA,aAAA,EAC3F,OAAA,CAAQ,QAAQ,CAAA,sEAAA;AAAA,KAChC;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AASA,SAAS,eAAA,CAAgB,IAAA,EAAmB,IAAA,EAAc,CAAA,EAAW,QAAA,EAA0B;AAC7F,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,IAAI,QAAA,GAAW,CAAA;AACf,EAAA,IAAI,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG;AACxB,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,GAAG,CAAA;AAClC,IAAA,QAAA,GAAW,kBAAkB,OAAA,EAAS,OAAA,CAAQ,OAAA,EAAS,OAAA,CAAQ,SAAS,CAAA,GAAI,CAAA;AAC5E,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,YAAY,IAAA,GAAO,CAAC,QAAQ,CAAA,GAAI,CAAC,YAAY,QAAQ,CAAA,uDAAA;AAAA,KAEvD;AACA,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,SAAA,EAAY,OAAO,CAAA,GAAI,QAAA,GAAW,CAAC,CAAA,KAAA,EAAQ,CAAC,8BAA8B,mBAAmB,CAAA,aAAA,EAC/E,QAAQ,OAAO,CAAA,eAAA,EAAkB,QAAQ,SAAS,CAAA,0BAAA,EAA6B,KAAK,IAAA,CAAK,IAAA,CAAK,GAAG,CAAC,CAAA,OAAA;AAAA,KAClH;AAAA,EACF;AAGA,EAAA,MAAM,QAAQ,IAAA,GAAO,CAAA,IAAK,QAAA,GAAW,CAAA,GAAI,WAAW,CAAA,GAAI,CAAA,CAAA;AACxD,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,YAAY,KAAK,CAAA,KAAA,EAAQ,CAAC,CAAA,mBAAA,EAAsB,mBAAmB,CAAA,aAAA,EACrD,OAAA,CAAQ,QAAQ,CAAA,eAAA,EAAkB,QAAQ,UAAU,CAAA,mCAAA,EAC9BA,UAAAA,CAAU,IAAA,CAAK,IAAI,CAAC,CAAA,eAAA;AAAA,GAC1D;AAGA,EAAA,MAAM,KAAA,GAAQ,OAAO,QAAA,GAAW,CAAA;AAChC,EAAA,KAAA,CAAM,IAAA;AAAA,IACJ,YAAY,KAAK,CAAA,KAAA,EAAQ,CAAC,CAAA,qCAAA,EAAwC,mBAAmB,CAAA,aAAA,EACvE,OAAA,CAAQ,QAAQ,CAAA,eAAA,EAAkB,QAAQ,UAAU,CAAA,iCAAA,EAChCA,UAAAA,CAAU,IAAA,CAAK,IAAI,CAAC,CAAA,eAAA;AAAA,GACxD;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAOA,SAAS,uBAAuB,GAAA,EAAuC;AACrE,EAAA,IAAI,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,EAAA;AAElC,EAAA,MAAM,QAAA,GAAW,GAAA,CAAI,MAAA,CAAO,GAAA,CAAI,OAAK,CAAA,EAAG,CAAA,CAAE,CAAC,CAAA,CAAA,EAAI,CAAA,CAAE,CAAC,CAAA,CAAE,CAAA,CAAE,KAAK,GAAG,CAAA;AAC9D,EAAA,MAAM,SAAA,GAAY,CAAC,GAAA,CAAI,WAAA,GAAc,yBAAA,GAA4B,EAAA;AAEjE,EAAA,OACE,qBAAqB,QAAQ,CAAA,kDAAA,EACZ,aAAA,CAAc,SAAS,IAAI,SAAS,CAAA,GAAA,CAAA;AAEzD;AAGA,SAAS,wBAAwB,GAAA,EAAuC;AACtE,EAAA,IAAI,CAAC,GAAA,CAAI,KAAA,IAAS,IAAI,MAAA,CAAO,MAAA,GAAS,GAAG,OAAO,EAAA;AAEhD,EAAA,MAAM,GAAA,GAAMC,SAAAA,CAAS,GAAA,CAAI,MAAM,CAAA;AAC/B,EAAA,MAAM,YAAY,iBAAA,CAAkB,GAAA,CAAI,OAAO,UAAA,CAAW,SAAA,EAAW,aAAa,SAAS,CAAA;AAG3F,EAAA,MAAM,MAAM,SAAA,GAAY,CAAA;AACxB,EAAA,MAAM,GAAA,GAAM,WAAW,SAAA,GAAY,CAAA;AAEnC,EAAA,OACE,CAAA,SAAA,EAAY,GAAA,CAAI,CAAA,GAAI,GAAA,GAAM,CAAC,CAAA,KAAA,EAAQ,GAAA,CAAI,CAAA,GAAI,GAAA,GAAM,CAAC,CAAA,SAAA,EAAY,GAAG,aAAa,GAAG,CAAA;AAAA,SAAA,EAEnE,IAAI,CAAC,CAAA,KAAA,EAAQ,GAAA,CAAI,CAAC,8BAA8B,mBAAmB,CAAA,aAAA,EACnE,UAAA,CAAW,SAAS,kBAAkB,YAAA,CAAa,SAAS,+BAA+BD,UAAAA,CAAU,GAAA,CAAI,KAAK,CAAC,CAAA,OAAA,CAAA;AAEjI;AAWA,SAAS,kBAAkB,GAAA,EAAuC;AAChE,EAAA,IAAI,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,OAAO,EAAA;AAClC,EAAA,MAAM,QAAkB,EAAC;AAGzB,EAAA,MAAM,EAAA,GAAK,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA;AACvB,EAAA,MAAM,EAAA,GAAK,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA;AACvB,EAAA,KAAA,CAAM,KAAK,eAAA,CAAgB,EAAA,EAAI,EAAA,EAAI,GAAA,CAAI,YAAY,CAAC,CAAA;AAGpD,EAAA,MAAM,KAAK,GAAA,CAAI,MAAA,CAAO,GAAA,CAAI,MAAA,CAAO,SAAS,CAAC,CAAA;AAC3C,EAAA,MAAM,MAAM,GAAA,CAAI,MAAA,CAAO,GAAA,CAAI,MAAA,CAAO,SAAS,CAAC,CAAA;AAC5C,EAAA,KAAA,CAAM,KAAK,eAAA,CAAgB,EAAA,EAAI,GAAA,EAAK,GAAA,CAAI,YAAY,CAAC,CAAA;AAErD,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAMA,SAAS,eAAA,CACP,KAAA,EACA,MAAA,EACA,WAAA,EACQ;AACR,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,EAAA,GAAK,cAAc,SAAA,GAAY,IAAA;AAGrC,EAAA,MAAM,EAAA,GAAK,KAAA,CAAM,CAAA,GAAI,MAAA,CAAO,CAAA;AAC5B,EAAA,MAAM,EAAA,GAAK,KAAA,CAAM,CAAA,GAAI,MAAA,CAAO,CAAA;AAC5B,EAAA,MAAM,MAAM,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,EAAA,GAAK,KAAK,EAAE,CAAA;AACvC,EAAA,IAAI,GAAA,KAAQ,GAAG,OAAO,EAAA;AACtB,EAAA,MAAM,KAAK,EAAA,GAAK,GAAA;AAChB,EAAA,MAAM,KAAK,EAAA,GAAK,GAAA;AAGhB,EAAA,MAAM,KAAK,CAAC,EAAA;AACZ,EAAA,MAAM,EAAA,GAAK,EAAA;AAGX,EAAA,MAAM,IAAA,GAAO,KAAA,CAAM,CAAA,GAAI,EAAA,GAAK,CAAA;AAC5B,EAAA,MAAM,IAAA,GAAO,KAAA,CAAM,CAAA,GAAI,EAAA,GAAK,CAAA;AAC5B,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,CAAA,GAAI,EAAA,GAAK,EAAA;AAC7B,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,CAAA,GAAI,EAAA,GAAK,EAAA;AAG7B,EAAA,MAAM,UAAA,GAAa,WAAA,KAAgB,KAAA,IAAS,WAAA,KAAgB,UAAA;AAC5D,EAAA,MAAM,YAAA,GAAe,WAAA,KAAgB,MAAA,IAAU,WAAA,KAAgB,WAAA;AAC/D,EAAA,MAAM,SAAA,GAAY,WAAA,KAAgB,UAAA,IAAc,WAAA,KAAgB,WAAA;AAGhE,EAAA,IAAI,UAAA,EAAY;AACd,IAAA,MAAM,KAAA,GAAQ,CAAA;AACd,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,aAAa,IAAA,GAAO,EAAA,GAAK,KAAK,CAAA,MAAA,EAAS,OAAO,EAAA,GAAK,KAAK,CAAA,MAAA,EACjD,IAAA,GAAO,KAAK,KAAK,CAAA,MAAA,EAAS,OAAO,EAAA,GAAK,KAAK,yCACX,EAAE,CAAA,IAAA;AAAA,KAC3C;AAEA,IAAA,MAAM,MAAA,GAAS,OAAO,EAAA,GAAK,CAAA;AAC3B,IAAA,MAAM,MAAA,GAAS,OAAO,EAAA,GAAK,CAAA;AAC3B,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,aAAa,MAAA,GAAS,EAAA,GAAK,KAAK,CAAA,MAAA,EAAS,SAAS,EAAA,GAAK,KAAK,CAAA,MAAA,EACrD,MAAA,GAAS,KAAK,KAAK,CAAA,MAAA,EAAS,SAAS,EAAA,GAAK,KAAK,yCACf,EAAE,CAAA,IAAA;AAAA,KAC3C;AAAA,EACF;AAGA,EAAA,IAAI,YAAA,EAAc;AAChB,IAAA,MAAM,IAAA,GAAO,CAAA;AAEb,IAAA,MAAM,MAAA,GAAS,IAAA;AACf,IAAA,MAAM,MAAA,GAAS,IAAA;AAEf,IAAA,KAAA,CAAM,IAAA;AAAA;AAAA,MAEJ,CAAA,UAAA,EAAa,MAAA,GAAS,EAAA,GAAK,IAAI,CAAA,MAAA,EAAS,MAAA,GAAS,EAAA,GAAK,IAAI,CAAA,MAAA,EACnD,KAAK,CAAA,MAAA,EAAS,KAAK,yCACa,EAAE,CAAA,IAAA;AAAA,KAC3C;AACA,IAAA,KAAA,CAAM,IAAA;AAAA;AAAA,MAEJ,CAAA,UAAA,EAAa,MAAM,CAAA,MAAA,EAAS,MAAM,SAC3B,KAAK,CAAA,MAAA,EAAS,KAAK,CAAA,sCAAA,EACa,EAAE,CAAA,IAAA;AAAA,KAC3C;AACA,IAAA,KAAA,CAAM,IAAA;AAAA;AAAA,MAEJ,CAAA,UAAA,EAAa,MAAA,GAAS,EAAA,GAAK,IAAI,CAAA,MAAA,EAAS,MAAA,GAAS,EAAA,GAAK,IAAI,CAAA,MAAA,EACnD,KAAK,CAAA,MAAA,EAAS,KAAK,yCACa,EAAE,CAAA,IAAA;AAAA,KAC3C;AAAA,EACF;AAGA,EAAA,IAAI,SAAA,EAAW;AACb,IAAA,MAAM,YAAA,GAAe,eAAe,EAAA,GAAK,EAAA;AACzC,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,CAAA,GAAI,EAAA,GAAK,YAAA;AAC/B,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,CAAA,GAAI,EAAA,GAAK,YAAA;AAC/B,IAAA,KAAA,CAAM,IAAA;AAAA,MACJ,CAAA,YAAA,EAAe,OAAO,CAAA,MAAA,EAAS,OAAO,gEACkB,EAAE,CAAA,IAAA;AAAA,KAC5D;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAMA,SAASC,UAAS,MAAA,EAAmE;AACnF,EAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG,OAAO,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAC7C,EAAA,IAAI,MAAA,CAAO,MAAA,KAAW,CAAA,EAAG,OAAO,OAAO,CAAC,CAAA;AAGxC,EAAA,IAAI,QAAA,GAAW,CAAA;AACf,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,IAAA,MAAM,EAAA,GAAK,OAAO,CAAC,CAAA,CAAG,IAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,CAAA;AACzC,IAAA,MAAM,EAAA,GAAK,OAAO,CAAC,CAAA,CAAG,IAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,CAAA;AACzC,IAAA,QAAA,IAAY,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,EAAA,GAAK,KAAK,EAAE,CAAA;AAAA,EACzC;AAEA,EAAA,IAAI,QAAA,KAAa,CAAA,EAAG,OAAO,MAAA,CAAO,CAAC,CAAA;AAGnC,EAAA,MAAM,UAAU,QAAA,GAAW,CAAA;AAC3B,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,IAAA,MAAM,EAAA,GAAK,OAAO,CAAC,CAAA,CAAG,IAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,CAAA;AACzC,IAAA,MAAM,EAAA,GAAK,OAAO,CAAC,CAAA,CAAG,IAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,CAAA;AACzC,IAAA,MAAM,SAAS,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,EAAA,GAAK,KAAK,EAAE,CAAA;AAC1C,IAAA,IAAI,MAAA,GAAS,UAAU,OAAA,EAAS;AAC9B,MAAA,MAAM,CAAA,GAAI,MAAA,GAAS,CAAA,GAAA,CAAK,OAAA,GAAU,UAAU,MAAA,GAAS,CAAA;AACrD,MAAA,OAAO;AAAA,QACL,GAAG,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,IAAI,EAAA,GAAK,CAAA;AAAA,QAC3B,GAAG,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,CAAG,IAAI,EAAA,GAAK;AAAA,OAC7B;AAAA,IACF;AACA,IAAA,MAAA,IAAU,MAAA;AAAA,EACZ;AAEA,EAAA,OAAO,MAAA,CAAO,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA;AACjC;AAMA,SAASD,WAAU,IAAA,EAAsB;AACvC,EAAA,OAAO,KACJ,OAAA,CAAQ,IAAA,EAAM,OAAO,CAAA,CACrB,OAAA,CAAQ,MAAM,MAAM,CAAA,CACpB,QAAQ,IAAA,EAAM,MAAM,EACpB,OAAA,CAAQ,IAAA,EAAM,QAAQ,CAAA,CACtB,OAAA,CAAQ,MAAM,OAAO,CAAA;AAC1B;;;AChUA,SAASE,mBAAkB,IAAA,EAAyD;AAClF,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,IAAA,EAAK,CAAE,KAAA,CAAM,IAAI,CAAA,CAAE,CAAC,CAAA,EAAG,IAAA,EAAK,CAAE,WAAA,EAAY,IAAK,EAAA;AAEtE,EAAA,IAAI,sBAAA,CAAuB,IAAA,CAAK,SAAS,CAAA,EAAG,OAAO,UAAA;AACnD,EAAA,IAAI,mBAAA,CAAoB,IAAA,CAAK,SAAS,CAAA,EAAG,OAAO,OAAA;AAChD,EAAA,IAAI,gBAAA,CAAiB,IAAA,CAAK,SAAS,CAAA,EAAG,OAAO,IAAA;AAG7C,EAAA,OAAO,WAAA;AACT;AAOA,SAAS,YAAY,OAAA,EAAuC;AAC1D,EAAA,OAAO;AAAA,IACL,EAAA,EAAI,OAAA,CAAQ,EAAA,IAAM,QAAA,CAAS,EAAA;AAAA,IAC3B,EAAA,EAAI,OAAA,CAAQ,EAAA,IAAM,QAAA,CAAS,EAAA;AAAA,IAC3B,MAAM,OAAA,CAAQ,IAAA;AAAA,IACd,QAAQ,OAAA,CAAQ,MAAA;AAAA,IAChB,OAAO,OAAA,CAAQ,KAAA;AAAA,IACf,SAAS,OAAA,CAAQ,OAAA;AAAA,IACjB,QAAQ,OAAA,CAAQ;AAAA,GAClB;AACF;AAkCA,eAAsB,aAAA,CACpB,IAAA,EACA,OAAA,GAAyB,EAAC,EACT;AACjB,EAAA,MAAM,MAAA,GAAS,YAAY,OAAO,CAAA;AAClC,EAAA,MAAM,IAAA,GAAO,QAAQ,IAAA,IAAQ,OAAA;AAC7B,EAAA,MAAM,WAAA,GAAc,QAAQ,WAAA,IAAe,KAAA;AAC3C,EAAA,MAAM,WAAA,GAAcA,mBAAkB,IAAI,CAAA;AAG1C,EAAA,MAAM,KAAA,GAAQ,KAAK,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAA,EAAM,EAAE,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,MAAA,GAAS,CAAA,IAAK,CAAC,CAAA,CAAE,UAAA,CAAW,IAAI,CAAC,CAAA;AAEjG,EAAA,QAAQ,WAAA;AAAa,IACnB,KAAK,UAAA,EAAY;AACf,MAAA,MAAM,OAAA,GAAU,qBAAqB,KAAK,CAAA;AAC1C,MAAA,MAAM,UAAA,GAAa,qBAAA,CAAsB,OAAA,EAAS,OAAO,CAAA;AACzD,MAAA,OAAO,iBAAA,CAAkB,UAAA,EAAY,MAAA,EAAQ,IAAA,EAAM,WAAW,CAAA;AAAA,IAChE;AAAA,IACA,KAAK,OAAA,EAAS;AACZ,MAAA,MAAM,OAAA,GAAU,kBAAkB,KAAK,CAAA;AACvC,MAAA,MAAM,UAAA,GAAa,MAAM,kBAAA,CAAmB,OAAA,EAAS,OAAO,CAAA;AAC5D,MAAA,OAAO,cAAA,CAAe,UAAA,EAAY,MAAA,EAAQ,IAAA,EAAM,WAAW,CAAA;AAAA,IAC7D;AAAA,IACA,KAAK,IAAA,EAAM;AACT,MAAA,MAAM,OAAA,GAAU,eAAe,KAAK,CAAA;AACpC,MAAA,MAAM,UAAA,GAAa,MAAM,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAA;AACzD,MAAA,OAAO,WAAA,CAAY,UAAA,EAAY,MAAA,EAAQ,IAAA,EAAM,WAAW,CAAA;AAAA,IAC1D;AAAA,IACA,KAAK,WAAA;AAAA,IACL,SAAS;AAEP,MAAA,MAAM,KAAA,GAAQ,aAAa,IAAI,CAAA;AAC/B,MAAA,MAAM,UAAA,GAAa,MAAM,WAAA,CAAY,KAAA,EAAO,OAAO,CAAA;AACnD,MAAA,OAAO,SAAA,CAAU,UAAA,EAAY,MAAA,EAAQ,IAAA,EAAM,WAAW,CAAA;AAAA,IACxD;AAAA;AAEJ","file":"index.cjs","sourcesContent":["// ============================================================================\n// Theme system  CSS custom property-based theming for mermaid SVG diagrams.\n//\n// Architecture:\n//   - Two required variables: --bg (background) and --fg (foreground)\n//   - Five optional enrichment variables: --line, --accent, --muted, --surface, --border\n//   - Unset optionals fall back to color-mix() derivations from bg + fg\n//   - All derived values computed in a <style> block inside the SVG\n//\n// This means the SVG is a function of its CSS variables. The caller provides\n// colors, and the SVG adapts. No light/dark mode detection needed.\n// ============================================================================\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Diagram color configuration.\n *\n * Required: bg + fg give you a clean mono diagram.\n * Optional: line, accent, muted, surface, border bring in richer color\n * from Shiki themes or custom palettes. Each falls back to a color-mix()\n * derivation from bg + fg if not set.\n */\nexport interface DiagramColors {\n  /** Background color  CSS variable --bg */\n  bg: string\n  /** Foreground / primary text color  CSS variable --fg */\n  fg: string\n\n  // -- Optional enrichment (each falls back to color-mix from bg+fg) --\n\n  /** Edge/connector color  CSS variable --line */\n  line?: string\n  /** Arrow heads, highlights, special nodes  CSS variable --accent */\n  accent?: string\n  /** Secondary text, edge labels  CSS variable --muted */\n  muted?: string\n  /** Node/box fill tint  CSS variable --surface */\n  surface?: string\n  /** Node/group stroke color  CSS variable --border */\n  border?: string\n}\n\n// ============================================================================\n// Defaults\n// ============================================================================\n\n/** Default bg/fg when no colors are provided (zinc light) */\nexport const DEFAULTS: Readonly<{ bg: string; fg: string }> = {\n  bg: '#FFFFFF',\n  fg: '#27272A',\n} as const\n\n// ============================================================================\n// color-mix() weights for derived CSS variables\n//\n// When an optional enrichment variable is NOT set, we compute the derived\n// value by mixing --fg into --bg at these percentages. This produces a\n// coherent mono hierarchy on any bg/fg combination.\n// ============================================================================\n\nexport const MIX = {\n  /** Primary text: near-full fg */\n  text:         100, // just use --fg directly\n  /** Secondary text (group headers): fg mixed at 60% */\n  textSec:      60,\n  /** Muted text (edge labels, notes): fg mixed at 40% */\n  textMuted:    40,\n  /** Faint text (de-emphasized): fg mixed at 25% */\n  textFaint:    25,\n  /** Edge/connector lines: fg mixed at 30% */\n  line:         30,\n  /** Arrow head fill: fg mixed at 50% */\n  arrow:        50,\n  /** Node fill tint: fg mixed at 3% */\n  nodeFill:     3,\n  /** Node/group stroke: fg mixed at 20% */\n  nodeStroke:   20,\n  /** Group header band tint: fg mixed at 5% */\n  groupHeader:  5,\n  /** Inner divider strokes: fg mixed at 12% */\n  innerStroke:  12,\n  /** Key badge background opacity (ER diagrams) */\n  keyBadge:     10,\n} as const\n\n// ============================================================================\n// Well-known theme palettes\n//\n// Curated bg/fg pairs (+ optional enrichment) for popular editor themes.\n// Users can also extract from Shiki theme objects via fromShikiTheme().\n// ============================================================================\n\nexport const THEMES: Record<string, DiagramColors> = {\n  'zinc-dark': {\n    bg: '#18181B', fg: '#FAFAFA',\n  },\n  'tokyo-night': {\n    bg: '#1a1b26', fg: '#a9b1d6',\n    line: '#3d59a1', accent: '#7aa2f7', muted: '#565f89',\n  },\n  'tokyo-night-storm': {\n    bg: '#24283b', fg: '#a9b1d6',\n    line: '#3d59a1', accent: '#7aa2f7', muted: '#565f89',\n  },\n  'tokyo-night-light': {\n    bg: '#d5d6db', fg: '#343b58',\n    line: '#34548a', accent: '#34548a', muted: '#9699a3',\n  },\n  'catppuccin-mocha': {\n    bg: '#1e1e2e', fg: '#cdd6f4',\n    line: '#585b70', accent: '#cba6f7', muted: '#6c7086',\n  },\n  'catppuccin-latte': {\n    bg: '#eff1f5', fg: '#4c4f69',\n    line: '#9ca0b0', accent: '#8839ef', muted: '#9ca0b0',\n  },\n  'nord': {\n    bg: '#2e3440', fg: '#d8dee9',\n    line: '#4c566a', accent: '#88c0d0', muted: '#616e88',\n  },\n  'nord-light': {\n    bg: '#eceff4', fg: '#2e3440',\n    line: '#aab1c0', accent: '#5e81ac', muted: '#7b88a1',\n  },\n  'dracula': {\n    bg: '#282a36', fg: '#f8f8f2',\n    line: '#6272a4', accent: '#bd93f9', muted: '#6272a4',\n  },\n  'github-light': {\n    bg: '#ffffff', fg: '#1f2328',\n    line: '#d1d9e0', accent: '#0969da', muted: '#59636e',\n  },\n  'github-dark': {\n    bg: '#0d1117', fg: '#e6edf3',\n    line: '#3d444d', accent: '#4493f8', muted: '#9198a1',\n  },\n  'solarized-light': {\n    bg: '#fdf6e3', fg: '#657b83',\n    line: '#93a1a1', accent: '#268bd2', muted: '#93a1a1',\n  },\n  'solarized-dark': {\n    bg: '#002b36', fg: '#839496',\n    line: '#586e75', accent: '#268bd2', muted: '#586e75',\n  },\n  'one-dark': {\n    bg: '#282c34', fg: '#abb2bf',\n    line: '#4b5263', accent: '#c678dd', muted: '#5c6370',\n  },\n} as const\n\nexport type ThemeName = keyof typeof THEMES\n\n// ============================================================================\n// Shiki theme extraction\n//\n// Extracts DiagramColors from a Shiki ThemeRegistrationResolved object.\n// This provides native compatibility with any VS Code / TextMate theme.\n// ============================================================================\n\n/**\n * Minimal subset of Shiki's ThemeRegistrationResolved that we need.\n * We don't import from shiki to avoid a hard dependency.\n */\ninterface ShikiThemeLike {\n  type?: string\n  colors?: Record<string, string>\n  tokenColors?: Array<{\n    scope?: string | string[]\n    settings?: { foreground?: string }\n  }>\n}\n\n/**\n * Extract diagram colors from a Shiki theme object.\n * Works with any VS Code / TextMate theme loaded by Shiki.\n *\n * Maps editor UI colors to diagram roles:\n *   editor.background          bg\n *   editor.foreground          fg\n *   editorLineNumber.fg        line (optional)\n *   focusBorder / keyword      accent (optional)\n *   comment token              muted (optional)\n *   editor.selectionBackground surface (optional)\n *   editorWidget.border        border (optional)\n *\n * @example\n * ```ts\n * import { getSingletonHighlighter } from 'shiki'\n * import { fromShikiTheme } from 'beautiful-mermaid'\n *\n * const hl = await getSingletonHighlighter({ themes: ['tokyo-night'] })\n * const colors = fromShikiTheme(hl.getTheme('tokyo-night'))\n * const svg = await renderMermaid(code, colors)\n * ```\n */\nexport function fromShikiTheme(theme: ShikiThemeLike): DiagramColors {\n  const c = theme.colors ?? {}\n  const dark = theme.type === 'dark'\n\n  // Helper: find a token color by scope name\n  const tokenColor = (scope: string): string | undefined =>\n    theme.tokenColors?.find(t =>\n      Array.isArray(t.scope) ? t.scope.includes(scope) : t.scope === scope\n    )?.settings?.foreground\n\n  return {\n    bg: c['editor.background'] ?? (dark ? '#1e1e1e' : '#ffffff'),\n    fg: c['editor.foreground'] ?? (dark ? '#d4d4d4' : '#333333'),\n    line:    c['editorLineNumber.foreground'] ?? undefined,\n    accent:  c['focusBorder'] ?? tokenColor('keyword') ?? undefined,\n    muted:   tokenColor('comment') ?? c['editorLineNumber.foreground'] ?? undefined,\n    surface: c['editor.selectionBackground'] ?? undefined,\n    border:  c['editorWidget.border'] ?? undefined,\n  }\n}\n\n// ============================================================================\n// SVG style block  the CSS variable derivation system\n//\n// Generates the <style> content that maps user-facing variables (--bg, --fg,\n// --line, etc.) to internal derived variables (--_text, --_line, etc.) using\n// color-mix() fallbacks.\n// ============================================================================\n\n/**\n * Build the CSS variable derivation rules for the SVG <style> block.\n *\n * When an optional variable (--line, --accent, etc.) is set on the SVG or\n * a parent element, it's used directly. When unset, the fallback computes\n * a blended value from --fg and --bg using color-mix().\n */\nexport function buildStyleBlock(font: string, hasMonoFont: boolean): string {\n  const fontImports = [\n    `@import url('https://fonts.googleapis.com/css2?family=${encodeURIComponent(font)}:wght@400;500;600;700&amp;display=swap');`,\n    ...(hasMonoFont\n      ? [`@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&amp;display=swap');`]\n      : []),\n  ]\n\n  // Derived CSS variables: use override if set, else mix from bg+fg.\n  // The --_ prefix signals \"private/derived\"  not meant for external override.\n  const derivedVars = `\n    /* Derived from --bg and --fg (overridable via --line, --accent, etc.) */\n    --_text:          var(--fg);\n    --_text-sec:      var(--muted, color-mix(in srgb, var(--fg) ${MIX.textSec}%, var(--bg)));\n    --_text-muted:    var(--muted, color-mix(in srgb, var(--fg) ${MIX.textMuted}%, var(--bg)));\n    --_text-faint:    color-mix(in srgb, var(--fg) ${MIX.textFaint}%, var(--bg));\n    --_line:          var(--line, color-mix(in srgb, var(--fg) ${MIX.line}%, var(--bg)));\n    --_arrow:         var(--accent, color-mix(in srgb, var(--fg) ${MIX.arrow}%, var(--bg)));\n    --_node-fill:     var(--surface, color-mix(in srgb, var(--fg) ${MIX.nodeFill}%, var(--bg)));\n    --_node-stroke:   var(--border, color-mix(in srgb, var(--fg) ${MIX.nodeStroke}%, var(--bg)));\n    --_group-fill:    var(--bg);\n    --_group-hdr:     color-mix(in srgb, var(--fg) ${MIX.groupHeader}%, var(--bg));\n    --_inner-stroke:  color-mix(in srgb, var(--fg) ${MIX.innerStroke}%, var(--bg));\n    --_key-badge:     color-mix(in srgb, var(--fg) ${MIX.keyBadge}%, var(--bg));`\n\n  return [\n    '<style>',\n    `  ${fontImports.join('\\n  ')}`,\n    `  text { font-family: '${font}', system-ui, sans-serif; }`,\n    ...(hasMonoFont ? [`  .mono { font-family: 'JetBrains Mono', 'SF Mono', 'Fira Code', ui-monospace, monospace; }`] : []),\n    `  svg {${derivedVars}`,\n    `  }`,\n    '</style>',\n  ].join('\\n')\n}\n\n/**\n * Build the SVG opening tag with CSS variables set as inline styles.\n * Only includes optional variables that are actually provided  unset ones\n * will fall back to the color-mix() derivations in the <style> block.\n *\n * @param transparent - If true, omits the background style for transparent SVGs\n */\nexport function svgOpenTag(\n  width: number,\n  height: number,\n  colors: DiagramColors,\n  transparent?: boolean,\n): string {\n  // Build the style string with only the provided color variables\n  const vars = [\n    `--bg:${colors.bg}`,\n    `--fg:${colors.fg}`,\n    colors.line    ? `--line:${colors.line}` : '',\n    colors.accent  ? `--accent:${colors.accent}` : '',\n    colors.muted   ? `--muted:${colors.muted}` : '',\n    colors.surface ? `--surface:${colors.surface}` : '',\n    colors.border  ? `--border:${colors.border}` : '',\n  ].filter(Boolean).join(';')\n\n  const bgStyle = transparent ? '' : ';background:var(--bg)'\n\n  return (\n    `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\" ` +\n    `width=\"${width}\" height=\"${height}\" style=\"${vars}${bgStyle}\">`\n  )\n}\n","import type { MermaidGraph, MermaidNode, MermaidEdge, MermaidSubgraph, Direction, NodeShape, EdgeStyle } from './types.ts'\n\n// ============================================================================\n// Mermaid parser  flowcharts and state diagrams\n//\n// Supports:\n//   Flowcharts: graph TD / flowchart LR\n//   State diagrams: stateDiagram-v2\n//\n// Line-by-line regex approach  the grammar is regular enough\n// that we don't need a grammar generator or full parser combinator.\n// ============================================================================\n\n/**\n * Parse Mermaid text into a logical graph structure.\n * Auto-detects diagram type (flowchart or state diagram).\n * Throws on invalid/unsupported input.\n */\nexport function parseMermaid(text: string): MermaidGraph {\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('%%'))\n\n  if (lines.length === 0) {\n    throw new Error('Empty mermaid diagram')\n  }\n\n  // Detect diagram type from header\n  const header = lines[0]!\n\n  // State diagram: \"stateDiagram-v2\" or \"stateDiagram\"\n  if (/^stateDiagram(-v2)?\\s*$/i.test(header)) {\n    return parseStateDiagram(lines)\n  }\n\n  // Flowchart: \"graph TD\" or \"flowchart LR\"\n  return parseFlowchart(lines)\n}\n\n// ============================================================================\n// Flowchart parser\n// ============================================================================\n\nfunction parseFlowchart(lines: string[]): MermaidGraph {\n  const headerMatch = lines[0]!.match(/^(?:graph|flowchart)\\s+(TD|TB|LR|BT|RL)\\s*$/i)\n  if (!headerMatch) {\n    throw new Error(`Invalid mermaid header: \"${lines[0]}\". Expected \"graph TD\", \"flowchart LR\", \"stateDiagram-v2\", etc.`)\n  }\n\n  const direction = headerMatch[1]!.toUpperCase() as Direction\n\n  const graph: MermaidGraph = {\n    direction,\n    nodes: new Map(),\n    edges: [],\n    subgraphs: [],\n    classDefs: new Map(),\n    classAssignments: new Map(),\n    nodeStyles: new Map(),\n  }\n\n  // Subgraph stack for nested subgraphs.\n  const subgraphStack: MermaidSubgraph[] = []\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!\n\n    // --- classDef: `classDef name prop:val,prop:val` ---\n    const classDefMatch = line.match(/^classDef\\s+(\\w+)\\s+(.+)$/)\n    if (classDefMatch) {\n      const name = classDefMatch[1]!\n      const propsStr = classDefMatch[2]!\n      const props = parseStyleProps(propsStr)\n      graph.classDefs.set(name, props)\n      continue\n    }\n\n    // --- class assignment: `class A,B className` ---\n    const classAssignMatch = line.match(/^class\\s+([\\w,-]+)\\s+(\\w+)$/)\n    if (classAssignMatch) {\n      const nodeIds = classAssignMatch[1]!.split(',').map(s => s.trim())\n      const className = classAssignMatch[2]!\n      for (const id of nodeIds) {\n        graph.classAssignments.set(id, className)\n      }\n      continue\n    }\n\n    // --- style statement: `style A,B fill:#f00,stroke:#333` ---\n    const styleMatch = line.match(/^style\\s+([\\w,-]+)\\s+(.+)$/)\n    if (styleMatch) {\n      const nodeIds = styleMatch[1]!.split(',').map(s => s.trim())\n      const props = parseStyleProps(styleMatch[2]!)\n      for (const id of nodeIds) {\n        graph.nodeStyles.set(id, { ...graph.nodeStyles.get(id), ...props })\n      }\n      continue\n    }\n\n    // --- direction override inside subgraph: `direction LR` ---\n    const dirMatch = line.match(/^direction\\s+(TD|TB|LR|BT|RL)\\s*$/i)\n    if (dirMatch && subgraphStack.length > 0) {\n      subgraphStack[subgraphStack.length - 1]!.direction = dirMatch[1]!.toUpperCase() as Direction\n      continue\n    }\n\n    // --- subgraph start: `subgraph Label` or `subgraph id [Label]` ---\n    const subgraphMatch = line.match(/^subgraph\\s+(.+)$/)\n    if (subgraphMatch) {\n      const rest = subgraphMatch[1]!.trim()\n      // Check for \"subgraph id [Label]\" form\n      // ID can contain hyphens (e.g. \"us-east\"), so use [\\w-]+ not \\w+\n      const bracketMatch = rest.match(/^([\\w-]+)\\s*\\[(.+)\\]$/)\n      let id: string\n      let label: string\n      if (bracketMatch) {\n        id = bracketMatch[1]!\n        label = bracketMatch[2]!\n      } else {\n        // Use the label text as id (slugified)\n        label = rest\n        id = rest.replace(/\\s+/g, '_').replace(/[^\\w]/g, '')\n      }\n      const sg: MermaidSubgraph = { id, label, nodeIds: [], children: [] }\n      subgraphStack.push(sg)\n      continue\n    }\n\n    // --- subgraph end ---\n    if (line === 'end') {\n      const completed = subgraphStack.pop()\n      if (completed) {\n        if (subgraphStack.length > 0) {\n          subgraphStack[subgraphStack.length - 1]!.children.push(completed)\n        } else {\n          graph.subgraphs.push(completed)\n        }\n      }\n      continue\n    }\n\n    // --- Edge/node definitions ---\n    parseEdgeLine(line, graph, subgraphStack)\n  }\n\n  return graph\n}\n\n// ============================================================================\n// State diagram parser\n//\n// Supported syntax:\n//   stateDiagram-v2\n//   s1 : Description\n//   state \"Description\" as s1\n//   s1 --> s2 : label\n//   [*] --> s1            (start pseudostate)\n//   s1 --> [*]            (end pseudostate)\n//   state CompositeState {\n//     inner1 --> inner2\n//   }\n// ============================================================================\n\nfunction parseStateDiagram(lines: string[]): MermaidGraph {\n  const graph: MermaidGraph = {\n    direction: 'TD',\n    nodes: new Map(),\n    edges: [],\n    subgraphs: [],\n    classDefs: new Map(),\n    classAssignments: new Map(),\n    nodeStyles: new Map(),\n  }\n\n  // Track composite state nesting (like subgraphs)\n  const compositeStack: MermaidSubgraph[] = []\n  // Counter for unique [*] pseudostate IDs\n  let startCount = 0\n  let endCount = 0\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!\n\n    // --- direction override ---\n    const dirMatch = line.match(/^direction\\s+(TD|TB|LR|BT|RL)\\s*$/i)\n    if (dirMatch) {\n      if (compositeStack.length > 0) {\n        compositeStack[compositeStack.length - 1]!.direction = dirMatch[1]!.toUpperCase() as Direction\n      } else {\n        graph.direction = dirMatch[1]!.toUpperCase() as Direction\n      }\n      continue\n    }\n\n    // --- composite state start: `state CompositeState {` ---\n    const compositeMatch = line.match(/^state\\s+(?:\"([^\"]+)\"\\s+as\\s+)?(\\w+)\\s*\\{$/)\n    if (compositeMatch) {\n      const label = compositeMatch[1] ?? compositeMatch[2]!\n      const id = compositeMatch[2]!\n      const sg: MermaidSubgraph = { id, label, nodeIds: [], children: [] }\n      compositeStack.push(sg)\n      continue\n    }\n\n    // --- composite state end ---\n    if (line === '}') {\n      const completed = compositeStack.pop()\n      if (completed) {\n        if (compositeStack.length > 0) {\n          compositeStack[compositeStack.length - 1]!.children.push(completed)\n        } else {\n          graph.subgraphs.push(completed)\n        }\n      }\n      continue\n    }\n\n    // --- state alias: `state \"Description\" as s1` (without brace) ---\n    const stateAliasMatch = line.match(/^state\\s+\"([^\"]+)\"\\s+as\\s+(\\w+)\\s*$/)\n    if (stateAliasMatch) {\n      const label = stateAliasMatch[1]!\n      const id = stateAliasMatch[2]!\n      registerStateNode(graph, compositeStack, { id, label, shape: 'rounded' })\n      continue\n    }\n\n    // --- transition: `s1 --> s2` or `s1 --> s2 : label` or `[*] --> s1` ---\n    const transitionMatch = line.match(/^(\\[\\*\\]|[\\w-]+)\\s*(-->)\\s*(\\[\\*\\]|[\\w-]+)(?:\\s*:\\s*(.+))?$/)\n    if (transitionMatch) {\n      let sourceId = transitionMatch[1]!\n      let targetId = transitionMatch[3]!\n      const edgeLabel = transitionMatch[4]?.trim() || undefined\n\n      // Handle [*] pseudostates  each occurrence gets a unique ID\n      if (sourceId === '[*]') {\n        startCount++\n        sourceId = `_start${startCount > 1 ? startCount : ''}`\n        registerStateNode(graph, compositeStack, { id: sourceId, label: '', shape: 'state-start' })\n      } else {\n        ensureStateNode(graph, compositeStack, sourceId)\n      }\n\n      if (targetId === '[*]') {\n        endCount++\n        targetId = `_end${endCount > 1 ? endCount : ''}`\n        registerStateNode(graph, compositeStack, { id: targetId, label: '', shape: 'state-end' })\n      } else {\n        ensureStateNode(graph, compositeStack, targetId)\n      }\n\n      graph.edges.push({\n        source: sourceId,\n        target: targetId,\n        label: edgeLabel,\n        style: 'solid',\n        hasArrowStart: false,\n        hasArrowEnd: true,\n      })\n      continue\n    }\n\n    // --- state description: `s1 : Description` ---\n    const stateDescMatch = line.match(/^([\\w-]+)\\s*:\\s*(.+)$/)\n    if (stateDescMatch) {\n      const id = stateDescMatch[1]!\n      const label = stateDescMatch[2]!.trim()\n      registerStateNode(graph, compositeStack, { id, label, shape: 'rounded' })\n      continue\n    }\n  }\n\n  return graph\n}\n\n/** Register a state node and track in composite state if applicable */\nfunction registerStateNode(\n  graph: MermaidGraph,\n  compositeStack: MermaidSubgraph[],\n  node: MermaidNode\n): void {\n  const isNew = !graph.nodes.has(node.id)\n  if (isNew) {\n    graph.nodes.set(node.id, node)\n  }\n  if (compositeStack.length > 0) {\n    const current = compositeStack[compositeStack.length - 1]!\n    if (!current.nodeIds.includes(node.id)) {\n      current.nodeIds.push(node.id)\n    }\n  }\n}\n\n/** Ensure a state node exists with default rounded shape */\nfunction ensureStateNode(\n  graph: MermaidGraph,\n  compositeStack: MermaidSubgraph[],\n  id: string\n): void {\n  if (!graph.nodes.has(id)) {\n    registerStateNode(graph, compositeStack, { id, label: id, shape: 'rounded' })\n  } else {\n    // Track in composite if applicable\n    if (compositeStack.length > 0) {\n      const current = compositeStack[compositeStack.length - 1]!\n      if (!current.nodeIds.includes(id)) {\n        current.nodeIds.push(id)\n      }\n    }\n  }\n}\n\n// ============================================================================\n// Shared utilities\n// ============================================================================\n\n/** Parse \"fill:#f00,stroke:#333\" style property strings into a Record */\nfunction parseStyleProps(propsStr: string): Record<string, string> {\n  const props: Record<string, string> = {}\n  for (const pair of propsStr.split(',')) {\n    const colonIdx = pair.indexOf(':')\n    if (colonIdx > 0) {\n      const key = pair.slice(0, colonIdx).trim()\n      const val = pair.slice(colonIdx + 1).trim()\n      if (key && val) {\n        props[key] = val\n      }\n    }\n  }\n  return props\n}\n\n// ============================================================================\n// Flowchart edge line parser\n//\n// Handles chained edges like: A[Label] --> B(Label) -.-> C{Label}\n// Also handles & parallel links: A & B --> C & D\n// ============================================================================\n\n/**\n * Arrow regex  matches all arrow operators with optional labels.\n *\n * Supported operators:\n *   -->  ---       solid arrow / solid line\n *   -.-> -.-       dotted arrow / dotted line\n *   ==>  ===       thick arrow / thick line\n *   <--> <-.-> <==>  bidirectional variants\n *\n * Optional label: -->|label text|\n */\nconst ARROW_REGEX = /^(<)?(-->|-.->|==>|---|-\\.-|===)(?:\\|([^|]*)\\|)?/\n\n/**\n * Node shape patterns  ordered from most specific delimiters to least.\n * Multi-char delimiters must be tried before single-char to avoid false matches.\n */\nconst NODE_PATTERNS: Array<{ regex: RegExp; shape: NodeShape }> = [\n  // Triple delimiters (must be first)\n  { regex: /^([\\w-]+)\\(\\(\\((.+?)\\)\\)\\)/, shape: 'doublecircle' },  // A(((text)))\n\n  // Double delimiters with mixed brackets\n  { regex: /^([\\w-]+)\\(\\[(.+?)\\]\\)/,     shape: 'stadium' },       // A([text])\n  { regex: /^([\\w-]+)\\(\\((.+?)\\)\\)/,     shape: 'circle' },        // A((text))\n  { regex: /^([\\w-]+)\\[\\[(.+?)\\]\\]/,     shape: 'subroutine' },    // A[[text]]\n  { regex: /^([\\w-]+)\\[\\((.+?)\\)\\]/,     shape: 'cylinder' },      // A[(text)]\n\n  // Trapezoid variants  must come before plain [text]\n  { regex: /^([\\w-]+)\\[\\/(.+?)\\\\\\]/,     shape: 'trapezoid' },     // A[/text\\]\n  { regex: /^([\\w-]+)\\[\\\\(.+?)\\/\\]/,     shape: 'trapezoid-alt' }, // A[\\text/]\n\n  // Asymmetric flag shape\n  { regex: /^([\\w-]+)>(.+?)\\]/,          shape: 'asymmetric' },    // A>text]\n\n  // Double curly braces (hexagon)  must come before single {text}\n  { regex: /^([\\w-]+)\\{\\{(.+?)\\}\\}/,     shape: 'hexagon' },       // A{{text}}\n\n  // Single-char delimiters (last  most common, least specific)\n  { regex: /^([\\w-]+)\\[(.+?)\\]/,         shape: 'rectangle' },     // A[text]\n  { regex: /^([\\w-]+)\\((.+?)\\)/,         shape: 'rounded' },       // A(text)\n  { regex: /^([\\w-]+)\\{(.+?)\\}/,         shape: 'diamond' },       // A{text}\n]\n\n/** Regex for a bare node reference (just an ID, no shape brackets) */\nconst BARE_NODE_REGEX = /^([\\w-]+)/\n\n/** Regex for ::: class shorthand suffix  matches :::className immediately after a node */\nconst CLASS_SHORTHAND_REGEX = /^:::([\\w][\\w-]*)/\n\n/**\n * Parse a line that contains node definitions and edges.\n * Handles chaining: A --> B --> C produces edges AB and BC.\n * Handles parallel links: A & B --> C & D produces 4 edges.\n */\nfunction parseEdgeLine(\n  line: string,\n  graph: MermaidGraph,\n  subgraphStack: MermaidSubgraph[]\n): void {\n  let remaining = line.trim()\n\n  // Parse the first node group (possibly with & separators)\n  const firstGroup = consumeNodeGroup(remaining, graph, subgraphStack)\n  if (!firstGroup || firstGroup.ids.length === 0) return\n\n  remaining = firstGroup.remaining.trim()\n  let prevGroupIds = firstGroup.ids\n\n  // Parse arrow + node-group pairs until the line is exhausted\n  while (remaining.length > 0) {\n    const arrowMatch = remaining.match(ARROW_REGEX)\n    if (!arrowMatch) break\n\n    const hasArrowStart = Boolean(arrowMatch[1])\n    const arrowOp = arrowMatch[2]!\n    const edgeLabel = arrowMatch[3]?.trim() || undefined\n    remaining = remaining.slice(arrowMatch[0].length).trim()\n\n    const style = arrowStyleFromOp(arrowOp)\n    const hasArrowEnd = arrowOp.endsWith('>')\n\n    // Parse the next node group\n    const nextGroup = consumeNodeGroup(remaining, graph, subgraphStack)\n    if (!nextGroup || nextGroup.ids.length === 0) break\n\n    remaining = nextGroup.remaining.trim()\n\n    // Emit Cartesian product of edges: every source  every target\n    for (const sourceId of prevGroupIds) {\n      for (const targetId of nextGroup.ids) {\n        graph.edges.push({\n          source: sourceId,\n          target: targetId,\n          label: edgeLabel,\n          style,\n          hasArrowStart,\n          hasArrowEnd,\n        })\n      }\n    }\n\n    prevGroupIds = nextGroup.ids\n  }\n}\n\ninterface ConsumedNodeGroup {\n  ids: string[]\n  remaining: string\n}\n\n/**\n * Consume one or more nodes separated by `&`.\n * E.g. \"A & B & C --> ...\" returns ids: ['A', 'B', 'C']\n */\nfunction consumeNodeGroup(\n  text: string,\n  graph: MermaidGraph,\n  subgraphStack: MermaidSubgraph[]\n): ConsumedNodeGroup | null {\n  const first = consumeNode(text, graph, subgraphStack)\n  if (!first) return null\n\n  const ids = [first.id]\n  let remaining = first.remaining.trim()\n\n  // Check for & separators\n  while (remaining.startsWith('&')) {\n    remaining = remaining.slice(1).trim()\n    const next = consumeNode(remaining, graph, subgraphStack)\n    if (!next) break\n    ids.push(next.id)\n    remaining = next.remaining.trim()\n  }\n\n  return { ids, remaining }\n}\n\ninterface ConsumedNode {\n  id: string\n  remaining: string\n}\n\n/**\n * Try to consume a node definition from the start of `text`.\n * If the node has a shape+label (e.g. A[Text]), it's registered in the graph.\n * If it's a bare reference (e.g. A), we look it up or create a default.\n * Also handles ::: class shorthand suffix.\n */\nfunction consumeNode(\n  text: string,\n  graph: MermaidGraph,\n  subgraphStack: MermaidSubgraph[]\n): ConsumedNode | null {\n  let id: string | null = null\n  let remaining: string = text\n\n  // Try each node pattern (shape-qualified)\n  for (const { regex, shape } of NODE_PATTERNS) {\n    const match = text.match(regex)\n    if (match) {\n      id = match[1]!\n      const label = match[2]!\n      registerNode(graph, subgraphStack, { id, label, shape })\n      remaining = text.slice(match[0].length)\n      break\n    }\n  }\n\n  // Bare node reference\n  if (id === null) {\n    const bareMatch = text.match(BARE_NODE_REGEX)\n    if (bareMatch) {\n      id = bareMatch[1]!\n      if (!graph.nodes.has(id)) {\n        registerNode(graph, subgraphStack, { id, label: id, shape: 'rectangle' })\n      } else {\n        trackInSubgraph(subgraphStack, id)\n      }\n      remaining = text.slice(bareMatch[0].length)\n    }\n  }\n\n  if (id === null) return null\n\n  // Check for ::: class shorthand suffix immediately after the node\n  const classMatch = remaining.match(CLASS_SHORTHAND_REGEX)\n  if (classMatch) {\n    graph.classAssignments.set(id, classMatch[1]!)\n    remaining = remaining.slice(classMatch[0].length)\n  }\n\n  return { id, remaining }\n}\n\n/** Register a node in the graph and track it in the current subgraph */\nfunction registerNode(\n  graph: MermaidGraph,\n  subgraphStack: MermaidSubgraph[],\n  node: MermaidNode\n): void {\n  const isNew = !graph.nodes.has(node.id)\n  if (isNew) {\n    graph.nodes.set(node.id, node)\n  }\n  trackInSubgraph(subgraphStack, node.id)\n}\n\n/** Add node ID to the innermost subgraph if we're inside one */\nfunction trackInSubgraph(subgraphStack: MermaidSubgraph[], nodeId: string): void {\n  if (subgraphStack.length > 0) {\n    const current = subgraphStack[subgraphStack.length - 1]!\n    if (!current.nodeIds.includes(nodeId)) {\n      current.nodeIds.push(nodeId)\n    }\n  }\n}\n\n/** Map arrow operator string to edge style (ignoring direction) */\nfunction arrowStyleFromOp(op: string): EdgeStyle {\n  if (op === '-.->') return 'dotted'\n  if (op === '-.-') return 'dotted'\n  if (op === '==>') return 'thick'\n  if (op === '===') return 'thick'\n  // '-->'' and '---' are both solid\n  return 'solid'\n}\n","// ============================================================================\n// ASCII renderer  type definitions\n//\n// Ported from AlexanderGrooff/mermaid-ascii (Go).\n// These types model the grid-based coordinate system, 2D text canvas,\n// and graph structures used by the ASCII/Unicode renderer.\n// ============================================================================\n\n/** Logical grid coordinate  nodes occupy 3x3 blocks on this grid. */\nexport interface GridCoord {\n  x: number\n  y: number\n}\n\n/** Character-level coordinate on the 2D text canvas. */\nexport interface DrawingCoord {\n  x: number\n  y: number\n}\n\n/**\n * Direction constants model positions on a node's 3x3 grid block.\n * Each node occupies grid cells [x..x+2, y..y+2].\n * Directions are offsets into that block, used for edge attachment points.\n *\n *   (0,0) UL   (1,0) Up   (2,0) UR\n *   (0,1) Left (1,1) Mid  (2,1) Right\n *   (0,2) LL   (1,2) Down (2,2) LR\n */\nexport interface Direction {\n  readonly x: number\n  readonly y: number\n}\n\nexport const Up: Direction         = { x: 1, y: 0 }\nexport const Down: Direction       = { x: 1, y: 2 }\nexport const Left: Direction       = { x: 0, y: 1 }\nexport const Right: Direction      = { x: 2, y: 1 }\nexport const UpperRight: Direction = { x: 2, y: 0 }\nexport const UpperLeft: Direction  = { x: 0, y: 0 }\nexport const LowerRight: Direction = { x: 2, y: 2 }\nexport const LowerLeft: Direction  = { x: 0, y: 2 }\nexport const Middle: Direction     = { x: 1, y: 1 }\n\n/** All named directions for iteration. */\nexport const ALL_DIRECTIONS: readonly Direction[] = [\n  Up, Down, Left, Right, UpperRight, UpperLeft, LowerRight, LowerLeft, Middle,\n]\n\n/**\n * 2D text canvas  column-major (canvas[x][y]).\n * Each cell holds a single character (or space).\n */\nexport type Canvas = string[][]\n\n/** A node in the ASCII graph, positioned on the grid. */\nexport interface AsciiNode {\n  /** Unique identity key  the original node ID from the parser (e.g. \"A\", \"B\"). */\n  name: string\n  /** Human-readable label for rendering inside the box (e.g. \"Web Server\"). */\n  displayLabel: string\n  index: number\n  gridCoord: GridCoord | null\n  drawingCoord: DrawingCoord | null\n  drawing: Canvas | null\n  drawn: boolean\n  styleClassName: string\n  styleClass: AsciiStyleClass\n}\n\n/** Style class for colored node text (ported from Go's classDef). */\nexport interface AsciiStyleClass {\n  name: string\n  styles: Record<string, string>\n}\n\n/** An edge in the ASCII graph, with a routed path. */\nexport interface AsciiEdge {\n  from: AsciiNode\n  to: AsciiNode\n  text: string\n  path: GridCoord[]\n  labelLine: GridCoord[]\n  startDir: Direction\n  endDir: Direction\n}\n\n/** A subgraph container with bounding box for rendering. */\nexport interface AsciiSubgraph {\n  name: string\n  nodes: AsciiNode[]\n  parent: AsciiSubgraph | null\n  children: AsciiSubgraph[]\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\n/** Configuration for ASCII rendering. */\nexport interface AsciiConfig {\n  /** true = ASCII chars (+,-,|), false = Unicode box-drawing (,,). Default: false */\n  useAscii: boolean\n  /** Horizontal spacing between nodes. Default: 5 */\n  paddingX: number\n  /** Vertical spacing between nodes. Default: 5 */\n  paddingY: number\n  /** Padding inside node boxes. Default: 1 */\n  boxBorderPadding: number\n  /** Graph direction: \"LR\" or \"TD\". */\n  graphDirection: 'LR' | 'TD'\n}\n\n/** Full ASCII graph state used during layout and rendering. */\nexport interface AsciiGraph {\n  nodes: AsciiNode[]\n  edges: AsciiEdge[]\n  canvas: Canvas\n  /** Grid occupancy map  maps \"x,y\" keys to node references. */\n  grid: Map<string, AsciiNode>\n  columnWidth: Map<number, number>\n  rowHeight: Map<number, number>\n  subgraphs: AsciiSubgraph[]\n  config: AsciiConfig\n  /** Offset applied to all drawing coords to accommodate subgraph borders. */\n  offsetX: number\n  offsetY: number\n}\n\n// ============================================================================\n// Coordinate helpers\n// ============================================================================\n\nexport function gridCoordEquals(a: GridCoord, b: GridCoord): boolean {\n  return a.x === b.x && a.y === b.y\n}\n\nexport function drawingCoordEquals(a: DrawingCoord, b: DrawingCoord): boolean {\n  return a.x === b.x && a.y === b.y\n}\n\n/** Apply a direction offset to a grid coordinate (move into the 3x3 block). */\nexport function gridCoordDirection(c: GridCoord, dir: Direction): GridCoord {\n  return { x: c.x + dir.x, y: c.y + dir.y }\n}\n\n/** Key for storing GridCoord in a Map. */\nexport function gridKey(c: GridCoord): string {\n  return `${c.x},${c.y}`\n}\n\n/** Default empty style class. */\nexport const EMPTY_STYLE: AsciiStyleClass = { name: '', styles: {} }\n","// ============================================================================\n// ASCII renderer  2D text canvas\n//\n// Ported from AlexanderGrooff/mermaid-ascii cmd/draw.go.\n// The canvas is a column-major 2D array of single-character strings.\n// canvas[x][y] gives the character at column x, row y.\n// ============================================================================\n\nimport type { Canvas, DrawingCoord } from './types.ts'\n\n/**\n * Create a blank canvas filled with spaces.\n * Dimensions are inclusive: mkCanvas(3, 2) creates a 4x3 grid (indices 0..3, 0..2).\n */\nexport function mkCanvas(x: number, y: number): Canvas {\n  const canvas: Canvas = []\n  for (let i = 0; i <= x; i++) {\n    const col: string[] = []\n    for (let j = 0; j <= y; j++) {\n      col.push(' ')\n    }\n    canvas.push(col)\n  }\n  return canvas\n}\n\n/** Create a blank canvas with the same dimensions as the given canvas. */\nexport function copyCanvas(source: Canvas): Canvas {\n  const [maxX, maxY] = getCanvasSize(source)\n  return mkCanvas(maxX, maxY)\n}\n\n/** Returns [maxX, maxY]  the highest valid indices in each dimension. */\nexport function getCanvasSize(canvas: Canvas): [number, number] {\n  return [canvas.length - 1, (canvas[0]?.length ?? 1) - 1]\n}\n\n/**\n * Grow the canvas to fit at least (newX, newY), preserving existing content.\n * Mutates the canvas in place and returns it.\n */\nexport function increaseSize(canvas: Canvas, newX: number, newY: number): Canvas {\n  const [currX, currY] = getCanvasSize(canvas)\n  const targetX = Math.max(newX, currX)\n  const targetY = Math.max(newY, currY)\n  const grown = mkCanvas(targetX, targetY)\n  for (let x = 0; x < grown.length; x++) {\n    for (let y = 0; y < grown[0]!.length; y++) {\n      if (x < canvas.length && y < canvas[0]!.length) {\n        grown[x]![y] = canvas[x]![y]!\n      }\n    }\n  }\n  // Mutate in place: splice old contents and replace with grown\n  canvas.length = 0\n  canvas.push(...grown)\n  return canvas\n}\n\n// ============================================================================\n// Junction merging  Unicode box-drawing character compositing\n// ============================================================================\n\n/** All Unicode box-drawing characters that participate in junction merging. */\nconst JUNCTION_CHARS = new Set([\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n])\n\nexport function isJunctionChar(c: string): boolean {\n  return JUNCTION_CHARS.has(c)\n}\n\n/**\n * When two junction characters overlap during canvas merging,\n * resolve them to the correct combined junction.\n * E.g., '' overlapping '' becomes ''.\n */\nconst JUNCTION_MAP: Record<string, Record<string, string>> = {\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n  '': { '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' },\n}\n\nexport function mergeJunctions(c1: string, c2: string): string {\n  return JUNCTION_MAP[c1]?.[c2] ?? c1\n}\n\n// ============================================================================\n// Canvas merging  composite multiple canvases with offset\n// ============================================================================\n\n/**\n * Merge overlay canvases onto a base canvas at the given offset.\n * Non-space characters in overlays overwrite the base.\n * When both characters are Unicode junction chars, they're merged intelligently.\n */\nexport function mergeCanvases(\n  base: Canvas,\n  offset: DrawingCoord,\n  useAscii: boolean,\n  ...overlays: Canvas[]\n): Canvas {\n  let [maxX, maxY] = getCanvasSize(base)\n  for (const overlay of overlays) {\n    const [oX, oY] = getCanvasSize(overlay)\n    maxX = Math.max(maxX, oX + offset.x)\n    maxY = Math.max(maxY, oY + offset.y)\n  }\n\n  const merged = mkCanvas(maxX, maxY)\n\n  // Copy base\n  for (let x = 0; x <= maxX; x++) {\n    for (let y = 0; y <= maxY; y++) {\n      if (x < base.length && y < base[0]!.length) {\n        merged[x]![y] = base[x]![y]!\n      }\n    }\n  }\n\n  // Apply overlays\n  for (const overlay of overlays) {\n    for (let x = 0; x < overlay.length; x++) {\n      for (let y = 0; y < overlay[0]!.length; y++) {\n        const c = overlay[x]![y]!\n        if (c !== ' ') {\n          const mx = x + offset.x\n          const my = y + offset.y\n          const current = merged[mx]![my]!\n          if (!useAscii && isJunctionChar(c) && isJunctionChar(current)) {\n            merged[mx]![my] = mergeJunctions(current, c)\n          } else {\n            merged[mx]![my] = c\n          }\n        }\n      }\n    }\n  }\n\n  return merged\n}\n\n// ============================================================================\n// Canvas  string conversion\n// ============================================================================\n\n/** Convert the canvas to a multi-line string (row by row, left to right). */\nexport function canvasToString(canvas: Canvas): string {\n  const [maxX, maxY] = getCanvasSize(canvas)\n  const lines: string[] = []\n  for (let y = 0; y <= maxY; y++) {\n    let line = ''\n    for (let x = 0; x <= maxX; x++) {\n      line += canvas[x]![y]!\n    }\n    lines.push(line)\n  }\n  return lines.join('\\n')\n}\n\n// ============================================================================\n// Canvas vertical flip  used for BT (bottom-to-top) direction support.\n//\n// The ASCII renderer lays out graphs top-down (TD). For BT direction, we\n// flip the finished canvas vertically and remap directional characters so\n// arrows point upward and corners are mirrored correctly.\n// ============================================================================\n\n/**\n * Characters that change meaning when the Y-axis is flipped.\n * Symmetric characters (, , , , ) are unchanged.\n */\nconst VERTICAL_FLIP_MAP: Record<string, string> = {\n  // Unicode arrows\n  '': '', '': '',\n  '': '', '': '',\n  '': '', '': '',\n  // ASCII arrows\n  '^': 'v', 'v': '^',\n  // Unicode corners\n  '': '', '': '',\n  '': '', '': '',\n  // Unicode junctions (T-pieces flip vertically)\n  '': '', '': '',\n  // Box-start junctions (exit points from node boxes)\n  '': '', '': '',\n}\n\n/**\n * Flip the canvas vertically (mirror across the horizontal center).\n * Reverses row order within each column and remaps directional characters\n * (arrows, corners, junctions) so they point the correct way after flip.\n *\n * Used to transform a TD-rendered canvas into BT output.\n * Mutates the canvas in place and returns it.\n */\nexport function flipCanvasVertically(canvas: Canvas): Canvas {\n  // Reverse each column array (Y-axis flip in column-major layout)\n  for (const col of canvas) {\n    col.reverse()\n  }\n\n  // Remap directional characters that change meaning after vertical flip\n  for (const col of canvas) {\n    for (let y = 0; y < col.length; y++) {\n      const flipped = VERTICAL_FLIP_MAP[col[y]!]\n      if (flipped) col[y] = flipped\n    }\n  }\n\n  return canvas\n}\n\n/** Draw text string onto the canvas starting at the given coordinate. */\nexport function drawText(canvas: Canvas, start: DrawingCoord, text: string): void {\n  increaseSize(canvas, start.x + text.length, start.y)\n  for (let i = 0; i < text.length; i++) {\n    canvas[start.x + i]![start.y] = text[i]!\n  }\n}\n\n/**\n * Set the canvas size to fit all grid columns and rows.\n * Called after layout to ensure the canvas covers the full drawing area.\n */\nexport function setCanvasSizeToGrid(\n  canvas: Canvas,\n  columnWidth: Map<number, number>,\n  rowHeight: Map<number, number>,\n): void {\n  let maxX = 0\n  let maxY = 0\n  for (const w of columnWidth.values()) maxX += w\n  for (const h of rowHeight.values()) maxY += h\n  increaseSize(canvas, maxX - 1, maxY - 1)\n}\n","// ============================================================================\n// ASCII renderer  MermaidGraph  AsciiGraph converter\n//\n// Bridges the existing TypeScript parser output to the ASCII renderer's\n// internal graph structure. This avoids maintaining a separate parser\n// for ASCII rendering  we reuse parseMermaid() and convert its output.\n// ============================================================================\n\nimport type { MermaidGraph, MermaidSubgraph } from '../types.ts'\nimport type {\n  AsciiGraph, AsciiNode, AsciiEdge, AsciiSubgraph, AsciiConfig,\n} from './types.ts'\nimport { EMPTY_STYLE } from './types.ts'\nimport { mkCanvas } from './canvas.ts'\n\n/**\n * Convert a parsed MermaidGraph into an AsciiGraph ready for grid layout.\n *\n * Key mappings:\n * - MermaidGraph.nodes (Map)  ordered AsciiNode[] preserving insertion order\n * - MermaidGraph.edges  AsciiEdge[] with resolved node references\n * - MermaidGraph.subgraphs  AsciiSubgraph[] with parent/child tree\n * - Node labels are used as display names (not raw IDs)\n */\nexport function convertToAsciiGraph(parsed: MermaidGraph, config: AsciiConfig): AsciiGraph {\n  // Build node list preserving Map insertion order\n  const nodeMap = new Map<string, AsciiNode>()\n  let index = 0\n\n  for (const [id, mNode] of parsed.nodes) {\n    const asciiNode: AsciiNode = {\n      // Use the parser ID as the unique identity key to avoid collisions\n      // when multiple nodes share the same label (e.g. A[Web Server], C[Web Server]).\n      name: id,\n      // The label is used for rendering inside the box.\n      displayLabel: mNode.label,\n      index,\n      gridCoord: null,\n      drawingCoord: null,\n      drawing: null,\n      drawn: false,\n      styleClassName: '',\n      styleClass: EMPTY_STYLE,\n    }\n    nodeMap.set(id, asciiNode)\n    index++\n  }\n\n  const nodes = [...nodeMap.values()]\n\n  // Build edges with resolved node references\n  const edges: AsciiEdge[] = []\n  for (const mEdge of parsed.edges) {\n    const from = nodeMap.get(mEdge.source)\n    const to = nodeMap.get(mEdge.target)\n    if (!from || !to) continue\n\n    edges.push({\n      from,\n      to,\n      text: mEdge.label ?? '',\n      path: [],\n      labelLine: [],\n      startDir: { x: 0, y: 0 },\n      endDir: { x: 0, y: 0 },\n    })\n  }\n\n  // Convert subgraphs recursively\n  const subgraphs: AsciiSubgraph[] = []\n  for (const mSg of parsed.subgraphs) {\n    convertSubgraph(mSg, null, nodeMap, subgraphs)\n  }\n\n  // Deduplicate subgraph node membership to match Go parser behavior.\n  // In Go, a node belongs only to the subgraph where it was FIRST DEFINED.\n  // The TS parser adds referenced nodes to all subgraphs they appear in,\n  // which causes incorrect bounding boxes when nodes span subgraph boundaries.\n  deduplicateSubgraphNodes(parsed.subgraphs, subgraphs, nodeMap, parsed)\n\n  // Apply class definitions\n  for (const [nodeId, className] of parsed.classAssignments) {\n    const node = nodeMap.get(nodeId)\n    const classDef = parsed.classDefs.get(className)\n    if (node && classDef) {\n      node.styleClassName = className\n      node.styleClass = { name: className, styles: classDef }\n    }\n  }\n\n  return {\n    nodes,\n    edges,\n    canvas: mkCanvas(0, 0),\n    grid: new Map(),\n    columnWidth: new Map(),\n    rowHeight: new Map(),\n    subgraphs,\n    config,\n    offsetX: 0,\n    offsetY: 0,\n  }\n}\n\n/**\n * Recursively convert a MermaidSubgraph to AsciiSubgraph.\n * Flattens the tree into the subgraphs array while maintaining parent/child references.\n * This matches the Go implementation where all subgraphs are in a flat list\n * but linked via parent/children pointers.\n */\nfunction convertSubgraph(\n  mSg: MermaidSubgraph,\n  parent: AsciiSubgraph | null,\n  nodeMap: Map<string, AsciiNode>,\n  allSubgraphs: AsciiSubgraph[],\n): AsciiSubgraph {\n  const sg: AsciiSubgraph = {\n    name: mSg.label,\n    nodes: [],\n    parent,\n    children: [],\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\n  }\n\n  // Resolve node references\n  for (const nodeId of mSg.nodeIds) {\n    const node = nodeMap.get(nodeId)\n    if (node) sg.nodes.push(node)\n  }\n\n  allSubgraphs.push(sg)\n\n  // Recurse into children\n  for (const childMSg of mSg.children) {\n    const child = convertSubgraph(childMSg, sg, nodeMap, allSubgraphs)\n    sg.children.push(child)\n\n    // Child nodes are also part of parent subgraphs (Go behavior).\n    // The Go parser adds nodes to ALL subgraphs in the stack, so a nested\n    // node belongs to both the inner and outer subgraph.\n    for (const childNode of child.nodes) {\n      if (!sg.nodes.includes(childNode)) {\n        sg.nodes.push(childNode)\n      }\n    }\n  }\n\n  return sg\n}\n\n/**\n * Deduplicate subgraph node membership to match Go parser behavior.\n *\n * The Go parser only adds a node to the subgraph that was active when the node\n * was FIRST CREATED. If a node is later referenced inside a different subgraph,\n * it is NOT added to that subgraph. The TS parser is more permissive  it adds\n * referenced nodes to whichever subgraph they appear in.\n *\n * This function fixes the discrepancy by:\n * 1. Walking the edges to determine which nodes were first created inside each subgraph\n * 2. Removing nodes from subgraphs where they weren't first created\n */\nfunction deduplicateSubgraphNodes(\n  mermaidSubgraphs: MermaidSubgraph[],\n  asciiSubgraphs: AsciiSubgraph[],\n  nodeMap: Map<string, AsciiNode>,\n  parsed: MermaidGraph,\n): void {\n  // Build a map from MermaidSubgraph to its corresponding AsciiSubgraph.\n  // The ordering matches since we convert them in the same order.\n  const sgMap = new Map<MermaidSubgraph, AsciiSubgraph>()\n  buildSgMap(mermaidSubgraphs, asciiSubgraphs, sgMap)\n\n  // Determine which subgraph each node was \"first defined\" in.\n  // A node is first defined in the subgraph where it first appears as a NEW node\n  // in the ordered edge/node list. We approximate this by checking the global\n  // node insertion order against subgraph membership.\n  const nodeOwner = new Map<string, AsciiSubgraph>() // nodeId  owning subgraph\n\n  // Walk all mermaid subgraphs in document order. For each subgraph,\n  // claim nodes that haven't been claimed yet by any previous subgraph.\n  function claimNodes(mSg: MermaidSubgraph): void {\n    const asciiSg = sgMap.get(mSg)\n    if (!asciiSg) return\n\n    // Recurse into children first (they appear before parent in the Go parser stack,\n    // but nodes defined in children are added to parent too  this is handled by\n    // the convertSubgraph function which propagates child nodes to parents).\n    // For dedup, we process children first so their claims propagate up correctly.\n    for (const child of mSg.children) {\n      claimNodes(child)\n    }\n\n    // Claim unclaimed nodes in this subgraph\n    for (const nodeId of mSg.nodeIds) {\n      if (!nodeOwner.has(nodeId)) {\n        nodeOwner.set(nodeId, asciiSg)\n      }\n    }\n  }\n\n  for (const mSg of mermaidSubgraphs) {\n    claimNodes(mSg)\n  }\n\n  // Now remove nodes from subgraphs that don't own them.\n  // A node should remain in: its owner subgraph + all ancestors of the owner.\n  for (const asciiSg of asciiSubgraphs) {\n    asciiSg.nodes = asciiSg.nodes.filter(node => {\n      // Find this node's ID in the nodeMap\n      let nodeId: string | undefined\n      for (const [id, n] of nodeMap) {\n        if (n === node) { nodeId = id; break }\n      }\n      if (!nodeId) return false\n\n      const owner = nodeOwner.get(nodeId)\n      if (!owner) return true // not in any subgraph claim  keep as-is\n\n      // Keep the node if this subgraph is the owner or an ancestor of the owner\n      return isAncestorOrSelf(asciiSg, owner)\n    })\n  }\n}\n\n/** Check if `candidate` is the same as or an ancestor of `target`. */\nfunction isAncestorOrSelf(candidate: AsciiSubgraph, target: AsciiSubgraph): boolean {\n  let current: AsciiSubgraph | null = target\n  while (current !== null) {\n    if (current === candidate) return true\n    current = current.parent\n  }\n  return false\n}\n\n/** Build a mapping from MermaidSubgraph  AsciiSubgraph (matching by position). */\nfunction buildSgMap(\n  mSgs: MermaidSubgraph[],\n  aSgs: AsciiSubgraph[],\n  result: Map<MermaidSubgraph, AsciiSubgraph>,\n): void {\n  // The asciiSubgraphs array is flat (all subgraphs including nested ones),\n  // while mermaidSubgraphs is hierarchical. We need to flatten the mermaid tree\n  // in the same order the converter processes them (pre-order DFS).\n  const flatMermaid: MermaidSubgraph[] = []\n  function flatten(sgs: MermaidSubgraph[]): void {\n    for (const sg of sgs) {\n      flatMermaid.push(sg)\n      flatten(sg.children)\n    }\n  }\n  flatten(mSgs)\n\n  for (let i = 0; i < flatMermaid.length && i < aSgs.length; i++) {\n    result.set(flatMermaid[i]!, aSgs[i]!)\n  }\n}\n","// ============================================================================\n// ASCII renderer  A* pathfinding for edge routing\n//\n// Ported from AlexanderGrooff/mermaid-ascii cmd/arrow.go.\n// Uses A* search with a corner-penalizing heuristic to find clean\n// paths between nodes on the grid. Prefers straight lines over zigzags.\n// ============================================================================\n\nimport type { GridCoord, AsciiNode } from './types.ts'\nimport { gridKey, gridCoordEquals } from './types.ts'\n\n// ============================================================================\n// Priority queue (min-heap) for A* open set\n// ============================================================================\n\ninterface PQItem {\n  coord: GridCoord\n  priority: number\n}\n\n/**\n * Simple min-heap priority queue.\n * For the grid sizes we handle (~100s of cells), this is more than fast enough.\n */\nclass MinHeap {\n  private items: PQItem[] = []\n\n  get length(): number {\n    return this.items.length\n  }\n\n  push(item: PQItem): void {\n    this.items.push(item)\n    this.bubbleUp(this.items.length - 1)\n  }\n\n  pop(): PQItem | undefined {\n    if (this.items.length === 0) return undefined\n    const top = this.items[0]!\n    const last = this.items.pop()!\n    if (this.items.length > 0) {\n      this.items[0] = last\n      this.sinkDown(0)\n    }\n    return top\n  }\n\n  private bubbleUp(i: number): void {\n    while (i > 0) {\n      const parent = (i - 1) >> 1\n      if (this.items[i]!.priority < this.items[parent]!.priority) {\n        ;[this.items[i], this.items[parent]] = [this.items[parent]!, this.items[i]!]\n        i = parent\n      } else {\n        break\n      }\n    }\n  }\n\n  private sinkDown(i: number): void {\n    const n = this.items.length\n    while (true) {\n      let smallest = i\n      const left = 2 * i + 1\n      const right = 2 * i + 2\n      if (left < n && this.items[left]!.priority < this.items[smallest]!.priority) {\n        smallest = left\n      }\n      if (right < n && this.items[right]!.priority < this.items[smallest]!.priority) {\n        smallest = right\n      }\n      if (smallest !== i) {\n        ;[this.items[i], this.items[smallest]] = [this.items[smallest]!, this.items[i]!]\n        i = smallest\n      } else {\n        break\n      }\n    }\n  }\n}\n\n// ============================================================================\n// A* heuristic\n// ============================================================================\n\n/**\n * Manhattan distance with a +1 penalty when both dx and dy are non-zero.\n * This encourages the pathfinder to prefer straight lines and minimize corners.\n */\nexport function heuristic(a: GridCoord, b: GridCoord): number {\n  const absX = Math.abs(a.x - b.x)\n  const absY = Math.abs(a.y - b.y)\n  if (absX === 0 || absY === 0) {\n    return absX + absY\n  }\n  return absX + absY + 1\n}\n\n// ============================================================================\n// A* pathfinding\n// ============================================================================\n\n/** 4-directional movement (no diagonals in grid pathfinding). */\nconst MOVE_DIRS: GridCoord[] = [\n  { x: 1, y: 0 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 0, y: -1 },\n]\n\n/** Check if a grid cell is unoccupied and has non-negative coordinates. */\nfunction isFreeInGrid(grid: Map<string, AsciiNode>, c: GridCoord): boolean {\n  if (c.x < 0 || c.y < 0) return false\n  return !grid.has(gridKey(c))\n}\n\n/**\n * Find a path from `from` to `to` on the grid using A*.\n * Returns the path as an array of GridCoords, or null if no path exists.\n */\nexport function getPath(\n  grid: Map<string, AsciiNode>,\n  from: GridCoord,\n  to: GridCoord,\n): GridCoord[] | null {\n  const pq = new MinHeap()\n  pq.push({ coord: from, priority: 0 })\n\n  const costSoFar = new Map<string, number>()\n  costSoFar.set(gridKey(from), 0)\n\n  const cameFrom = new Map<string, GridCoord | null>()\n  cameFrom.set(gridKey(from), null)\n\n  while (pq.length > 0) {\n    const current = pq.pop()!.coord\n\n    if (gridCoordEquals(current, to)) {\n      // Reconstruct path by walking backwards through cameFrom\n      const path: GridCoord[] = []\n      let c: GridCoord | null = current\n      while (c !== null) {\n        path.unshift(c)\n        c = cameFrom.get(gridKey(c)) ?? null\n      }\n      return path\n    }\n\n    const currentCost = costSoFar.get(gridKey(current))!\n\n    for (const dir of MOVE_DIRS) {\n      const next: GridCoord = { x: current.x + dir.x, y: current.y + dir.y }\n\n      // Allow moving to the destination even if it's occupied (it's a node boundary)\n      if (!isFreeInGrid(grid, next) && !gridCoordEquals(next, to)) {\n        continue\n      }\n\n      const newCost = currentCost + 1\n      const nextKey = gridKey(next)\n      const existingCost = costSoFar.get(nextKey)\n\n      if (existingCost === undefined || newCost < existingCost) {\n        costSoFar.set(nextKey, newCost)\n        const priority = newCost + heuristic(next, to)\n        pq.push({ coord: next, priority })\n        cameFrom.set(nextKey, current)\n      }\n    }\n  }\n\n  return null // No path found\n}\n\n/**\n * Simplify a path by removing intermediate waypoints on straight segments.\n * E.g., [(0,0), (1,0), (2,0), (2,1)] becomes [(0,0), (2,0), (2,1)].\n * This reduces the number of line-drawing operations.\n */\nexport function mergePath(path: GridCoord[]): GridCoord[] {\n  if (path.length <= 2) return path\n\n  const toRemove = new Set<number>()\n  let step0 = path[0]!\n  let step1 = path[1]!\n\n  for (let idx = 2; idx < path.length; idx++) {\n    const step2 = path[idx]!\n    const prevDx = step1.x - step0.x\n    const prevDy = step1.y - step0.y\n    const dx = step2.x - step1.x\n    const dy = step2.y - step1.y\n\n    // Same direction  the middle point is redundant\n    if (prevDx === dx && prevDy === dy) {\n      // In Go: indexToRemove = append(indexToRemove, idx+1) but idx is 0-based from path[2:]\n      // which corresponds to index idx in the full path. Go uses idx+1 because idx iterates\n      // from 0 in the [2:] slice, mapping to full-array index idx+1.\n      // Actually re-checking Go code: the loop is `for idx, step2 := range path[2:]`\n      // so idx=0  path[2], and it removes idx+1 which is index 1 in the full array.\n      // Wait, that doesn't look right. Let me re-read:\n      //   step0 = path[0], step1 = path[1]\n      //   for idx, step2 := range path[2:] { ... indexToRemove = append(indexToRemove, idx+1) ... }\n      //   When idx=0, step2=path[2], and it removes index 1 (step1 = path[1]) if directions match\n      // So it removes the middle point (step1) which is at index idx+1 in the original array\n      // when counting from the 2-ahead loop. Let me just track which middle indices to remove.\n      toRemove.add(idx - 1) // Remove the middle point (step1's position)\n    }\n\n    step0 = step1\n    step1 = step2\n  }\n\n  return path.filter((_, i) => !toRemove.has(i))\n}\n","// ============================================================================\n// ASCII renderer  direction system and edge path determination\n//\n// Ported from AlexanderGrooff/mermaid-ascii cmd/direction.go + cmd/mapping_edge.go.\n// Handles direction constants, edge attachment point selection,\n// and dual-path comparison for optimal edge routing.\n// ============================================================================\n\nimport type { GridCoord, Direction, AsciiEdge, AsciiGraph } from './types.ts'\nimport {\n  Up, Down, Left, Right, UpperRight, UpperLeft, LowerRight, LowerLeft, Middle,\n  gridCoordDirection,\n} from './types.ts'\nimport { getPath, mergePath } from './pathfinder.ts'\n\n// ============================================================================\n// Direction utilities\n// ============================================================================\n\nexport function getOpposite(d: Direction): Direction {\n  if (d === Up) return Down\n  if (d === Down) return Up\n  if (d === Left) return Right\n  if (d === Right) return Left\n  if (d === UpperRight) return LowerLeft\n  if (d === UpperLeft) return LowerRight\n  if (d === LowerRight) return UpperLeft\n  if (d === LowerLeft) return UpperRight\n  return Middle\n}\n\n/** Compare directions by value (not reference). */\nexport function dirEquals(a: Direction, b: Direction): boolean {\n  return a.x === b.x && a.y === b.y\n}\n\n/**\n * Determine 8-way direction from one coordinate to another.\n * Uses the coordinate difference to pick one of 8 cardinal/ordinal directions.\n */\nexport function determineDirection(from: { x: number; y: number }, to: { x: number; y: number }): Direction {\n  if (from.x === to.x) {\n    return from.y < to.y ? Down : Up\n  } else if (from.y === to.y) {\n    return from.x < to.x ? Right : Left\n  } else if (from.x < to.x) {\n    return from.y < to.y ? LowerRight : UpperRight\n  } else {\n    return from.y < to.y ? LowerLeft : UpperLeft\n  }\n}\n\n// ============================================================================\n// Start/end direction selection for edges\n// ============================================================================\n\n/** Self-reference routing (node points to itself). */\nfunction selfReferenceDirection(graphDirection: string): [Direction, Direction, Direction, Direction] {\n  if (graphDirection === 'LR') return [Right, Down, Down, Right]\n  return [Down, Right, Right, Down]\n}\n\n/**\n * Determine preferred and alternative start/end directions for an edge.\n * Returns [preferredStart, preferredEnd, alternativeStart, alternativeEnd].\n *\n * The edge routing tries both pairs and picks the shorter path.\n * Direction selection depends on relative node positions and graph direction (LR vs TD).\n */\nexport function determineStartAndEndDir(\n  edge: AsciiEdge,\n  graphDirection: string,\n): [Direction, Direction, Direction, Direction] {\n  if (edge.from === edge.to) return selfReferenceDirection(graphDirection)\n\n  const d = determineDirection(edge.from.gridCoord!, edge.to.gridCoord!)\n\n  let preferredDir: Direction\n  let preferredOppositeDir: Direction\n  let alternativeDir: Direction\n  let alternativeOppositeDir: Direction\n\n  const isBackwards = graphDirection === 'LR'\n    ? (dirEquals(d, Left) || dirEquals(d, UpperLeft) || dirEquals(d, LowerLeft))\n    : (dirEquals(d, Up) || dirEquals(d, UpperLeft) || dirEquals(d, UpperRight))\n\n  if (dirEquals(d, LowerRight)) {\n    if (graphDirection === 'LR') {\n      preferredDir = Down; preferredOppositeDir = Left\n      alternativeDir = Right; alternativeOppositeDir = Up\n    } else {\n      preferredDir = Right; preferredOppositeDir = Up\n      alternativeDir = Down; alternativeOppositeDir = Left\n    }\n  } else if (dirEquals(d, UpperRight)) {\n    if (graphDirection === 'LR') {\n      preferredDir = Up; preferredOppositeDir = Left\n      alternativeDir = Right; alternativeOppositeDir = Down\n    } else {\n      preferredDir = Right; preferredOppositeDir = Down\n      alternativeDir = Up; alternativeOppositeDir = Left\n    }\n  } else if (dirEquals(d, LowerLeft)) {\n    if (graphDirection === 'LR') {\n      preferredDir = Down; preferredOppositeDir = Down\n      alternativeDir = Left; alternativeOppositeDir = Up\n    } else {\n      preferredDir = Left; preferredOppositeDir = Up\n      alternativeDir = Down; alternativeOppositeDir = Right\n    }\n  } else if (dirEquals(d, UpperLeft)) {\n    if (graphDirection === 'LR') {\n      preferredDir = Down; preferredOppositeDir = Down\n      alternativeDir = Left; alternativeOppositeDir = Down\n    } else {\n      preferredDir = Right; preferredOppositeDir = Right\n      alternativeDir = Up; alternativeOppositeDir = Right\n    }\n  } else if (isBackwards) {\n    if (graphDirection === 'LR' && dirEquals(d, Left)) {\n      preferredDir = Down; preferredOppositeDir = Down\n      alternativeDir = Left; alternativeOppositeDir = Right\n    } else if (graphDirection === 'TD' && dirEquals(d, Up)) {\n      preferredDir = Right; preferredOppositeDir = Right\n      alternativeDir = Up; alternativeOppositeDir = Down\n    } else {\n      preferredDir = d; preferredOppositeDir = getOpposite(d)\n      alternativeDir = d; alternativeOppositeDir = getOpposite(d)\n    }\n  } else {\n    // Default: go in the natural direction\n    preferredDir = d; preferredOppositeDir = getOpposite(d)\n    alternativeDir = d; alternativeOppositeDir = getOpposite(d)\n  }\n\n  return [preferredDir, preferredOppositeDir, alternativeDir, alternativeOppositeDir]\n}\n\n// ============================================================================\n// Edge path determination\n// ============================================================================\n\n/**\n * Determine the path for an edge by trying two candidate routes (preferred + alternative)\n * and picking the shorter one. Sets edge.path, edge.startDir, edge.endDir.\n */\nexport function determinePath(graph: AsciiGraph, edge: AsciiEdge): void {\n  const [preferredDir, preferredOppositeDir, alternativeDir, alternativeOppositeDir] =\n    determineStartAndEndDir(edge, graph.config.graphDirection)\n\n  // Try preferred path\n  const prefFrom = gridCoordDirection(edge.from.gridCoord!, preferredDir)\n  const prefTo = gridCoordDirection(edge.to.gridCoord!, preferredOppositeDir)\n  let preferredPath = getPath(graph.grid, prefFrom, prefTo)\n\n  if (preferredPath === null) {\n    // No preferred path found  use alternative\n    edge.startDir = alternativeDir\n    edge.endDir = alternativeOppositeDir\n    edge.path = []\n    return\n  }\n  preferredPath = mergePath(preferredPath)\n\n  // Try alternative path\n  const altFrom = gridCoordDirection(edge.from.gridCoord!, alternativeDir)\n  const altTo = gridCoordDirection(edge.to.gridCoord!, alternativeOppositeDir)\n  let alternativePath = getPath(graph.grid, altFrom, altTo)\n\n  if (alternativePath === null) {\n    // Only preferred path works\n    edge.startDir = preferredDir\n    edge.endDir = preferredOppositeDir\n    edge.path = preferredPath\n    return\n  }\n  alternativePath = mergePath(alternativePath)\n\n  // Pick the shorter path\n  if (preferredPath.length <= alternativePath.length) {\n    edge.startDir = preferredDir\n    edge.endDir = preferredOppositeDir\n    edge.path = preferredPath\n  } else {\n    edge.startDir = alternativeDir\n    edge.endDir = alternativeOppositeDir\n    edge.path = alternativePath\n  }\n}\n\n/**\n * Find the best line segment in an edge's path to place a label on.\n * Picks the first segment wide enough for the label, or the widest segment overall.\n * Also increases the column width at the label position to fit the text.\n */\nexport function determineLabelLine(graph: AsciiGraph, edge: AsciiEdge): void {\n  if (edge.text.length === 0) return\n\n  const lenLabel = edge.text.length\n  let prevStep = edge.path[0]!\n  let largestLine: [GridCoord, GridCoord] = [prevStep, edge.path[1]!]\n  let largestLineSize = 0\n\n  for (let i = 1; i < edge.path.length; i++) {\n    const step = edge.path[i]!\n    const line: [GridCoord, GridCoord] = [prevStep, step]\n    const lineWidth = calculateLineWidth(graph, line)\n\n    if (lineWidth >= lenLabel) {\n      largestLine = line\n      break\n    } else if (lineWidth > largestLineSize) {\n      largestLineSize = lineWidth\n      largestLine = line\n    }\n    prevStep = step\n  }\n\n  // Ensure column at midpoint is wide enough for the label\n  const minX = Math.min(largestLine[0].x, largestLine[1].x)\n  const maxX = Math.max(largestLine[0].x, largestLine[1].x)\n  const middleX = minX + Math.floor((maxX - minX) / 2)\n\n  const current = graph.columnWidth.get(middleX) ?? 0\n  graph.columnWidth.set(middleX, Math.max(current, lenLabel + 2))\n\n  edge.labelLine = [largestLine[0], largestLine[1]]\n}\n\n/** Calculate the total character width of a line segment by summing column widths. */\nfunction calculateLineWidth(graph: AsciiGraph, line: [GridCoord, GridCoord]): number {\n  let total = 0\n  const startX = Math.min(line[0].x, line[1].x)\n  const endX = Math.max(line[0].x, line[1].x)\n  for (let x = startX; x <= endX; x++) {\n    total += graph.columnWidth.get(x) ?? 0\n  }\n  return total\n}\n","// ============================================================================\n// ASCII renderer  drawing operations\n//\n// Ported from AlexanderGrooff/mermaid-ascii cmd/draw.go + cmd/arrow.go.\n// Contains all visual rendering: boxes, lines, arrows, corners,\n// subgraphs, labels, and the top-level draw orchestrator.\n// ============================================================================\n\nimport type {\n  Canvas, DrawingCoord, GridCoord, Direction,\n  AsciiGraph, AsciiNode, AsciiEdge, AsciiSubgraph,\n} from './types.ts'\nimport {\n  Up, Down, Left, Right, UpperLeft, UpperRight, LowerLeft, LowerRight, Middle,\n  drawingCoordEquals,\n} from './types.ts'\nimport { mkCanvas, copyCanvas, getCanvasSize, mergeCanvases, drawText } from './canvas.ts'\nimport { determineDirection, dirEquals } from './edge-routing.ts'\nimport { gridToDrawingCoord, lineToDrawing } from './grid.ts'\n\n// ============================================================================\n// Box drawing  renders a node as a bordered rectangle\n// ============================================================================\n\n/**\n * Draw a node box with centered label text.\n * Returns a standalone canvas containing just the box.\n * Box size is determined by the grid column/row sizes for the node's position.\n */\nexport function drawBox(node: AsciiNode, graph: AsciiGraph): Canvas {\n  const gc = node.gridCoord!\n  const useAscii = graph.config.useAscii\n\n  // Width spans 2 columns (border + content)\n  let w = 0\n  for (let i = 0; i < 2; i++) {\n    w += graph.columnWidth.get(gc.x + i) ?? 0\n  }\n  // Height spans 2 rows (border + content)\n  let h = 0\n  for (let i = 0; i < 2; i++) {\n    h += graph.rowHeight.get(gc.y + i) ?? 0\n  }\n\n  const from: DrawingCoord = { x: 0, y: 0 }\n  const to: DrawingCoord = { x: w, y: h }\n  const box = mkCanvas(Math.max(from.x, to.x), Math.max(from.y, to.y))\n\n  if (!useAscii) {\n    // Unicode box-drawing characters\n    for (let x = from.x + 1; x < to.x; x++) box[x]![from.y] = ''\n    for (let x = from.x + 1; x < to.x; x++) box[x]![to.y] = ''\n    for (let y = from.y + 1; y < to.y; y++) box[from.x]![y] = ''\n    for (let y = from.y + 1; y < to.y; y++) box[to.x]![y] = ''\n    box[from.x]![from.y] = ''\n    box[to.x]![from.y] = ''\n    box[from.x]![to.y] = ''\n    box[to.x]![to.y] = ''\n  } else {\n    // ASCII characters\n    for (let x = from.x + 1; x < to.x; x++) box[x]![from.y] = '-'\n    for (let x = from.x + 1; x < to.x; x++) box[x]![to.y] = '-'\n    for (let y = from.y + 1; y < to.y; y++) box[from.x]![y] = '|'\n    for (let y = from.y + 1; y < to.y; y++) box[to.x]![y] = '|'\n    box[from.x]![from.y] = '+'\n    box[to.x]![from.y] = '+'\n    box[from.x]![to.y] = '+'\n    box[to.x]![to.y] = '+'\n  }\n\n  // Center the display label inside the box\n  const label = node.displayLabel\n  const textY = from.y + Math.floor(h / 2)\n  const textX = from.x + Math.floor(w / 2) - Math.ceil(label.length / 2) + 1\n  for (let i = 0; i < label.length; i++) {\n    box[textX + i]![textY] = label[i]!\n  }\n\n  return box\n}\n\n// ============================================================================\n// Multi-section box drawing  for class and ER diagram nodes\n// ============================================================================\n\n/**\n * Draw a multi-section box with horizontal dividers between sections.\n * Used by class diagrams (header | attributes | methods) and ER diagrams (header | attributes).\n * Each section is an array of text lines to render left-aligned with padding.\n *\n * @param sections - Array of sections, each section is an array of text lines\n * @param useAscii - true for ASCII chars, false for Unicode box-drawing\n * @param padding - horizontal padding inside the box (default 1)\n * @returns A standalone Canvas containing the multi-section box\n */\nexport function drawMultiBox(\n  sections: string[][],\n  useAscii: boolean,\n  padding: number = 1,\n): Canvas {\n  // Compute width: widest line across all sections + 2*padding + 2 border chars\n  let maxTextWidth = 0\n  for (const section of sections) {\n    for (const line of section) {\n      maxTextWidth = Math.max(maxTextWidth, line.length)\n    }\n  }\n  const innerWidth = maxTextWidth + 2 * padding\n  const boxWidth = innerWidth + 2 // +2 for left/right border\n\n  // Compute height: sum of all section line counts + dividers + 2 border rows\n  let totalLines = 0\n  for (const section of sections) {\n    totalLines += Math.max(section.length, 1) // at least 1 row per section\n  }\n  const numDividers = sections.length - 1\n  const boxHeight = totalLines + numDividers + 2 // +2 for top/bottom border\n\n  // Box-drawing characters\n  const hLine = useAscii ? '-' : ''\n  const vLine = useAscii ? '|' : ''\n  const tl = useAscii ? '+' : ''\n  const tr = useAscii ? '+' : ''\n  const bl = useAscii ? '+' : ''\n  const br = useAscii ? '+' : ''\n  const divL = useAscii ? '+' : ''\n  const divR = useAscii ? '+' : ''\n\n  const canvas = mkCanvas(boxWidth - 1, boxHeight - 1)\n\n  // Top border\n  canvas[0]![0] = tl\n  for (let x = 1; x < boxWidth - 1; x++) canvas[x]![0] = hLine\n  canvas[boxWidth - 1]![0] = tr\n\n  // Bottom border\n  canvas[0]![boxHeight - 1] = bl\n  for (let x = 1; x < boxWidth - 1; x++) canvas[x]![boxHeight - 1] = hLine\n  canvas[boxWidth - 1]![boxHeight - 1] = br\n\n  // Left and right borders (full height)\n  for (let y = 1; y < boxHeight - 1; y++) {\n    canvas[0]![y] = vLine\n    canvas[boxWidth - 1]![y] = vLine\n  }\n\n  // Render sections with dividers\n  let row = 1 // current y position (starts after top border)\n  for (let s = 0; s < sections.length; s++) {\n    const section = sections[s]!\n    const lines = section.length > 0 ? section : ['']\n\n    // Draw section text lines\n    for (const line of lines) {\n      const startX = 1 + padding\n      for (let i = 0; i < line.length; i++) {\n        canvas[startX + i]![row] = line[i]!\n      }\n      row++\n    }\n\n    // Draw divider after each section except the last\n    if (s < sections.length - 1) {\n      canvas[0]![row] = divL\n      for (let x = 1; x < boxWidth - 1; x++) canvas[x]![row] = hLine\n      canvas[boxWidth - 1]![row] = divR\n      row++\n    }\n  }\n\n  return canvas\n}\n\n// ============================================================================\n// Line drawing  8-directional lines on the canvas\n// ============================================================================\n\n/**\n * Draw a line between two drawing coordinates.\n * Returns the list of coordinates that were drawn on.\n * offsetFrom/offsetTo control how many cells to skip at the start/end.\n */\nexport function drawLine(\n  canvas: Canvas,\n  from: DrawingCoord,\n  to: DrawingCoord,\n  offsetFrom: number,\n  offsetTo: number,\n  useAscii: boolean,\n): DrawingCoord[] {\n  const dir = determineDirection(from, to)\n  const drawnCoords: DrawingCoord[] = []\n\n  // Horizontal/vertical/diagonal character pairs: [unicode, ascii]\n  const hChar = useAscii ? '-' : ''\n  const vChar = useAscii ? '|' : ''\n  const bslash = useAscii ? '\\\\' : ''\n  const fslash = useAscii ? '/' : ''\n\n  if (dirEquals(dir, Up)) {\n    for (let y = from.y - offsetFrom; y >= to.y - offsetTo; y--) {\n      drawnCoords.push({ x: from.x, y })\n      canvas[from.x]![y] = vChar\n    }\n  } else if (dirEquals(dir, Down)) {\n    for (let y = from.y + offsetFrom; y <= to.y + offsetTo; y++) {\n      drawnCoords.push({ x: from.x, y })\n      canvas[from.x]![y] = vChar\n    }\n  } else if (dirEquals(dir, Left)) {\n    for (let x = from.x - offsetFrom; x >= to.x - offsetTo; x--) {\n      drawnCoords.push({ x, y: from.y })\n      canvas[x]![from.y] = hChar\n    }\n  } else if (dirEquals(dir, Right)) {\n    for (let x = from.x + offsetFrom; x <= to.x + offsetTo; x++) {\n      drawnCoords.push({ x, y: from.y })\n      canvas[x]![from.y] = hChar\n    }\n  } else if (dirEquals(dir, UpperLeft)) {\n    for (let x = from.x, y = from.y - offsetFrom; x >= to.x - offsetTo && y >= to.y - offsetTo; x--, y--) {\n      drawnCoords.push({ x, y })\n      canvas[x]![y] = bslash\n    }\n  } else if (dirEquals(dir, UpperRight)) {\n    for (let x = from.x, y = from.y - offsetFrom; x <= to.x + offsetTo && y >= to.y - offsetTo; x++, y--) {\n      drawnCoords.push({ x, y })\n      canvas[x]![y] = fslash\n    }\n  } else if (dirEquals(dir, LowerLeft)) {\n    for (let x = from.x, y = from.y + offsetFrom; x >= to.x - offsetTo && y <= to.y + offsetTo; x--, y++) {\n      drawnCoords.push({ x, y })\n      canvas[x]![y] = fslash\n    }\n  } else if (dirEquals(dir, LowerRight)) {\n    for (let x = from.x, y = from.y + offsetFrom; x <= to.x + offsetTo && y <= to.y + offsetTo; x++, y++) {\n      drawnCoords.push({ x, y })\n      canvas[x]![y] = bslash\n    }\n  }\n\n  return drawnCoords\n}\n\n// ============================================================================\n// Arrow drawing  path, corners, arrowheads, box-start junctions, labels\n// ============================================================================\n\n/**\n * Draw a complete arrow (edge) between two nodes.\n * Returns 5 separate canvases for layered compositing:\n * [path, boxStart, arrowHead, corners, label]\n */\nexport function drawArrow(\n  graph: AsciiGraph,\n  edge: AsciiEdge,\n): [Canvas, Canvas, Canvas, Canvas, Canvas] {\n  if (edge.path.length === 0) {\n    const empty = copyCanvas(graph.canvas)\n    return [empty, empty, empty, empty, empty]\n  }\n\n  const labelCanvas = drawArrowLabel(graph, edge)\n  const [pathCanvas, linesDrawn, lineDirs] = drawPath(graph, edge.path)\n  const boxStartCanvas = drawBoxStart(graph, edge.path, linesDrawn[0]!)\n  const arrowHeadCanvas = drawArrowHead(\n    graph,\n    linesDrawn[linesDrawn.length - 1]!,\n    lineDirs[lineDirs.length - 1]!,\n  )\n  const cornersCanvas = drawCorners(graph, edge.path)\n\n  return [pathCanvas, boxStartCanvas, arrowHeadCanvas, cornersCanvas, labelCanvas]\n}\n\n/**\n * Draw the path lines for an edge.\n * Returns the canvas, the coordinates drawn for each segment, and the direction of each segment.\n */\nfunction drawPath(\n  graph: AsciiGraph,\n  path: GridCoord[],\n): [Canvas, DrawingCoord[][], Direction[]] {\n  const canvas = copyCanvas(graph.canvas)\n  let previousCoord = path[0]!\n  const linesDrawn: DrawingCoord[][] = []\n  const lineDirs: Direction[] = []\n\n  for (let i = 1; i < path.length; i++) {\n    const nextCoord = path[i]!\n    const prevDC = gridToDrawingCoord(graph, previousCoord)\n    const nextDC = gridToDrawingCoord(graph, nextCoord)\n\n    if (drawingCoordEquals(prevDC, nextDC)) {\n      previousCoord = nextCoord\n      continue\n    }\n\n    const dir = determineDirection(previousCoord, nextCoord)\n    const segment = drawLine(canvas, prevDC, nextDC, 1, -1, graph.config.useAscii)\n    if (segment.length === 0) segment.push(prevDC)\n    linesDrawn.push(segment)\n    lineDirs.push(dir)\n    previousCoord = nextCoord\n  }\n\n  return [canvas, linesDrawn, lineDirs]\n}\n\n/**\n * Draw the junction character where an edge exits the source node's box.\n * Only applies to Unicode mode (ASCII mode just uses the line characters).\n */\nfunction drawBoxStart(\n  graph: AsciiGraph,\n  path: GridCoord[],\n  firstLine: DrawingCoord[],\n): Canvas {\n  const canvas = copyCanvas(graph.canvas)\n  if (graph.config.useAscii) return canvas\n\n  const from = firstLine[0]!\n  const dir = determineDirection(path[0]!, path[1]!)\n\n  if (dirEquals(dir, Up)) canvas[from.x]![from.y + 1] = ''\n  else if (dirEquals(dir, Down)) canvas[from.x]![from.y - 1] = ''\n  else if (dirEquals(dir, Left)) canvas[from.x + 1]![from.y] = ''\n  else if (dirEquals(dir, Right)) canvas[from.x - 1]![from.y] = ''\n\n  return canvas\n}\n\n/**\n * Draw the arrowhead at the end of an edge path.\n * Uses triangular Unicode symbols () or ASCII symbols (^v<>).\n */\nfunction drawArrowHead(\n  graph: AsciiGraph,\n  lastLine: DrawingCoord[],\n  fallbackDir: Direction,\n): Canvas {\n  const canvas = copyCanvas(graph.canvas)\n  if (lastLine.length === 0) return canvas\n\n  const from = lastLine[0]!\n  const lastPos = lastLine[lastLine.length - 1]!\n  let dir = determineDirection(from, lastPos)\n  if (lastLine.length === 1 || dirEquals(dir, Middle)) dir = fallbackDir\n\n  let char: string\n\n  if (!graph.config.useAscii) {\n    if (dirEquals(dir, Up)) char = ''\n    else if (dirEquals(dir, Down)) char = ''\n    else if (dirEquals(dir, Left)) char = ''\n    else if (dirEquals(dir, Right)) char = ''\n    else if (dirEquals(dir, UpperRight)) char = ''\n    else if (dirEquals(dir, UpperLeft)) char = ''\n    else if (dirEquals(dir, LowerRight)) char = ''\n    else if (dirEquals(dir, LowerLeft)) char = ''\n    else {\n      // Fallback\n      if (dirEquals(fallbackDir, Up)) char = ''\n      else if (dirEquals(fallbackDir, Down)) char = ''\n      else if (dirEquals(fallbackDir, Left)) char = ''\n      else if (dirEquals(fallbackDir, Right)) char = ''\n      else if (dirEquals(fallbackDir, UpperRight)) char = ''\n      else if (dirEquals(fallbackDir, UpperLeft)) char = ''\n      else if (dirEquals(fallbackDir, LowerRight)) char = ''\n      else if (dirEquals(fallbackDir, LowerLeft)) char = ''\n      else char = ''\n    }\n  } else {\n    if (dirEquals(dir, Up)) char = '^'\n    else if (dirEquals(dir, Down)) char = 'v'\n    else if (dirEquals(dir, Left)) char = '<'\n    else if (dirEquals(dir, Right)) char = '>'\n    else {\n      if (dirEquals(fallbackDir, Up)) char = '^'\n      else if (dirEquals(fallbackDir, Down)) char = 'v'\n      else if (dirEquals(fallbackDir, Left)) char = '<'\n      else if (dirEquals(fallbackDir, Right)) char = '>'\n      else char = '*'\n    }\n  }\n\n  canvas[lastPos.x]![lastPos.y] = char\n  return canvas\n}\n\n/**\n * Draw corner characters at path bends (where the direction changes).\n * Uses  in Unicode mode, + in ASCII mode.\n */\nfunction drawCorners(graph: AsciiGraph, path: GridCoord[]): Canvas {\n  const canvas = copyCanvas(graph.canvas)\n\n  for (let idx = 1; idx < path.length - 1; idx++) {\n    const coord = path[idx]!\n    const dc = gridToDrawingCoord(graph, coord)\n    const prevDir = determineDirection(path[idx - 1]!, coord)\n    const nextDir = determineDirection(coord, path[idx + 1]!)\n\n    let corner: string\n    if (!graph.config.useAscii) {\n      if ((dirEquals(prevDir, Right) && dirEquals(nextDir, Down)) ||\n          (dirEquals(prevDir, Up) && dirEquals(nextDir, Left))) {\n        corner = ''\n      } else if ((dirEquals(prevDir, Right) && dirEquals(nextDir, Up)) ||\n                 (dirEquals(prevDir, Down) && dirEquals(nextDir, Left))) {\n        corner = ''\n      } else if ((dirEquals(prevDir, Left) && dirEquals(nextDir, Down)) ||\n                 (dirEquals(prevDir, Up) && dirEquals(nextDir, Right))) {\n        corner = ''\n      } else if ((dirEquals(prevDir, Left) && dirEquals(nextDir, Up)) ||\n                 (dirEquals(prevDir, Down) && dirEquals(nextDir, Right))) {\n        corner = ''\n      } else {\n        corner = '+'\n      }\n    } else {\n      corner = '+'\n    }\n\n    canvas[dc.x]![dc.y] = corner\n  }\n\n  return canvas\n}\n\n/** Draw edge label text centered on the widest path segment. */\nfunction drawArrowLabel(graph: AsciiGraph, edge: AsciiEdge): Canvas {\n  const canvas = copyCanvas(graph.canvas)\n  if (edge.text.length === 0) return canvas\n\n  const drawingLine = lineToDrawing(graph, edge.labelLine)\n  drawTextOnLine(canvas, drawingLine, edge.text)\n  return canvas\n}\n\n/** Draw text centered on a line segment defined by two drawing coordinates. */\nfunction drawTextOnLine(canvas: Canvas, line: DrawingCoord[], label: string): void {\n  if (line.length < 2) return\n  const minX = Math.min(line[0]!.x, line[1]!.x)\n  const maxX = Math.max(line[0]!.x, line[1]!.x)\n  const minY = Math.min(line[0]!.y, line[1]!.y)\n  const maxY = Math.max(line[0]!.y, line[1]!.y)\n  const middleX = minX + Math.floor((maxX - minX) / 2)\n  const middleY = minY + Math.floor((maxY - minY) / 2)\n  const startX = middleX - Math.floor(label.length / 2)\n  drawText(canvas, { x: startX, y: middleY }, label)\n}\n\n// ============================================================================\n// Subgraph drawing\n// ============================================================================\n\n/** Draw a subgraph border rectangle. */\nexport function drawSubgraphBox(sg: AsciiSubgraph, graph: AsciiGraph): Canvas {\n  const width = sg.maxX - sg.minX\n  const height = sg.maxY - sg.minY\n  if (width <= 0 || height <= 0) return mkCanvas(0, 0)\n\n  const from: DrawingCoord = { x: 0, y: 0 }\n  const to: DrawingCoord = { x: width, y: height }\n  const canvas = mkCanvas(width, height)\n\n  if (!graph.config.useAscii) {\n    for (let x = from.x + 1; x < to.x; x++) canvas[x]![from.y] = ''\n    for (let x = from.x + 1; x < to.x; x++) canvas[x]![to.y] = ''\n    for (let y = from.y + 1; y < to.y; y++) canvas[from.x]![y] = ''\n    for (let y = from.y + 1; y < to.y; y++) canvas[to.x]![y] = ''\n    canvas[from.x]![from.y] = ''\n    canvas[to.x]![from.y] = ''\n    canvas[from.x]![to.y] = ''\n    canvas[to.x]![to.y] = ''\n  } else {\n    for (let x = from.x + 1; x < to.x; x++) canvas[x]![from.y] = '-'\n    for (let x = from.x + 1; x < to.x; x++) canvas[x]![to.y] = '-'\n    for (let y = from.y + 1; y < to.y; y++) canvas[from.x]![y] = '|'\n    for (let y = from.y + 1; y < to.y; y++) canvas[to.x]![y] = '|'\n    canvas[from.x]![from.y] = '+'\n    canvas[to.x]![from.y] = '+'\n    canvas[from.x]![to.y] = '+'\n    canvas[to.x]![to.y] = '+'\n  }\n\n  return canvas\n}\n\n/** Draw a subgraph label centered in its header area. */\nexport function drawSubgraphLabel(sg: AsciiSubgraph, graph: AsciiGraph): [Canvas, DrawingCoord] {\n  const width = sg.maxX - sg.minX\n  const height = sg.maxY - sg.minY\n  if (width <= 0 || height <= 0) return [mkCanvas(0, 0), { x: 0, y: 0 }]\n\n  const canvas = mkCanvas(width, height)\n  const labelY = 1 // second row inside the subgraph box\n  let labelX = Math.floor(width / 2) - Math.floor(sg.name.length / 2)\n  if (labelX < 1) labelX = 1\n\n  for (let i = 0; i < sg.name.length; i++) {\n    if (labelX + i < width) {\n      canvas[labelX + i]![labelY] = sg.name[i]!\n    }\n  }\n\n  return [canvas, { x: sg.minX, y: sg.minY }]\n}\n\n// ============================================================================\n// Top-level draw orchestrator\n// ============================================================================\n\n/** Sort subgraphs by nesting depth (shallowest first) for correct layered rendering. */\nfunction sortSubgraphsByDepth(subgraphs: AsciiSubgraph[]): AsciiSubgraph[] {\n  function getDepth(sg: AsciiSubgraph): number {\n    return sg.parent === null ? 0 : 1 + getDepth(sg.parent)\n  }\n  const sorted = [...subgraphs]\n  sorted.sort((a, b) => getDepth(a) - getDepth(b))\n  return sorted\n}\n\n/**\n * Main draw function  renders the entire graph onto the canvas.\n * Drawing order matters for correct layering:\n * 1. Subgraph borders (bottom layer)\n * 2. Node boxes\n * 3. Edge paths (lines)\n * 4. Edge corners\n * 5. Arrowheads\n * 6. Box-start junctions\n * 7. Edge labels\n * 8. Subgraph labels (top layer)\n */\nexport function drawGraph(graph: AsciiGraph): Canvas {\n  const useAscii = graph.config.useAscii\n\n  // Draw subgraph borders\n  const sortedSgs = sortSubgraphsByDepth(graph.subgraphs)\n  for (const sg of sortedSgs) {\n    const sgCanvas = drawSubgraphBox(sg, graph)\n    const offset: DrawingCoord = { x: sg.minX, y: sg.minY }\n    graph.canvas = mergeCanvases(graph.canvas, offset, useAscii, sgCanvas)\n  }\n\n  // Draw node boxes\n  for (const node of graph.nodes) {\n    if (!node.drawn && node.drawingCoord && node.drawing) {\n      graph.canvas = mergeCanvases(graph.canvas, node.drawingCoord, useAscii, node.drawing)\n      node.drawn = true\n    }\n  }\n\n  // Collect all edge drawing layers\n  const lineCanvases: Canvas[] = []\n  const cornerCanvases: Canvas[] = []\n  const arrowHeadCanvases: Canvas[] = []\n  const boxStartCanvases: Canvas[] = []\n  const labelCanvases: Canvas[] = []\n\n  for (const edge of graph.edges) {\n    const [pathC, boxStartC, arrowHeadC, cornersC, labelC] = drawArrow(graph, edge)\n    lineCanvases.push(pathC)\n    cornerCanvases.push(cornersC)\n    arrowHeadCanvases.push(arrowHeadC)\n    boxStartCanvases.push(boxStartC)\n    labelCanvases.push(labelC)\n  }\n\n  // Merge edge layers in order\n  const zero: DrawingCoord = { x: 0, y: 0 }\n  graph.canvas = mergeCanvases(graph.canvas, zero, useAscii, ...lineCanvases)\n  graph.canvas = mergeCanvases(graph.canvas, zero, useAscii, ...cornerCanvases)\n  graph.canvas = mergeCanvases(graph.canvas, zero, useAscii, ...arrowHeadCanvases)\n  graph.canvas = mergeCanvases(graph.canvas, zero, useAscii, ...boxStartCanvases)\n  graph.canvas = mergeCanvases(graph.canvas, zero, useAscii, ...labelCanvases)\n\n  // Draw subgraph labels last (on top)\n  for (const sg of graph.subgraphs) {\n    if (sg.nodes.length === 0) continue\n    const [labelCanvas, offset] = drawSubgraphLabel(sg, graph)\n    graph.canvas = mergeCanvases(graph.canvas, offset, useAscii, labelCanvas)\n  }\n\n  return graph.canvas\n}\n","// ============================================================================\n// ASCII renderer  grid-based layout\n//\n// Ported from AlexanderGrooff/mermaid-ascii cmd/graph.go + cmd/mapping_node.go.\n// Places nodes on a logical grid, computes column/row sizes,\n// converts grid coordinates to character-level drawing coordinates,\n// and handles subgraph bounding boxes.\n// ============================================================================\n\nimport type {\n  GridCoord, DrawingCoord, Direction, AsciiGraph, AsciiNode, AsciiSubgraph,\n} from './types.ts'\nimport { gridKey } from './types.ts'\nimport { mkCanvas, setCanvasSizeToGrid } from './canvas.ts'\nimport { determinePath, determineLabelLine } from './edge-routing.ts'\nimport { drawBox } from './draw.ts'\n\n// ============================================================================\n// Grid coordinate  drawing coordinate conversion\n// ============================================================================\n\n/**\n * Convert a grid coordinate to a drawing (character) coordinate.\n * Sums column widths up to the target column, and row heights up to the target row,\n * then centers within the cell.\n */\nexport function gridToDrawingCoord(\n  graph: AsciiGraph,\n  c: GridCoord,\n  dir?: Direction,\n): DrawingCoord {\n  const target: GridCoord = dir\n    ? { x: c.x + dir.x, y: c.y + dir.y }\n    : c\n\n  let x = 0\n  for (let col = 0; col < target.x; col++) {\n    x += graph.columnWidth.get(col) ?? 0\n  }\n\n  let y = 0\n  for (let row = 0; row < target.y; row++) {\n    y += graph.rowHeight.get(row) ?? 0\n  }\n\n  const colW = graph.columnWidth.get(target.x) ?? 0\n  const rowH = graph.rowHeight.get(target.y) ?? 0\n  return {\n    x: x + Math.floor(colW / 2) + graph.offsetX,\n    y: y + Math.floor(rowH / 2) + graph.offsetY,\n  }\n}\n\n/** Convert a path of grid coords to drawing coords. */\nexport function lineToDrawing(graph: AsciiGraph, line: GridCoord[]): DrawingCoord[] {\n  return line.map(c => gridToDrawingCoord(graph, c))\n}\n\n// ============================================================================\n// Node placement on the grid\n// ============================================================================\n\n/**\n * Reserve a 3x3 block in the grid for a node.\n * If the requested position is occupied, recursively shift by 4 grid units\n * (in the perpendicular direction based on graph direction) until a free spot is found.\n */\nexport function reserveSpotInGrid(\n  graph: AsciiGraph,\n  node: AsciiNode,\n  requested: GridCoord,\n): GridCoord {\n  if (graph.grid.has(gridKey(requested))) {\n    // Collision  shift perpendicular to main flow direction\n    if (graph.config.graphDirection === 'LR') {\n      return reserveSpotInGrid(graph, node, { x: requested.x, y: requested.y + 4 })\n    } else {\n      return reserveSpotInGrid(graph, node, { x: requested.x + 4, y: requested.y })\n    }\n  }\n\n  // Reserve the 3x3 block\n  for (let dx = 0; dx < 3; dx++) {\n    for (let dy = 0; dy < 3; dy++) {\n      const reserved: GridCoord = { x: requested.x + dx, y: requested.y + dy }\n      graph.grid.set(gridKey(reserved), node)\n    }\n  }\n\n  node.gridCoord = requested\n  return requested\n}\n\n// ============================================================================\n// Column width / row height computation\n// ============================================================================\n\n/**\n * Set column widths and row heights for a node's 3x3 grid block.\n * Each node occupies 3 columns (border, content, border) and 3 rows.\n * The content column must be wide enough for the node's label.\n */\nexport function setColumnWidth(graph: AsciiGraph, node: AsciiNode): void {\n  const gc = node.gridCoord!\n  const padding = graph.config.boxBorderPadding\n\n  // 3 columns: [border=1] [content=2*padding+labelLen] [border=1]\n  const colWidths = [1, 2 * padding + node.displayLabel.length, 1]\n  // 3 rows: [border=1] [content=1+2*padding] [border=1]\n  const rowHeights = [1, 1 + 2 * padding, 1]\n\n  for (let idx = 0; idx < colWidths.length; idx++) {\n    const xCoord = gc.x + idx\n    const current = graph.columnWidth.get(xCoord) ?? 0\n    graph.columnWidth.set(xCoord, Math.max(current, colWidths[idx]!))\n  }\n\n  for (let idx = 0; idx < rowHeights.length; idx++) {\n    const yCoord = gc.y + idx\n    const current = graph.rowHeight.get(yCoord) ?? 0\n    graph.rowHeight.set(yCoord, Math.max(current, rowHeights[idx]!))\n  }\n\n  // Padding column/row before the node (spacing between nodes)\n  if (gc.x > 0) {\n    const current = graph.columnWidth.get(gc.x - 1) ?? 0\n    graph.columnWidth.set(gc.x - 1, Math.max(current, graph.config.paddingX))\n  }\n\n  if (gc.y > 0) {\n    let basePadding = graph.config.paddingY\n    // Extra vertical padding for nodes with incoming edges from outside their subgraph\n    if (hasIncomingEdgeFromOutsideSubgraph(graph, node)) {\n      const subgraphOverhead = 4\n      basePadding += subgraphOverhead\n    }\n    const current = graph.rowHeight.get(gc.y - 1) ?? 0\n    graph.rowHeight.set(gc.y - 1, Math.max(current, basePadding))\n  }\n}\n\n/** Ensure grid has width/height entries for all cells along an edge path. */\nexport function increaseGridSizeForPath(graph: AsciiGraph, path: GridCoord[]): void {\n  for (const c of path) {\n    if (!graph.columnWidth.has(c.x)) {\n      graph.columnWidth.set(c.x, Math.floor(graph.config.paddingX / 2))\n    }\n    if (!graph.rowHeight.has(c.y)) {\n      graph.rowHeight.set(c.y, Math.floor(graph.config.paddingY / 2))\n    }\n  }\n}\n\n// ============================================================================\n// Subgraph helpers\n// ============================================================================\n\nfunction isNodeInAnySubgraph(graph: AsciiGraph, node: AsciiNode): boolean {\n  return graph.subgraphs.some(sg => sg.nodes.includes(node))\n}\n\nfunction getNodeSubgraph(graph: AsciiGraph, node: AsciiNode): AsciiSubgraph | null {\n  for (const sg of graph.subgraphs) {\n    if (sg.nodes.includes(node)) return sg\n  }\n  return null\n}\n\n/**\n * Check if a node has an incoming edge from outside its subgraph\n * AND is the topmost such node in its subgraph.\n * Used to add extra vertical padding for subgraph borders.\n */\nfunction hasIncomingEdgeFromOutsideSubgraph(graph: AsciiGraph, node: AsciiNode): boolean {\n  const nodeSg = getNodeSubgraph(graph, node)\n  if (!nodeSg) return false\n\n  let hasExternalEdge = false\n  for (const edge of graph.edges) {\n    if (edge.to === node) {\n      const sourceSg = getNodeSubgraph(graph, edge.from)\n      if (sourceSg !== nodeSg) {\n        hasExternalEdge = true\n        break\n      }\n    }\n  }\n\n  if (!hasExternalEdge) return false\n\n  // Only return true for the topmost node with an external incoming edge\n  for (const otherNode of nodeSg.nodes) {\n    if (otherNode === node || !otherNode.gridCoord) continue\n    let otherHasExternal = false\n    for (const edge of graph.edges) {\n      if (edge.to === otherNode) {\n        const sourceSg = getNodeSubgraph(graph, edge.from)\n        if (sourceSg !== nodeSg) {\n          otherHasExternal = true\n          break\n        }\n      }\n    }\n    if (otherHasExternal && otherNode.gridCoord.y < node.gridCoord!.y) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// ============================================================================\n// Subgraph bounding boxes\n// ============================================================================\n\nfunction calculateSubgraphBoundingBox(graph: AsciiGraph, sg: AsciiSubgraph): void {\n  if (sg.nodes.length === 0) return\n\n  let minX = 1_000_000\n  let minY = 1_000_000\n  let maxX = -1_000_000\n  let maxY = -1_000_000\n\n  // Include children's bounding boxes\n  for (const child of sg.children) {\n    calculateSubgraphBoundingBox(graph, child)\n    if (child.nodes.length > 0) {\n      minX = Math.min(minX, child.minX)\n      minY = Math.min(minY, child.minY)\n      maxX = Math.max(maxX, child.maxX)\n      maxY = Math.max(maxY, child.maxY)\n    }\n  }\n\n  // Include node positions\n  for (const node of sg.nodes) {\n    if (!node.drawingCoord || !node.drawing) continue\n    const nodeMinX = node.drawingCoord.x\n    const nodeMinY = node.drawingCoord.y\n    const nodeMaxX = nodeMinX + node.drawing.length - 1\n    const nodeMaxY = nodeMinY + node.drawing[0]!.length - 1\n    minX = Math.min(minX, nodeMinX)\n    minY = Math.min(minY, nodeMinY)\n    maxX = Math.max(maxX, nodeMaxX)\n    maxY = Math.max(maxY, nodeMaxY)\n  }\n\n  const subgraphPadding = 2\n  const subgraphLabelSpace = 2\n  sg.minX = minX - subgraphPadding\n  sg.minY = minY - subgraphPadding - subgraphLabelSpace\n  sg.maxX = maxX + subgraphPadding\n  sg.maxY = maxY + subgraphPadding\n}\n\n/** Ensure non-overlapping root subgraphs have minimum spacing. */\nfunction ensureSubgraphSpacing(graph: AsciiGraph): void {\n  const minSpacing = 1\n  const rootSubgraphs = graph.subgraphs.filter(sg => sg.parent === null && sg.nodes.length > 0)\n\n  for (let i = 0; i < rootSubgraphs.length; i++) {\n    for (let j = i + 1; j < rootSubgraphs.length; j++) {\n      const sg1 = rootSubgraphs[i]!\n      const sg2 = rootSubgraphs[j]!\n\n      // Horizontal overlap  adjust vertical\n      if (sg1.minX < sg2.maxX && sg1.maxX > sg2.minX) {\n        if (sg1.maxY >= sg2.minY - minSpacing && sg1.minY < sg2.minY) {\n          sg2.minY = sg1.maxY + minSpacing + 1\n        } else if (sg2.maxY >= sg1.minY - minSpacing && sg2.minY < sg1.minY) {\n          sg1.minY = sg2.maxY + minSpacing + 1\n        }\n      }\n      // Vertical overlap  adjust horizontal\n      if (sg1.minY < sg2.maxY && sg1.maxY > sg2.minY) {\n        if (sg1.maxX >= sg2.minX - minSpacing && sg1.minX < sg2.minX) {\n          sg2.minX = sg1.maxX + minSpacing + 1\n        } else if (sg2.maxX >= sg1.minX - minSpacing && sg2.minX < sg1.minX) {\n          sg1.minX = sg2.maxX + minSpacing + 1\n        }\n      }\n    }\n  }\n}\n\nexport function calculateSubgraphBoundingBoxes(graph: AsciiGraph): void {\n  for (const sg of graph.subgraphs) {\n    calculateSubgraphBoundingBox(graph, sg)\n  }\n  ensureSubgraphSpacing(graph)\n}\n\n/**\n * Offset all drawing coordinates so subgraph borders don't go negative.\n * If any subgraph has negative min coordinates, shift everything positive.\n */\nexport function offsetDrawingForSubgraphs(graph: AsciiGraph): void {\n  if (graph.subgraphs.length === 0) return\n\n  let minX = 0\n  let minY = 0\n  for (const sg of graph.subgraphs) {\n    minX = Math.min(minX, sg.minX)\n    minY = Math.min(minY, sg.minY)\n  }\n\n  const offsetX = -minX\n  const offsetY = -minY\n  if (offsetX === 0 && offsetY === 0) return\n\n  graph.offsetX = offsetX\n  graph.offsetY = offsetY\n\n  for (const sg of graph.subgraphs) {\n    sg.minX += offsetX\n    sg.minY += offsetY\n    sg.maxX += offsetX\n    sg.maxY += offsetY\n  }\n\n  for (const node of graph.nodes) {\n    if (node.drawingCoord) {\n      node.drawingCoord.x += offsetX\n      node.drawingCoord.y += offsetY\n    }\n  }\n}\n\n// ============================================================================\n// Main layout orchestrator\n// ============================================================================\n\n/**\n * createMapping performs the full grid layout:\n * 1. Place root nodes on the grid\n * 2. Place child nodes level by level\n * 3. Compute column widths and row heights\n * 4. Run A* pathfinding for all edges\n * 5. Determine label placement\n * 6. Convert grid coords  drawing coords\n * 7. Generate node box drawings\n * 8. Calculate subgraph bounding boxes\n */\nexport function createMapping(graph: AsciiGraph): void {\n  const dir = graph.config.graphDirection\n  const highestPositionPerLevel: number[] = new Array(100).fill(0)\n\n  // Identify root nodes  nodes that aren't the target of any edge\n  const nodesFound = new Set<string>()\n  const rootNodes: AsciiNode[] = []\n\n  for (const node of graph.nodes) {\n    if (!nodesFound.has(node.name)) {\n      rootNodes.push(node)\n    }\n    nodesFound.add(node.name)\n    for (const child of getChildren(graph, node)) {\n      nodesFound.add(child.name)\n    }\n  }\n\n  // In LR mode with both external and subgraph roots, separate them\n  // so subgraph roots are placed one level deeper\n  let hasExternalRoots = false\n  let hasSubgraphRootsWithEdges = false\n  for (const node of rootNodes) {\n    if (isNodeInAnySubgraph(graph, node)) {\n      if (getChildren(graph, node).length > 0) hasSubgraphRootsWithEdges = true\n    } else {\n      hasExternalRoots = true\n    }\n  }\n  const shouldSeparate = dir === 'LR' && hasExternalRoots && hasSubgraphRootsWithEdges\n\n  let externalRootNodes: AsciiNode[]\n  let subgraphRootNodes: AsciiNode[] = []\n\n  if (shouldSeparate) {\n    externalRootNodes = rootNodes.filter(n => !isNodeInAnySubgraph(graph, n))\n    subgraphRootNodes = rootNodes.filter(n => isNodeInAnySubgraph(graph, n))\n  } else {\n    externalRootNodes = rootNodes\n  }\n\n  // Place external root nodes\n  for (const node of externalRootNodes) {\n    const requested: GridCoord = dir === 'LR'\n      ? { x: 0, y: highestPositionPerLevel[0]! }\n      : { x: highestPositionPerLevel[0]!, y: 0 }\n    reserveSpotInGrid(graph, graph.nodes[node.index]!, requested)\n    highestPositionPerLevel[0] = highestPositionPerLevel[0]! + 4\n  }\n\n  // Place subgraph root nodes at level 4 (one level in from the edge)\n  if (shouldSeparate && subgraphRootNodes.length > 0) {\n    const subgraphLevel = 4\n    for (const node of subgraphRootNodes) {\n      const requested: GridCoord = dir === 'LR'\n        ? { x: subgraphLevel, y: highestPositionPerLevel[subgraphLevel]! }\n        : { x: highestPositionPerLevel[subgraphLevel]!, y: subgraphLevel }\n      reserveSpotInGrid(graph, graph.nodes[node.index]!, requested)\n      highestPositionPerLevel[subgraphLevel] = highestPositionPerLevel[subgraphLevel]! + 4\n    }\n  }\n\n  // Place child nodes level by level\n  for (const node of graph.nodes) {\n    const gc = node.gridCoord!\n    const childLevel = dir === 'LR' ? gc.x + 4 : gc.y + 4\n    let highestPosition = highestPositionPerLevel[childLevel]!\n\n    for (const child of getChildren(graph, node)) {\n      if (child.gridCoord !== null) continue // already placed\n\n      const requested: GridCoord = dir === 'LR'\n        ? { x: childLevel, y: highestPosition }\n        : { x: highestPosition, y: childLevel }\n      reserveSpotInGrid(graph, graph.nodes[child.index]!, requested)\n      highestPositionPerLevel[childLevel] = highestPosition + 4\n      highestPosition = highestPositionPerLevel[childLevel]!\n    }\n  }\n\n  // Compute column widths and row heights\n  for (const node of graph.nodes) {\n    setColumnWidth(graph, node)\n  }\n\n  // Route edges via A* and determine label positions\n  for (const edge of graph.edges) {\n    determinePath(graph, edge)\n    increaseGridSizeForPath(graph, edge.path)\n    determineLabelLine(graph, edge)\n  }\n\n  // Convert grid coords  drawing coords and generate box drawings\n  for (const node of graph.nodes) {\n    node.drawingCoord = gridToDrawingCoord(graph, node.gridCoord!)\n    node.drawing = drawBox(node, graph)\n  }\n\n  // Set canvas size and compute subgraph bounding boxes\n  setCanvasSizeToGrid(graph.canvas, graph.columnWidth, graph.rowHeight)\n  calculateSubgraphBoundingBoxes(graph)\n  offsetDrawingForSubgraphs(graph)\n}\n\n// ============================================================================\n// Graph traversal helpers\n// ============================================================================\n\n/** Get all edges originating from a node. */\nfunction getEdgesFromNode(graph: AsciiGraph, node: AsciiNode): AsciiGraph['edges'] {\n  return graph.edges.filter(e => e.from.name === node.name)\n}\n\n/** Get all direct children of a node (targets of outgoing edges). */\nfunction getChildren(graph: AsciiGraph, node: AsciiNode): AsciiNode[] {\n  return getEdgesFromNode(graph, node).map(e => e.to)\n}\n","import type { SequenceDiagram, Actor, Message, Block, Note } from './types.ts'\n\n// ============================================================================\n// Sequence diagram parser\n//\n// Parses Mermaid sequenceDiagram syntax into a SequenceDiagram structure.\n//\n// Supported syntax:\n//   participant A as Alice\n//   actor B as Bob\n//   A->>B: Solid arrow\n//   A-->>B: Dashed arrow\n//   A-)B: Open arrow\n//   A--)B: Dashed open arrow\n//   A->>+B: Activate target\n//   A-->>-B: Deactivate source\n//   loop Label ... end\n//   alt Label ... else Label ... end\n//   opt Label ... end\n//   par Label ... and Label ... end\n//   Note left of A: Text\n//   Note right of A: Text\n//   Note over A,B: Text\n// ============================================================================\n\n/**\n * Parse a Mermaid sequence diagram.\n * Expects the first line to be \"sequenceDiagram\".\n */\nexport function parseSequenceDiagram(lines: string[]): SequenceDiagram {\n  const diagram: SequenceDiagram = {\n    actors: [],\n    messages: [],\n    blocks: [],\n    notes: [],\n  }\n\n  // Track actor IDs to auto-create actors referenced in messages\n  const actorIds = new Set<string>()\n  // Track block nesting with a stack\n  const blockStack: Array<{ type: Block['type']; label: string; startIndex: number; dividers: Block['dividers'] }> = []\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!\n\n    // --- Participant / Actor declaration ---\n    // \"participant A as Alice\" or \"participant Alice\"\n    // \"actor B as Bob\" or \"actor Bob\"\n    const actorMatch = line.match(/^(participant|actor)\\s+(\\S+?)(?:\\s+as\\s+(.+))?$/)\n    if (actorMatch) {\n      const type = actorMatch[1] as 'participant' | 'actor'\n      const id = actorMatch[2]!\n      const label = actorMatch[3]?.trim() ?? id\n      if (!actorIds.has(id)) {\n        actorIds.add(id)\n        diagram.actors.push({ id, label, type })\n      }\n      continue\n    }\n\n    // --- Note ---\n    // \"Note left of A: text\" / \"Note right of A: text\" / \"Note over A,B: text\"\n    const noteMatch = line.match(/^Note\\s+(left of|right of|over)\\s+([^:]+):\\s*(.+)$/i)\n    if (noteMatch) {\n      const posStr = noteMatch[1]!.toLowerCase()\n      const actorsStr = noteMatch[2]!.trim()\n      const text = noteMatch[3]!.trim()\n      const noteActorIds = actorsStr.split(',').map(s => s.trim())\n\n      // Ensure actors exist\n      for (const aid of noteActorIds) {\n        ensureActor(diagram, actorIds, aid)\n      }\n\n      let position: 'left' | 'right' | 'over' = 'over'\n      if (posStr === 'left of') position = 'left'\n      else if (posStr === 'right of') position = 'right'\n\n      diagram.notes.push({\n        actorIds: noteActorIds,\n        text,\n        position,\n        afterIndex: diagram.messages.length - 1,\n      })\n      continue\n    }\n\n    // --- Block start: loop, alt, opt, par, critical, break, rect ---\n    const blockMatch = line.match(/^(loop|alt|opt|par|critical|break|rect)\\s*(.*)$/)\n    if (blockMatch) {\n      const blockType = blockMatch[1] as Block['type']\n      const label = blockMatch[2]?.trim() ?? ''\n      blockStack.push({\n        type: blockType,\n        label,\n        startIndex: diagram.messages.length,\n        dividers: [],\n      })\n      continue\n    }\n\n    // --- Block divider: else, and ---\n    const dividerMatch = line.match(/^(else|and)\\s*(.*)$/)\n    if (dividerMatch && blockStack.length > 0) {\n      const label = dividerMatch[2]?.trim() ?? ''\n      blockStack[blockStack.length - 1]!.dividers.push({\n        index: diagram.messages.length,\n        label,\n      })\n      continue\n    }\n\n    // --- Block end ---\n    if (line === 'end' && blockStack.length > 0) {\n      const completed = blockStack.pop()!\n      diagram.blocks.push({\n        type: completed.type,\n        label: completed.label,\n        startIndex: completed.startIndex,\n        endIndex: Math.max(diagram.messages.length - 1, completed.startIndex),\n        dividers: completed.dividers,\n      })\n      continue\n    }\n\n    // --- Message ---\n    // Patterns: A->>B, A-->>B, A-)B, A--)B, with optional +/- activation\n    // Format: FROM ARROW TO: LABEL\n    const msgMatch = line.match(\n      /^(\\S+?)\\s*(--?>?>|--?[)x]|--?>>|--?>)\\s*([+-]?)(\\S+?)\\s*:\\s*(.+)$/\n    )\n    if (msgMatch) {\n      const from = msgMatch[1]!\n      const arrow = msgMatch[2]!\n      const activationMark = msgMatch[3]\n      const to = msgMatch[4]!\n      const label = msgMatch[5]!.trim()\n\n      // Ensure both actors exist\n      ensureActor(diagram, actorIds, from)\n      ensureActor(diagram, actorIds, to)\n\n      // Determine line style and arrow head from the arrow operator\n      const lineStyle = arrow.startsWith('--') ? 'dashed' : 'solid'\n      // \">>\" = filled arrow, \")\" or \">\" alone = open arrow, \"x\" = cross (treat as filled)\n      const arrowHead = arrow.includes('>>') || arrow.includes('x') ? 'filled' : 'open'\n\n      const msg: Message = {\n        from,\n        to,\n        label,\n        lineStyle,\n        arrowHead,\n      }\n\n      // Activation/deactivation via +/- prefix on target\n      if (activationMark === '+') msg.activate = true\n      if (activationMark === '-') msg.deactivate = true\n\n      diagram.messages.push(msg)\n      continue\n    }\n\n    // --- Simplified message format: A->>B: Label (fallback with more relaxed regex) ---\n    const simpleMsgMatch = line.match(\n      /^(\\S+?)\\s*(->>|-->>|-\\)|--\\)|-x|--x|->|-->)\\s*([+-]?)(\\S+?)\\s*:\\s*(.+)$/\n    )\n    if (simpleMsgMatch) {\n      const from = simpleMsgMatch[1]!\n      const arrow = simpleMsgMatch[2]!\n      const activationMark = simpleMsgMatch[3]\n      const to = simpleMsgMatch[4]!\n      const label = simpleMsgMatch[5]!.trim()\n\n      ensureActor(diagram, actorIds, from)\n      ensureActor(diagram, actorIds, to)\n\n      const lineStyle = arrow.startsWith('--') ? 'dashed' : 'solid'\n      const arrowHead = arrow.includes('>>') || arrow.includes('x') ? 'filled' : 'open'\n\n      const msg: Message = { from, to, label, lineStyle, arrowHead }\n      if (activationMark === '+') msg.activate = true\n      if (activationMark === '-') msg.deactivate = true\n\n      diagram.messages.push(msg)\n      continue\n    }\n\n    // --- activate / deactivate explicit commands ---\n    // These are handled implicitly via +/- on messages but can also appear standalone\n    // For now, we skip explicit activate/deactivate lines (they affect rendering only)\n  }\n\n  return diagram\n}\n\n/** Ensure an actor exists, creating a default participant if not */\nfunction ensureActor(diagram: SequenceDiagram, actorIds: Set<string>, id: string): void {\n  if (!actorIds.has(id)) {\n    actorIds.add(id)\n    diagram.actors.push({ id, label: id, type: 'participant' })\n  }\n}\n","// ============================================================================\n// ASCII renderer  sequence diagrams\n//\n// Renders sequenceDiagram text to ASCII/Unicode art using a column-based layout.\n// Each actor occupies a column with a vertical lifeline; messages are horizontal\n// arrows between lifelines. Blocks (loop/alt/opt/par) wrap around message groups.\n//\n// Layout is fundamentally different from flowcharts  no grid or A* pathfinding.\n// Instead: actors  columns, messages  rows, all positioned linearly.\n// ============================================================================\n\nimport { parseSequenceDiagram } from '../sequence/parser.ts'\nimport type { SequenceDiagram, Block } from '../sequence/types.ts'\nimport type { Canvas, AsciiConfig } from './types.ts'\nimport { mkCanvas, canvasToString, increaseSize } from './canvas.ts'\n\n/**\n * Render a Mermaid sequence diagram to ASCII/Unicode text.\n *\n * Pipeline: parse  layout (columns + rows)  draw onto canvas  string.\n */\nexport function renderSequenceAscii(text: string, config: AsciiConfig): string {\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('%%'))\n  const diagram = parseSequenceDiagram(lines)\n\n  if (diagram.actors.length === 0) return ''\n\n  const useAscii = config.useAscii\n\n  // Box-drawing characters\n  const H = useAscii ? '-' : ''\n  const V = useAscii ? '|' : ''\n  const TL = useAscii ? '+' : ''\n  const TR = useAscii ? '+' : ''\n  const BL = useAscii ? '+' : ''\n  const BR = useAscii ? '+' : ''\n  const JT = useAscii ? '+' : '' // top junction on lifeline\n  const JB = useAscii ? '+' : '' // bottom junction on lifeline\n  const JL = useAscii ? '+' : '' // left junction\n  const JR = useAscii ? '+' : '' // right junction\n\n  // ---- LAYOUT: compute lifeline X positions ----\n\n  const actorIdx = new Map<string, number>()\n  diagram.actors.forEach((a, i) => actorIdx.set(a.id, i))\n\n  const boxPad = 1\n  const actorBoxWidths = diagram.actors.map(a => a.label.length + 2 * boxPad + 2)\n  const halfBox = actorBoxWidths.map(w => Math.ceil(w / 2))\n  const actorBoxH = 3 // top border + label row + bottom border\n\n  // Compute minimum gap between adjacent lifelines based on message labels.\n  // For messages spanning multiple actors, distribute the required width across gaps.\n  const adjMaxWidth: number[] = new Array(Math.max(diagram.actors.length - 1, 0)).fill(0)\n\n  for (const msg of diagram.messages) {\n    const fi = actorIdx.get(msg.from)!\n    const ti = actorIdx.get(msg.to)!\n    if (fi === ti) continue // self-messages don't affect spacing\n    const lo = Math.min(fi, ti)\n    const hi = Math.max(fi, ti)\n    // Required gap per span = (label + arrow decorations) / number of gaps\n    const needed = msg.label.length + 4\n    const numGaps = hi - lo\n    const perGap = Math.ceil(needed / numGaps)\n    for (let g = lo; g < hi; g++) {\n      adjMaxWidth[g] = Math.max(adjMaxWidth[g]!, perGap)\n    }\n  }\n\n  // Compute lifeline x-positions (greedy left-to-right)\n  const llX: number[] = [halfBox[0]!]\n  for (let i = 1; i < diagram.actors.length; i++) {\n    const gap = Math.max(\n      halfBox[i - 1]! + halfBox[i]! + 2,\n      adjMaxWidth[i - 1]! + 2,\n      10,\n    )\n    llX[i] = llX[i - 1]! + gap\n  }\n\n  // ---- LAYOUT: compute vertical positions for messages ----\n\n  // For each message index, track the y where its arrow is drawn.\n  // Also track block start/end y positions and divider y positions.\n  const msgArrowY: number[] = []\n  const msgLabelY: number[] = []\n  const blockStartY = new Map<number, number>()\n  const blockEndY = new Map<number, number>()\n  const divYMap = new Map<string, number>() // \"blockIdx:divIdx\"  y\n  const notePositions: Array<{ x: number; y: number; width: number; height: number; lines: string[] }> = []\n\n  let curY = actorBoxH // start right below header boxes\n\n  for (let m = 0; m < diagram.messages.length; m++) {\n    // Block openings at this message\n    for (let b = 0; b < diagram.blocks.length; b++) {\n      if (diagram.blocks[b]!.startIndex === m) {\n        curY += 2 // 1 blank + 1 header row\n        blockStartY.set(b, curY - 1)\n      }\n    }\n\n    // Dividers at this message index\n    for (let b = 0; b < diagram.blocks.length; b++) {\n      for (let d = 0; d < diagram.blocks[b]!.dividers.length; d++) {\n        if (diagram.blocks[b]!.dividers[d]!.index === m) {\n          curY += 1\n          divYMap.set(`${b}:${d}`, curY)\n          curY += 1\n        }\n      }\n    }\n\n    curY += 1 // blank row before message\n\n    const msg = diagram.messages[m]!\n    const isSelf = msg.from === msg.to\n\n    if (isSelf) {\n      // Self-message occupies 3 rows: top-arm, label-col, bottom-arm\n      msgLabelY[m] = curY + 1\n      msgArrowY[m] = curY\n      curY += 3\n    } else {\n      // Normal message: label row then arrow row\n      msgLabelY[m] = curY\n      msgArrowY[m] = curY + 1\n      curY += 2\n    }\n\n    // Notes after this message\n    for (let n = 0; n < diagram.notes.length; n++) {\n      if (diagram.notes[n]!.afterIndex === m) {\n        curY += 1\n        const note = diagram.notes[n]!\n        const nLines = note.text.split('\\\\n')\n        const nWidth = Math.max(...nLines.map(l => l.length)) + 4\n        const nHeight = nLines.length + 2\n\n        // Determine x position based on note.position\n        const aIdx = actorIdx.get(note.actorIds[0]!) ?? 0\n        let nx: number\n        if (note.position === 'left') {\n          nx = llX[aIdx]! - nWidth - 1\n        } else if (note.position === 'right') {\n          nx = llX[aIdx]! + 2\n        } else {\n          // 'over'  center over actor(s)\n          if (note.actorIds.length >= 2) {\n            const aIdx2 = actorIdx.get(note.actorIds[1]!) ?? aIdx\n            nx = Math.floor((llX[aIdx]! + llX[aIdx2]!) / 2) - Math.floor(nWidth / 2)\n          } else {\n            nx = llX[aIdx]! - Math.floor(nWidth / 2)\n          }\n        }\n        nx = Math.max(0, nx)\n\n        notePositions.push({ x: nx, y: curY, width: nWidth, height: nHeight, lines: nLines })\n        curY += nHeight\n      }\n    }\n\n    // Block closings after this message\n    for (let b = 0; b < diagram.blocks.length; b++) {\n      if (diagram.blocks[b]!.endIndex === m) {\n        curY += 1\n        blockEndY.set(b, curY)\n        curY += 1\n      }\n    }\n  }\n\n  curY += 1 // gap before footer\n  const footerY = curY\n  const totalH = footerY + actorBoxH\n\n  // Total canvas width\n  const lastLL = llX[llX.length - 1] ?? 0\n  const lastHalf = halfBox[halfBox.length - 1] ?? 0\n  let totalW = lastLL + lastHalf + 2\n\n  // Ensure canvas is wide enough for self-message labels and notes\n  for (let m = 0; m < diagram.messages.length; m++) {\n    const msg = diagram.messages[m]!\n    if (msg.from === msg.to) {\n      const fi = actorIdx.get(msg.from)!\n      const selfRight = llX[fi]! + 6 + 2 + msg.label.length\n      totalW = Math.max(totalW, selfRight + 1)\n    }\n  }\n  for (const np of notePositions) {\n    totalW = Math.max(totalW, np.x + np.width + 1)\n  }\n\n  const canvas = mkCanvas(totalW, totalH - 1)\n\n  // ---- DRAW: helper to place a bordered actor box ----\n\n  function drawActorBox(cx: number, topY: number, label: string): void {\n    const w = label.length + 2 * boxPad + 2\n    const left = cx - Math.floor(w / 2)\n    // Top border\n    canvas[left]![topY] = TL\n    for (let x = 1; x < w - 1; x++) canvas[left + x]![topY] = H\n    canvas[left + w - 1]![topY] = TR\n    // Sides + label\n    canvas[left]![topY + 1] = V\n    canvas[left + w - 1]![topY + 1] = V\n    const ls = left + 1 + boxPad\n    for (let i = 0; i < label.length; i++) canvas[ls + i]![topY + 1] = label[i]!\n    // Bottom border\n    canvas[left]![topY + 2] = BL\n    for (let x = 1; x < w - 1; x++) canvas[left + x]![topY + 2] = H\n    canvas[left + w - 1]![topY + 2] = BR\n  }\n\n  // ---- DRAW: lifelines ----\n\n  for (let i = 0; i < diagram.actors.length; i++) {\n    const x = llX[i]!\n    for (let y = actorBoxH; y <= footerY; y++) {\n      canvas[x]![y] = V\n    }\n  }\n\n  // ---- DRAW: actor header + footer boxes (drawn over lifelines) ----\n\n  for (let i = 0; i < diagram.actors.length; i++) {\n    const actor = diagram.actors[i]!\n    drawActorBox(llX[i]!, 0, actor.label)\n    drawActorBox(llX[i]!, footerY, actor.label)\n\n    // Lifeline junctions on box borders (Unicode only)\n    if (!useAscii) {\n      canvas[llX[i]!]![actorBoxH - 1] = JT // bottom of header  \n      canvas[llX[i]!]![footerY] = JB        // top of footer  \n    }\n  }\n\n  // ---- DRAW: messages ----\n\n  for (let m = 0; m < diagram.messages.length; m++) {\n    const msg = diagram.messages[m]!\n    const fi = actorIdx.get(msg.from)!\n    const ti = actorIdx.get(msg.to)!\n    const fromX = llX[fi]!\n    const toX = llX[ti]!\n    const isSelf = fi === ti\n    const isDashed = msg.lineStyle === 'dashed'\n    const isFilled = msg.arrowHead === 'filled'\n\n    // Arrow line character (solid vs dashed)\n    const lineChar = isDashed ? (useAscii ? '.' : '') : H\n\n    if (isSelf) {\n      // Self-message: 3-row loop to the right of the lifeline\n      //              (row 0 = msgArrowY)\n      //      Label     (row 1)\n      //              (row 2)\n      const y0 = msgArrowY[m]!\n      const loopW = Math.max(4, 4)\n\n      // Row 0: start junction + horizontal + top-right corner\n      canvas[fromX]![y0] = JL\n      for (let x = fromX + 1; x < fromX + loopW; x++) canvas[x]![y0] = lineChar\n      canvas[fromX + loopW]![y0] = useAscii ? '+' : ''\n\n      // Row 1: vertical on right side + label\n      canvas[fromX + loopW]![y0 + 1] = V\n      const labelX = fromX + loopW + 2\n      for (let i = 0; i < msg.label.length; i++) {\n        if (labelX + i < totalW) canvas[labelX + i]![y0 + 1] = msg.label[i]!\n      }\n\n      // Row 2: arrow-back + horizontal + bottom-right corner\n      const arrowChar = isFilled ? (useAscii ? '<' : '') : (useAscii ? '<' : '')\n      canvas[fromX]![y0 + 2] = arrowChar\n      for (let x = fromX + 1; x < fromX + loopW; x++) canvas[x]![y0 + 2] = lineChar\n      canvas[fromX + loopW]![y0 + 2] = useAscii ? '+' : ''\n    } else {\n      // Normal message: label on row above, arrow on row below\n      const labelY = msgLabelY[m]!\n      const arrowY = msgArrowY[m]!\n      const leftToRight = fromX < toX\n\n      // Draw label centered between the two lifelines\n      const midX = Math.floor((fromX + toX) / 2)\n      const labelStart = midX - Math.floor(msg.label.length / 2)\n      for (let i = 0; i < msg.label.length; i++) {\n        const lx = labelStart + i\n        if (lx >= 0 && lx < totalW) canvas[lx]![labelY] = msg.label[i]!\n      }\n\n      // Draw arrow line\n      if (leftToRight) {\n        for (let x = fromX + 1; x < toX; x++) canvas[x]![arrowY] = lineChar\n        // Arrowhead at destination\n        const ah = isFilled ? (useAscii ? '>' : '') : (useAscii ? '>' : '')\n        canvas[toX]![arrowY] = ah\n      } else {\n        for (let x = toX + 1; x < fromX; x++) canvas[x]![arrowY] = lineChar\n        const ah = isFilled ? (useAscii ? '<' : '') : (useAscii ? '<' : '')\n        canvas[toX]![arrowY] = ah\n      }\n    }\n  }\n\n  // ---- DRAW: blocks (loop, alt, opt, par, etc.) ----\n\n  for (let b = 0; b < diagram.blocks.length; b++) {\n    const block = diagram.blocks[b]!\n    const topY = blockStartY.get(b)\n    const botY = blockEndY.get(b)\n    if (topY === undefined || botY === undefined) continue\n\n    // Find the leftmost/rightmost lifelines involved in this block's messages\n    let minLX = totalW\n    let maxLX = 0\n    for (let m = block.startIndex; m <= block.endIndex; m++) {\n      if (m >= diagram.messages.length) break\n      const msg = diagram.messages[m]!\n      const f = actorIdx.get(msg.from) ?? 0\n      const t = actorIdx.get(msg.to) ?? 0\n      minLX = Math.min(minLX, llX[Math.min(f, t)]!)\n      maxLX = Math.max(maxLX, llX[Math.max(f, t)]!)\n    }\n\n    const bLeft = Math.max(0, minLX - 4)\n    const bRight = Math.min(totalW - 1, maxLX + 4)\n\n    // Top border with block type label\n    canvas[bLeft]![topY] = TL\n    for (let x = bLeft + 1; x < bRight; x++) canvas[x]![topY] = H\n    canvas[bRight]![topY] = TR\n    // Write block header label over the top border\n    const hdrLabel = block.label ? `${block.type} [${block.label}]` : block.type\n    for (let i = 0; i < hdrLabel.length && bLeft + 1 + i < bRight; i++) {\n      canvas[bLeft + 1 + i]![topY] = hdrLabel[i]!\n    }\n\n    // Bottom border\n    canvas[bLeft]![botY] = BL\n    for (let x = bLeft + 1; x < bRight; x++) canvas[x]![botY] = H\n    canvas[bRight]![botY] = BR\n\n    // Side borders\n    for (let y = topY + 1; y < botY; y++) {\n      canvas[bLeft]![y] = V\n      canvas[bRight]![y] = V\n    }\n\n    // Dividers\n    for (let d = 0; d < block.dividers.length; d++) {\n      const dY = divYMap.get(`${b}:${d}`)\n      if (dY === undefined) continue\n      const dashChar = isDashedH()\n      canvas[bLeft]![dY] = JL\n      for (let x = bLeft + 1; x < bRight; x++) canvas[x]![dY] = dashChar\n      canvas[bRight]![dY] = JR\n      // Divider label\n      const dLabel = block.dividers[d]!.label\n      if (dLabel) {\n        const dStr = `[${dLabel}]`\n        for (let i = 0; i < dStr.length && bLeft + 1 + i < bRight; i++) {\n          canvas[bLeft + 1 + i]![dY] = dStr[i]!\n        }\n      }\n    }\n  }\n\n  // ---- DRAW: notes ----\n\n  for (const np of notePositions) {\n    // Ensure canvas is big enough\n    increaseSize(canvas, np.x + np.width, np.y + np.height)\n    // Top border\n    canvas[np.x]![np.y] = TL\n    for (let x = 1; x < np.width - 1; x++) canvas[np.x + x]![np.y] = H\n    canvas[np.x + np.width - 1]![np.y] = TR\n    // Content rows\n    for (let l = 0; l < np.lines.length; l++) {\n      const ly = np.y + 1 + l\n      canvas[np.x]![ly] = V\n      canvas[np.x + np.width - 1]![ly] = V\n      for (let i = 0; i < np.lines[l]!.length; i++) {\n        canvas[np.x + 2 + i]![ly] = np.lines[l]![i]!\n      }\n    }\n    // Bottom border\n    const by = np.y + np.height - 1\n    canvas[np.x]![by] = BL\n    for (let x = 1; x < np.width - 1; x++) canvas[np.x + x]![by] = H\n    canvas[np.x + np.width - 1]![by] = BR\n  }\n\n  return canvasToString(canvas)\n\n  // ---- Helper: dashed horizontal character ----\n  function isDashedH(): string {\n    return useAscii ? '-' : ''\n  }\n}\n","import type { ClassDiagram, ClassNode, ClassRelationship, ClassMember, RelationshipType, ClassNamespace } from './types.ts'\n\n// ============================================================================\n// Class diagram parser\n//\n// Parses Mermaid classDiagram syntax into a ClassDiagram structure.\n//\n// Supported syntax:\n//   class Animal { +String name; +eat() void }\n//   class Shape { <<abstract>> }\n//   Animal <|-- Dog           (inheritance)\n//   Car *-- Engine            (composition)\n//   Car o-- Wheel             (aggregation)\n//   A --> B                   (association)\n//   A ..> B                   (dependency)\n//   A ..|> B                  (realization)\n//   A \"1\" --> \"*\" B : label   (with cardinality + label)\n//   Animal : +String name     (inline attribute)\n//   namespace MyNamespace { class A { } }\n// ============================================================================\n\n/**\n * Parse a Mermaid class diagram.\n * Expects the first line to be \"classDiagram\".\n */\nexport function parseClassDiagram(lines: string[]): ClassDiagram {\n  const diagram: ClassDiagram = {\n    classes: [],\n    relationships: [],\n    namespaces: [],\n  }\n\n  // Track classes by ID for deduplication\n  const classMap = new Map<string, ClassNode>()\n  // Track namespace nesting\n  let currentNamespace: ClassNamespace | null = null\n  // Track class body parsing\n  let currentClass: ClassNode | null = null\n  let braceDepth = 0\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!\n\n    // --- Inside a class body block ---\n    if (currentClass && braceDepth > 0) {\n      if (line === '}') {\n        braceDepth--\n        if (braceDepth === 0) {\n          currentClass = null\n        }\n        continue\n      }\n\n      // Check for annotation like <<interface>>\n      const annotMatch = line.match(/^<<(\\w+)>>$/)\n      if (annotMatch) {\n        currentClass.annotation = annotMatch[1]!\n        continue\n      }\n\n      // Parse member: visibility, name, type, optional parens for method\n      const member = parseMember(line)\n      if (member) {\n        if (member.isMethod) {\n          currentClass.methods.push(member.member)\n        } else {\n          currentClass.attributes.push(member.member)\n        }\n      }\n      continue\n    }\n\n    // --- Namespace block start ---\n    const nsMatch = line.match(/^namespace\\s+(\\S+)\\s*\\{$/)\n    if (nsMatch) {\n      currentNamespace = { name: nsMatch[1]!, classIds: [] }\n      continue\n    }\n\n    // --- Namespace end ---\n    if (line === '}' && currentNamespace) {\n      diagram.namespaces.push(currentNamespace)\n      currentNamespace = null\n      continue\n    }\n\n    // --- Class block start: `class ClassName {` or `class ClassName` ---\n    const classBlockMatch = line.match(/^class\\s+(\\S+?)(?:\\s*~(\\w+)~)?\\s*\\{$/)\n    if (classBlockMatch) {\n      const id = classBlockMatch[1]!\n      const generic = classBlockMatch[2]\n      const cls = ensureClass(classMap, id)\n      if (generic) {\n        cls.label = `${id}<${generic}>`\n      }\n      currentClass = cls\n      braceDepth = 1\n      if (currentNamespace) {\n        currentNamespace.classIds.push(id)\n      }\n      continue\n    }\n\n    // --- Standalone class declaration (no body): `class ClassName` ---\n    const classOnlyMatch = line.match(/^class\\s+(\\S+?)(?:\\s*~(\\w+)~)?\\s*$/)\n    if (classOnlyMatch) {\n      const id = classOnlyMatch[1]!\n      const generic = classOnlyMatch[2]\n      const cls = ensureClass(classMap, id)\n      if (generic) {\n        cls.label = `${id}<${generic}>`\n      }\n      if (currentNamespace) {\n        currentNamespace.classIds.push(id)\n      }\n      continue\n    }\n\n    // --- Inline annotation: `class ClassName { <<interface>> }` (single line) ---\n    const inlineAnnotMatch = line.match(/^class\\s+(\\S+?)\\s*\\{\\s*<<(\\w+)>>\\s*\\}$/)\n    if (inlineAnnotMatch) {\n      const cls = ensureClass(classMap, inlineAnnotMatch[1]!)\n      cls.annotation = inlineAnnotMatch[2]!\n      continue\n    }\n\n    // --- Inline attribute: `ClassName : +String name` ---\n    const inlineAttrMatch = line.match(/^(\\S+?)\\s*:\\s*(.+)$/)\n    if (inlineAttrMatch) {\n      // Make sure this isn't a relationship line (those have arrows)\n      const rest = inlineAttrMatch[2]!\n      if (!rest.match(/<\\|--|--|\\*--|o--|-->|\\.\\.>|\\.\\.\\|>/)) {\n        const cls = ensureClass(classMap, inlineAttrMatch[1]!)\n        const member = parseMember(rest)\n        if (member) {\n          if (member.isMethod) {\n            cls.methods.push(member.member)\n          } else {\n            cls.attributes.push(member.member)\n          }\n        }\n        continue\n      }\n    }\n\n    // --- Relationship ---\n    // Pattern: [FROM] [\"card\"] ARROW [\"card\"] [TO] [: label]\n    // Arrows: <|--, *--, o--, -->, ..|>, ..>\n    // Can also be reversed: --o, --*, --|>\n    const rel = parseRelationship(line)\n    if (rel) {\n      // Ensure both classes exist\n      ensureClass(classMap, rel.from)\n      ensureClass(classMap, rel.to)\n      diagram.relationships.push(rel)\n      continue\n    }\n  }\n\n  diagram.classes = [...classMap.values()]\n  return diagram\n}\n\n/** Ensure a class exists in the map, creating a default if needed */\nfunction ensureClass(classMap: Map<string, ClassNode>, id: string): ClassNode {\n  let cls = classMap.get(id)\n  if (!cls) {\n    cls = { id, label: id, attributes: [], methods: [] }\n    classMap.set(id, cls)\n  }\n  return cls\n}\n\n/** Parse a class member line (attribute or method) */\nfunction parseMember(line: string): { member: ClassMember; isMethod: boolean } | null {\n  const trimmed = line.trim().replace(/;$/, '')\n  if (!trimmed) return null\n\n  // Extract visibility prefix\n  let visibility: ClassMember['visibility'] = ''\n  let rest = trimmed\n  if (/^[+\\-#~]/.test(rest)) {\n    visibility = rest[0] as ClassMember['visibility']\n    rest = rest.slice(1).trim()\n  }\n\n  // Check if it's a method (has parentheses)\n  const methodMatch = rest.match(/^(.+?)\\(([^)]*)\\)(?:\\s*(.+))?$/)\n  if (methodMatch) {\n    const name = methodMatch[1]!.trim()\n    const type = methodMatch[3]?.trim()\n    // Check for static ($) or abstract (*) markers\n    const isStatic = name.endsWith('$') || rest.includes('$')\n    const isAbstract = name.endsWith('*') || rest.includes('*')\n    return {\n      member: {\n        visibility,\n        name: name.replace(/[$*]$/, ''),\n        type: type || undefined,\n        isStatic,\n        isAbstract,\n      },\n      isMethod: true,\n    }\n  }\n\n  // It's an attribute: [Type] name or name Type\n  // Common patterns: \"String name\", \"+int age\", \"name\"\n  const parts = rest.split(/\\s+/)\n  let name: string\n  let type: string | undefined\n\n  if (parts.length >= 2) {\n    // \"Type name\" pattern\n    type = parts[0]\n    name = parts.slice(1).join(' ')\n  } else {\n    name = parts[0] ?? rest\n  }\n\n  const isStatic = name.endsWith('$')\n  const isAbstract = name.endsWith('*')\n\n  return {\n    member: {\n      visibility,\n      name: name.replace(/[$*]$/, ''),\n      type: type || undefined,\n      isStatic,\n      isAbstract,\n    },\n    isMethod: false,\n  }\n}\n\n/** Parse a relationship line into a ClassRelationship */\nfunction parseRelationship(line: string): ClassRelationship | null {\n  // Relationship regex  handles all arrow types with optional cardinality and labels\n  // Pattern: FROM [\"card\"] ARROW [\"card\"] TO [: label]\n  const match = line.match(\n    /^(\\S+?)\\s+(?:\"([^\"]*?)\"\\s+)?(<\\|--|<\\|\\.\\.|\\*--|o--|-->|--\\*|--o|--|>\\s*|\\.\\.>|\\.\\.\\|>|--)\\s+(?:\"([^\"]*?)\"\\s+)?(\\S+?)(?:\\s*:\\s*(.+))?$/\n  )\n  if (!match) return null\n\n  const from = match[1]!\n  const fromCardinality = match[2] || undefined\n  const arrow = match[3]!.trim()\n  const toCardinality = match[4] || undefined\n  const to = match[5]!\n  const label = match[6]?.trim() || undefined\n\n  const parsed = parseArrow(arrow)\n  if (!parsed) return null\n\n  return { from, to, type: parsed.type, markerAt: parsed.markerAt, label, fromCardinality, toCardinality }\n}\n\n/**\n * Map arrow syntax to relationship type and marker placement side.\n * Prefix markers (`<|--`, `*--`, `o--`) place the UML shape at the 'from' end.\n * Suffix markers (`..|>`, `-->`, `..>`, `--*`, `--o`) place it at the 'to' end.\n */\nfunction parseArrow(arrow: string): { type: RelationshipType; markerAt: 'from' | 'to' } | null {\n  switch (arrow) {\n    case '<|--': return { type: 'inheritance',  markerAt: 'from' }\n    case '<|..': return { type: 'realization',  markerAt: 'from' }\n    case '*--':  return { type: 'composition',  markerAt: 'from' }\n    case '--*':  return { type: 'composition',  markerAt: 'to' }\n    case 'o--':  return { type: 'aggregation',  markerAt: 'from' }\n    case '--o':  return { type: 'aggregation',  markerAt: 'to' }\n    case '-->':  return { type: 'association',  markerAt: 'to' }\n    case '..>':  return { type: 'dependency',   markerAt: 'to' }\n    case '..|>': return { type: 'realization',  markerAt: 'to' }\n    case '--':   return { type: 'association',  markerAt: 'to' }\n    default:     return null\n  }\n}\n","// ============================================================================\n// ASCII renderer  class diagrams\n//\n// Renders classDiagram text to ASCII/Unicode art.\n// Each class is a multi-compartment box (header | attributes | methods).\n// Relationships are drawn as lines between classes with UML markers.\n//\n// Layout: level-based top-down. \"From\" classes are placed above \"to\" classes\n// for all relationship types, matching dagre/mermaid.com behavior.\n// Relationship lines use simple Manhattan routing (vertical + horizontal).\n// ============================================================================\n\nimport { parseClassDiagram } from '../class/parser.ts'\nimport type { ClassDiagram, ClassNode, ClassMember, ClassRelationship, RelationshipType } from '../class/types.ts'\nimport type { Canvas, AsciiConfig } from './types.ts'\nimport { mkCanvas, canvasToString, increaseSize } from './canvas.ts'\nimport { drawMultiBox } from './draw.ts'\n\n// ============================================================================\n// Class member formatting\n// ============================================================================\n\n/** Format a class member as a display string: visibility + name + optional type */\nfunction formatMember(m: ClassMember): string {\n  const vis = m.visibility || ''\n  const type = m.type ? `: ${m.type}` : ''\n  return `${vis}${m.name}${type}`\n}\n\n/** Build the text sections for a class box: [header], [attributes], [methods] */\nfunction buildClassSections(cls: ClassNode): string[][] {\n  // Header section: optional annotation + class name (centered later by drawMultiBox)\n  const header: string[] = []\n  if (cls.annotation) header.push(`<<${cls.annotation}>>`)\n  header.push(cls.label)\n\n  // Attributes section\n  const attrs = cls.attributes.map(formatMember)\n\n  // Methods section\n  const methods = cls.methods.map(formatMember)\n\n  // If no attrs and no methods, just return header (1-section box)\n  if (attrs.length === 0 && methods.length === 0) return [header]\n  // If no methods, return header + attrs (2-section box)\n  if (methods.length === 0) return [header, attrs]\n  // Full 3-section box\n  return [header, attrs, methods]\n}\n\n// ============================================================================\n// Relationship marker characters\n// ============================================================================\n\ninterface RelMarker {\n  /** Relationship type (determines marker shape) */\n  type: RelationshipType\n  /** Which end the marker is placed at */\n  markerAt: 'from' | 'to'\n  /** Whether the line is dashed */\n  dashed: boolean\n}\n\n/**\n * Build the marker metadata for a relationship.\n * The actual marker character will be determined at placement time based on line direction.\n */\nfunction getRelMarker(type: RelationshipType, markerAt: 'from' | 'to'): RelMarker {\n  const dashed = type === 'dependency' || type === 'realization'\n  return { type, markerAt, dashed }\n}\n\n/**\n * Get the UML marker shape character for a relationship type.\n * For directional arrows (association/dependency), the direction parameter\n * specifies which way the arrow should point.\n */\nfunction getMarkerShape(\n  type: RelationshipType,\n  useAscii: boolean,\n  direction?: 'up' | 'down' | 'left' | 'right'\n): string {\n  switch (type) {\n    case 'inheritance':\n    case 'realization':\n      // Hollow triangle - rotate based on line direction\n      // Triangle points TOWARD the parent class\n      if (direction === 'down') {\n        // Line goes down (parent above, child below) - triangle points UP\n        return useAscii ? '^' : ''\n      } else if (direction === 'up') {\n        // Line goes up (parent below, child above) - triangle points DOWN\n        return useAscii ? 'v' : ''\n      } else if (direction === 'left') {\n        // Line goes left - triangle points LEFT\n        return useAscii ? '>' : ''\n      } else {\n        // Default: line goes right - triangle points RIGHT\n        return useAscii ? '<' : ''\n      }\n    case 'composition':\n      // Filled diamond - omnidirectional shape\n      return useAscii ? '*' : ''\n    case 'aggregation':\n      // Hollow diamond - omnidirectional shape\n      return useAscii ? 'o' : ''\n    case 'association':\n    case 'dependency':\n      // Directional arrow - rotate based on line direction\n      if (direction === 'down') {\n        return useAscii ? 'v' : ''\n      } else if (direction === 'up') {\n        return useAscii ? '^' : ''\n      } else if (direction === 'left') {\n        return useAscii ? '<' : ''\n      } else {\n        // Default to right (or when direction not specified)\n        return useAscii ? '>' : ''\n      }\n  }\n}\n\n// ============================================================================\n// Layout and rendering\n// ============================================================================\n\n/** Positioned class node on the canvas */\ninterface PlacedClass {\n  cls: ClassNode\n  sections: string[][]\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\n/**\n * Render a Mermaid class diagram to ASCII/Unicode text.\n *\n * Pipeline: parse  build boxes  level-based layout  draw boxes  draw relationships  string.\n */\nexport function renderClassAscii(text: string, config: AsciiConfig): string {\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('%%'))\n  const diagram = parseClassDiagram(lines)\n\n  if (diagram.classes.length === 0) return ''\n\n  const useAscii = config.useAscii\n  const hGap = 4  // horizontal gap between class boxes\n  const vGap = 3  // vertical gap between levels (enough for relationship lines)\n\n  // --- Build box dimensions for each class ---\n  const classSections = new Map<string, string[][]>()\n  const classBoxW = new Map<string, number>()\n  const classBoxH = new Map<string, number>()\n\n  for (const cls of diagram.classes) {\n    const sections = buildClassSections(cls)\n    classSections.set(cls.id, sections)\n\n    // Compute box dimensions from drawMultiBox logic\n    let maxTextW = 0\n    for (const section of sections) {\n      for (const line of section) maxTextW = Math.max(maxTextW, line.length)\n    }\n    const boxW = maxTextW + 4 // 2 border + 2 padding\n\n    let totalLines = 0\n    for (const section of sections) totalLines += Math.max(section.length, 1)\n    const boxH = totalLines + (sections.length - 1) + 2 // section lines + dividers + top/bottom border\n\n    classBoxW.set(cls.id, boxW)\n    classBoxH.set(cls.id, boxH)\n  }\n\n  // --- Assign levels: topological sort based on directed relationships ---\n  // All relationship types place \"from\" above \"to\" in the layout, matching\n  // dagre's layered algorithm and the official mermaid.com renderer behavior.\n  // For \"Animal <|-- Dog\": from=\"Animal\", to=\"Dog\"  Animal above Dog.\n  //\n  // Every relationship type (including association and dependency) forces nodes\n  // to different levels. Same-row routing for mixed diagrams causes collisions:\n  // detour lines overlap with cross-level routing, and labels overwrite box borders.\n\n  const classById = new Map<string, ClassNode>()\n  for (const cls of diagram.classes) classById.set(cls.id, cls)\n\n  const parents = new Map<string, Set<string>>()  // child  set of parent IDs\n  const children = new Map<string, Set<string>>() // parent  set of child IDs\n\n  for (const rel of diagram.relationships) {\n    // For inheritance/realization, the marker (hollow triangle) points to the parent.\n    // - `Animal <|-- Dog` (markerAt='from'): Animal is parent, Dog is child\n    // - `Bird ..|> Flyable` (markerAt='to'): Flyable is parent, Bird is child\n    // For other relationships, use the default fromto direction.\n    const isHierarchical = rel.type === 'inheritance' || rel.type === 'realization'\n    const parentId = isHierarchical && rel.markerAt === 'to' ? rel.to : rel.from\n    const childId = isHierarchical && rel.markerAt === 'to' ? rel.from : rel.to\n\n    if (!parents.has(childId)) parents.set(childId, new Set())\n    parents.get(childId)!.add(parentId)\n    if (!children.has(parentId)) children.set(parentId, new Set())\n    children.get(parentId)!.add(childId)\n  }\n\n  // BFS from roots (classes that have no parents) to assign levels.\n  // Cap at classes.length - 1 to prevent infinite loops on cyclic graphs\n  // (e.g. View --> Model and Model ..> View would otherwise push levels\n  // upward forever). In a DAG the longest path has at most N-1 edges.\n  const level = new Map<string, number>()\n  const roots = diagram.classes.filter(c => !parents.has(c.id) || parents.get(c.id)!.size === 0)\n  const queue: string[] = roots.map(c => c.id)\n  for (const id of queue) level.set(id, 0)\n\n  const levelCap = diagram.classes.length - 1\n  let qi = 0\n  while (qi < queue.length) {\n    const id = queue[qi++]!\n    const childSet = children.get(id)\n    if (!childSet) continue\n    for (const childId of childSet) {\n      const newLevel = (level.get(id) ?? 0) + 1\n      if (newLevel > levelCap) continue // cycle detected  skip to prevent infinite loop\n      if (!level.has(childId) || level.get(childId)! < newLevel) {\n        level.set(childId, newLevel)\n        queue.push(childId)\n      }\n    }\n  }\n\n  // Assign remaining (unconnected) classes to level 0\n  for (const cls of diagram.classes) {\n    if (!level.has(cls.id)) level.set(cls.id, 0)\n  }\n\n  // --- Position classes by level ---\n  // Group classes by level\n  const maxLevel = Math.max(...[...level.values()], 0)\n  const levelGroups: string[][] = Array.from({ length: maxLevel + 1 }, () => [])\n  for (const cls of diagram.classes) {\n    levelGroups[level.get(cls.id)!]!.push(cls.id)\n  }\n\n  // Compute positions: each level is a row, classes in a row are spaced horizontally\n  const placed = new Map<string, PlacedClass>()\n  let currentY = 0\n\n  for (let lv = 0; lv <= maxLevel; lv++) {\n    const group = levelGroups[lv]!\n    if (group.length === 0) continue\n\n    let currentX = 0\n    let maxH = 0\n\n    for (const id of group) {\n      const cls = classById.get(id)!\n      const w = classBoxW.get(id)!\n      const h = classBoxH.get(id)!\n      placed.set(id, {\n        cls,\n        sections: classSections.get(id)!,\n        x: currentX,\n        y: currentY,\n        width: w,\n        height: h,\n      })\n      currentX += w + hGap\n      maxH = Math.max(maxH, h)\n    }\n\n    currentY += maxH + vGap\n  }\n\n  // --- Create canvas ---\n  let totalW = 0\n  let totalH = 0\n  for (const p of placed.values()) {\n    totalW = Math.max(totalW, p.x + p.width)\n    totalH = Math.max(totalH, p.y + p.height)\n  }\n\n  // Extra space for relationship lines that may go below/beside\n  totalW += 4\n  totalH += 2\n\n  const canvas = mkCanvas(totalW - 1, totalH - 1)\n\n  // --- Draw class boxes ---\n  for (const p of placed.values()) {\n    const boxCanvas = drawMultiBox(p.sections, useAscii)\n    // Copy box onto main canvas at (p.x, p.y)\n    for (let bx = 0; bx < boxCanvas.length; bx++) {\n      for (let by = 0; by < boxCanvas[0]!.length; by++) {\n        const ch = boxCanvas[bx]![by]!\n        if (ch !== ' ') {\n          const cx = p.x + bx\n          const cy = p.y + by\n          if (cx < totalW && cy < totalH) {\n            canvas[cx]![cy] = ch\n          }\n        }\n      }\n    }\n  }\n\n  // --- Draw relationship lines ---\n  const H = useAscii ? '-' : ''\n  const V = useAscii ? '|' : ''\n  const dashH = useAscii ? '.' : ''\n  const dashV = useAscii ? ':' : ''\n\n  for (const rel of diagram.relationships) {\n    const fromP = placed.get(rel.from)\n    const toP = placed.get(rel.to)\n    if (!fromP || !toP) continue\n\n    const marker = getRelMarker(rel.type, rel.markerAt)\n    const lineH = marker.dashed ? dashH : H\n    const lineV = marker.dashed ? dashV : V\n\n    // Connection points: center-bottom of source  center-top of target\n    const fromCX = fromP.x + Math.floor(fromP.width / 2)\n    const fromBY = fromP.y + fromP.height - 1\n    const toCX = toP.x + Math.floor(toP.width / 2)\n    const toTY = toP.y\n\n    // Route: simple Manhattan routing\n    // If target is below source: vertical down from source, horizontal if needed, vertical down to target\n    // If same row: horizontal line with a small vertical detour above or below\n    if (fromBY < toTY) {\n      // Target is below source  simple vertical-first routing\n      const midY = fromBY + Math.floor((toTY - fromBY) / 2)\n\n      // Vertical from source bottom to midY\n      for (let y = fromBY + 1; y <= midY; y++) {\n        if (y < totalH) canvas[fromCX]![y] = lineV\n      }\n\n      // Horizontal from fromCX to toCX at midY\n      if (fromCX !== toCX) {\n        const lx = Math.min(fromCX, toCX)\n        const rx = Math.max(fromCX, toCX)\n        for (let x = lx; x <= rx; x++) {\n          if (x < totalW && midY < totalH) canvas[x]![midY] = lineH\n        }\n        // Corner characters\n        if (!useAscii && midY < totalH) {\n          if (fromCX < toCX) {\n            canvas[fromCX]![midY] = ''\n            canvas[toCX]![midY] = ''\n          } else {\n            canvas[fromCX]![midY] = ''\n            canvas[toCX]![midY] = ''\n          }\n        }\n      }\n\n      // Vertical from midY to target top\n      for (let y = midY + 1; y < toTY; y++) {\n        if (y < totalH) canvas[toCX]![y] = lineV\n      }\n\n      // Draw markers - arrows point in the direction of the vertical segment\n      if (marker.markerAt === 'to') {\n        // Marker at target (pointing down into the target box)\n        const markerChar = getMarkerShape(marker.type, useAscii, 'down')\n        const my = toTY - 1\n        if (my >= 0 && my < totalH) {\n          for (let i = 0; i < markerChar.length; i++) {\n            const mx = toCX - Math.floor(markerChar.length / 2) + i\n            if (mx >= 0 && mx < totalW) canvas[mx]![my] = markerChar[i]!\n          }\n        }\n      }\n      if (marker.markerAt === 'from') {\n        // Marker at source (pointing down away from source box)\n        const markerChar = getMarkerShape(marker.type, useAscii, 'down')\n        const my = fromBY + 1\n        if (my < totalH) {\n          for (let i = 0; i < markerChar.length; i++) {\n            const mx = fromCX - Math.floor(markerChar.length / 2) + i\n            if (mx >= 0 && mx < totalW) canvas[mx]![my] = markerChar[i]!\n          }\n        }\n      }\n    } else if (toP.y + toP.height - 1 < fromP.y) {\n      // Target is ABOVE source  draw upward from source top to target bottom\n      const fromTY = fromP.y\n      const toBY = toP.y + toP.height - 1\n      const midY = toBY + Math.floor((fromTY - toBY) / 2)\n\n      for (let y = fromTY - 1; y >= midY; y--) {\n        if (y >= 0 && y < totalH) canvas[fromCX]![y] = lineV\n      }\n\n      if (fromCX !== toCX) {\n        const lx = Math.min(fromCX, toCX)\n        const rx = Math.max(fromCX, toCX)\n        for (let x = lx; x <= rx; x++) {\n          if (x < totalW && midY >= 0 && midY < totalH) canvas[x]![midY] = lineH\n        }\n        if (!useAscii && midY >= 0 && midY < totalH) {\n          if (fromCX < toCX) {\n            canvas[fromCX]![midY] = ''\n            canvas[toCX]![midY] = ''\n          } else {\n            canvas[fromCX]![midY] = ''\n            canvas[toCX]![midY] = ''\n          }\n        }\n      }\n\n      for (let y = midY - 1; y > toBY; y--) {\n        if (y >= 0 && y < totalH) canvas[toCX]![y] = lineV\n      }\n\n      // Draw markers - arrows point in the direction of the vertical segment (upward)\n      if (marker.markerAt === 'from') {\n        // Marker at source (pointing up away from source box)\n        const markerChar = getMarkerShape(marker.type, useAscii, 'up')\n        const my = fromTY - 1\n        if (my >= 0 && my < totalH) {\n          for (let i = 0; i < markerChar.length; i++) {\n            const mx = fromCX - Math.floor(markerChar.length / 2) + i\n            if (mx >= 0 && mx < totalW) canvas[mx]![my] = markerChar[i]!\n          }\n        }\n      }\n      if (marker.markerAt === 'to') {\n        // Marker at target (pointing up into the target box from below)\n        // For inheritance/realization, triangle points toward parent - use 'down' to get \n        // For association/dependency, arrow points in line direction - use 'up' to get \n        const isHierarchical = marker.type === 'inheritance' || marker.type === 'realization'\n        const markerDir = isHierarchical ? 'down' : 'up'\n        const markerChar = getMarkerShape(marker.type, useAscii, markerDir)\n        const my = toBY + 1\n        if (my < totalH) {\n          for (let i = 0; i < markerChar.length; i++) {\n            const mx = toCX - Math.floor(markerChar.length / 2) + i\n            if (mx >= 0 && mx < totalW) canvas[mx]![my] = markerChar[i]!\n          }\n        }\n      }\n    } else {\n      // Same level  draw horizontal line with a detour below both boxes\n      const detourY = Math.max(fromBY, toP.y + toP.height - 1) + 2\n      increaseSize(canvas, totalW, detourY + 1)\n\n      // Vertical down from source\n      for (let y = fromBY + 1; y <= detourY; y++) {\n        canvas[fromCX]![y] = lineV\n      }\n      // Horizontal\n      const lx = Math.min(fromCX, toCX)\n      const rx = Math.max(fromCX, toCX)\n      for (let x = lx; x <= rx; x++) {\n        canvas[x]![detourY] = lineH\n      }\n      // Vertical up to target\n      for (let y = detourY - 1; y >= toP.y + toP.height; y--) {\n        canvas[toCX]![y] = lineV\n      }\n\n      // Draw markers - same-level routing uses vertical segments at both ends\n      if (marker.markerAt === 'from') {\n        // Marker at source (pointing down away from source box)\n        const markerChar = getMarkerShape(marker.type, useAscii, 'down')\n        const my = fromBY + 1\n        if (my < totalH) {\n          for (let i = 0; i < markerChar.length; i++) {\n            const mx = fromCX - Math.floor(markerChar.length / 2) + i\n            if (mx >= 0 && mx < totalW) canvas[mx]![my] = markerChar[i]!\n          }\n        }\n      }\n      if (marker.markerAt === 'to') {\n        // Marker at target bottom (pointing up into the target box)\n        const markerChar = getMarkerShape(marker.type, useAscii, 'up')\n        const my = toP.y + toP.height\n        if (my < totalH) {\n          for (let i = 0; i < markerChar.length; i++) {\n            const mx = toCX - Math.floor(markerChar.length / 2) + i\n            if (mx >= 0 && mx < totalW) canvas[mx]![my] = markerChar[i]!\n          }\n        }\n      }\n    }\n\n    // Draw relationship label at midpoint if present\n    // Add padding around the label for readability\n    if (rel.label) {\n      const paddedLabel = ` ${rel.label} `  // Add space padding on both sides\n      const midX = Math.floor((fromCX + toCX) / 2)\n      // Calculate midY based on routing direction\n      let midY: number\n      if (fromBY < toTY) {\n        // Target below source: midpoint between source bottom and target top\n        midY = Math.floor((fromBY + 1 + toTY - 1) / 2)\n      } else if (toP.y + toP.height - 1 < fromP.y) {\n        // Target above source: midpoint between target bottom and source top\n        const toBY = toP.y + toP.height - 1\n        midY = Math.floor((toBY + 1 + fromP.y - 1) / 2)\n      } else {\n        // Same level: place label at midpoint of the detour line\n        midY = Math.max(fromBY, toP.y + toP.height - 1) + 2\n      }\n      const labelStart = midX - Math.floor(paddedLabel.length / 2)\n      // Clear the area first (overwrite line characters) then draw the padded label\n      for (let i = 0; i < paddedLabel.length; i++) {\n        const lx = labelStart + i\n        if (lx >= 0 && lx < totalW && midY >= 0 && midY < totalH) {\n          canvas[lx]![midY] = paddedLabel[i]!\n        }\n      }\n    }\n  }\n\n  return canvasToString(canvas)\n}\n","import type { ErDiagram, ErEntity, ErAttribute, ErRelationship, Cardinality } from './types.ts'\n\n// ============================================================================\n// ER diagram parser\n//\n// Parses Mermaid erDiagram syntax into an ErDiagram structure.\n//\n// Supported syntax:\n//   CUSTOMER ||--o{ ORDER : places\n//   CUSTOMER {\n//     string name PK\n//     int age\n//     string email UK \"user email\"\n//   }\n//\n// Cardinality notation:\n//   ||  exactly one\n//   o|  zero or one (also |o)\n//   }|  one or more (also |{)\n//   o{  zero or more (also {o)\n//\n// Line style:\n//   --  identifying (solid line)\n//   ..  non-identifying (dashed line)\n// ============================================================================\n\n/**\n * Parse a Mermaid ER diagram.\n * Expects the first line to be \"erDiagram\".\n */\nexport function parseErDiagram(lines: string[]): ErDiagram {\n  const diagram: ErDiagram = {\n    entities: [],\n    relationships: [],\n  }\n\n  // Track entities by ID for deduplication\n  const entityMap = new Map<string, ErEntity>()\n  // Track entity body parsing\n  let currentEntity: ErEntity | null = null\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i]!\n\n    // --- Inside entity body ---\n    if (currentEntity) {\n      if (line === '}') {\n        currentEntity = null\n        continue\n      }\n\n      // Attribute line: type name [PK|FK|UK] [\"comment\"]\n      const attr = parseAttribute(line)\n      if (attr) {\n        currentEntity.attributes.push(attr)\n      }\n      continue\n    }\n\n    // --- Entity block start: `ENTITY_NAME {` ---\n    const entityBlockMatch = line.match(/^(\\S+)\\s*\\{$/)\n    if (entityBlockMatch) {\n      const id = entityBlockMatch[1]!\n      const entity = ensureEntity(entityMap, id)\n      currentEntity = entity\n      continue\n    }\n\n    // --- Relationship: `ENTITY1 cardinality1--cardinality2 ENTITY2 : label` ---\n    const rel = parseRelationshipLine(line)\n    if (rel) {\n      // Ensure both entities exist\n      ensureEntity(entityMap, rel.entity1)\n      ensureEntity(entityMap, rel.entity2)\n      diagram.relationships.push(rel)\n      continue\n    }\n  }\n\n  diagram.entities = [...entityMap.values()]\n  return diagram\n}\n\n/** Ensure an entity exists in the map */\nfunction ensureEntity(entityMap: Map<string, ErEntity>, id: string): ErEntity {\n  let entity = entityMap.get(id)\n  if (!entity) {\n    entity = { id, label: id, attributes: [] }\n    entityMap.set(id, entity)\n  }\n  return entity\n}\n\n/** Parse an attribute line inside an entity block */\nfunction parseAttribute(line: string): ErAttribute | null {\n  // Format: type name [PK|FK|UK [...]] [\"comment\"]\n  const match = line.match(/^(\\S+)\\s+(\\S+)(?:\\s+(.+))?$/)\n  if (!match) return null\n\n  const type = match[1]!\n  const name = match[2]!\n  const rest = match[3]?.trim() ?? ''\n\n  // Extract key constraints (PK, FK, UK) and optional comment\n  const keys: ErAttribute['keys'] = []\n  let comment: string | undefined\n\n  // Extract quoted comment first\n  const commentMatch = rest.match(/\"([^\"]*)\"/)\n  if (commentMatch) {\n    comment = commentMatch[1]\n  }\n\n  // Extract key constraints\n  const restWithoutComment = rest.replace(/\"[^\"]*\"/, '').trim()\n  for (const part of restWithoutComment.split(/\\s+/)) {\n    const upper = part.toUpperCase()\n    if (upper === 'PK' || upper === 'FK' || upper === 'UK') {\n      keys.push(upper as 'PK' | 'FK' | 'UK')\n    }\n  }\n\n  return { type, name, keys, comment }\n}\n\n/**\n * Parse a relationship line.\n *\n * Cardinality symbols on each side of the line style:\n *   Left side (entity1):  ||  |o  o|  }|  |{  o{  {o\n *   Line:                 --  (identifying) or  ..  (non-identifying)\n *   Right side (entity2): ||  o|  |o  |{  }|  {o  o{\n *\n * Full pattern example: CUSTOMER ||--o{ ORDER : places\n */\nfunction parseRelationshipLine(line: string): ErRelationship | null {\n  // Match: ENTITY1 <cardinality_and_line> ENTITY2 : label\n  const match = line.match(/^(\\S+)\\s+([|o}{]+(?:--|\\.\\.)[|o}{]+)\\s+(\\S+)\\s*:\\s*(.+)$/)\n  if (!match) return null\n\n  const entity1 = match[1]!\n  const cardinalityStr = match[2]!\n  const entity2 = match[3]!\n  const label = match[4]!.trim()\n\n  // Split the cardinality string into left side, line style, right side\n  const lineMatch = cardinalityStr.match(/^([|o}{]+)(--|\\.\\.?)([|o}{]+)$/)\n  if (!lineMatch) return null\n\n  const leftStr = lineMatch[1]!\n  const lineStyle = lineMatch[2]!\n  const rightStr = lineMatch[3]!\n\n  const cardinality1 = parseCardinality(leftStr)\n  const cardinality2 = parseCardinality(rightStr)\n  const identifying = lineStyle === '--'\n\n  if (!cardinality1 || !cardinality2) return null\n\n  return { entity1, entity2, cardinality1, cardinality2, label, identifying }\n}\n\n/** Parse a cardinality notation string into a Cardinality type */\nfunction parseCardinality(str: string): Cardinality | null {\n  // Normalize: sort the characters to handle both orders (e.g., |o and o|)\n  const sorted = str.split('').sort().join('')\n\n  // Exact one: ||  sorted \"||\"\n  if (sorted === '||') return 'one'\n  // Zero or one: o| or |o  sorted \"o|\" (o=111 < |=124 in char codes)\n  if (sorted === 'o|') return 'zero-one'\n  // One or more: }| or |{  sorted \"|}\" or \"{|\"\n  if (sorted === '|}' || sorted === '{|') return 'many'\n  // Zero or more: o{ or {o  sorted \"{o\" or \"o{\"\n  if (sorted === '{o' || sorted === 'o{') return 'zero-many'\n\n  return null\n}\n","// ============================================================================\n// ASCII renderer  ER diagrams\n//\n// Renders erDiagram text to ASCII/Unicode art.\n// Each entity is a 2-section box (header | attributes).\n// Relationships are drawn as lines with crow's foot notation at endpoints.\n//\n// Layout: entities are placed in a grid pattern (multiple rows if needed).\n// Relationship lines use Manhattan routing between entity boxes.\n// ============================================================================\n\nimport { parseErDiagram } from '../er/parser.ts'\nimport type { ErDiagram, ErEntity, ErAttribute, Cardinality } from '../er/types.ts'\nimport type { Canvas, AsciiConfig } from './types.ts'\nimport { mkCanvas, canvasToString, increaseSize } from './canvas.ts'\nimport { drawMultiBox } from './draw.ts'\n\n// ============================================================================\n// Entity box content\n// ============================================================================\n\n/** Format an attribute line: \"PK type name\" or \"FK type name\" etc. */\nfunction formatAttribute(attr: ErAttribute): string {\n  const keyStr = attr.keys.length > 0 ? attr.keys.join(',') + ' ' : '   '\n  return `${keyStr}${attr.type} ${attr.name}`\n}\n\n/** Build sections for an entity box: [header], [attributes] */\nfunction buildEntitySections(entity: ErEntity): string[][] {\n  const header = [entity.label]\n  const attrs = entity.attributes.map(formatAttribute)\n  if (attrs.length === 0) return [header]\n  return [header, attrs]\n}\n\n// ============================================================================\n// Crow's foot notation\n// ============================================================================\n\n/**\n * Returns the ASCII/Unicode characters for a crow's foot cardinality marker.\n * These are drawn near the endpoint of a relationship line.\n *\n * Cardinality markers (horizontal direction):\n *   one:          or  --||--\n *   zero-one:  o  or  --o|--\n *   many:         or  --<|--  (or }|)\n *   zero-many: o  or  --o<--  (or o{)\n */\nfunction getCrowsFootChars(card: Cardinality, useAscii: boolean): string {\n  if (useAscii) {\n    switch (card) {\n      case 'one':       return '||'\n      case 'zero-one':  return 'o|'\n      case 'many':      return '}|'\n      case 'zero-many': return 'o{'\n    }\n  } else {\n    switch (card) {\n      case 'one':       return ''\n      case 'zero-one':  return 'o'\n      case 'many':      return ''\n      case 'zero-many': return 'o'\n    }\n  }\n}\n\n// ============================================================================\n// Positioned entity\n// ============================================================================\n\ninterface PlacedEntity {\n  entity: ErEntity\n  sections: string[][]\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\n// ============================================================================\n// Layout and rendering\n// ============================================================================\n\n/**\n * Render a Mermaid ER diagram to ASCII/Unicode text.\n *\n * Pipeline: parse  build boxes  grid layout  draw boxes  draw relationships  string.\n */\nexport function renderErAscii(text: string, config: AsciiConfig): string {\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('%%'))\n  const diagram = parseErDiagram(lines)\n\n  if (diagram.entities.length === 0) return ''\n\n  const useAscii = config.useAscii\n  const hGap = 6  // horizontal gap between entity boxes\n  const vGap = 4  // vertical gap between rows (for relationship lines)\n\n  // --- Build entity box dimensions ---\n  const entitySections = new Map<string, string[][]>()\n  const entityBoxW = new Map<string, number>()\n  const entityBoxH = new Map<string, number>()\n\n  for (const ent of diagram.entities) {\n    const sections = buildEntitySections(ent)\n    entitySections.set(ent.id, sections)\n\n    let maxTextW = 0\n    for (const section of sections) {\n      for (const line of section) maxTextW = Math.max(maxTextW, line.length)\n    }\n    const boxW = maxTextW + 4 // 2 border + 2 padding\n\n    let totalLines = 0\n    for (const section of sections) totalLines += Math.max(section.length, 1)\n    const boxH = totalLines + (sections.length - 1) + 2\n\n    entityBoxW.set(ent.id, boxW)\n    entityBoxH.set(ent.id, boxH)\n  }\n\n  // --- Layout: place entities in rows ---\n  // Use a simple grid: max N entities per row (based on count).\n  // Entities involved in relationships are placed adjacent when possible.\n  const maxPerRow = Math.max(2, Math.ceil(Math.sqrt(diagram.entities.length)))\n\n  const placed = new Map<string, PlacedEntity>()\n  let currentX = 0\n  let currentY = 0\n  let maxRowH = 0\n  let colCount = 0\n\n  for (const ent of diagram.entities) {\n    const w = entityBoxW.get(ent.id)!\n    const h = entityBoxH.get(ent.id)!\n\n    if (colCount >= maxPerRow) {\n      // Wrap to next row\n      currentY += maxRowH + vGap\n      currentX = 0\n      maxRowH = 0\n      colCount = 0\n    }\n\n    placed.set(ent.id, {\n      entity: ent,\n      sections: entitySections.get(ent.id)!,\n      x: currentX,\n      y: currentY,\n      width: w,\n      height: h,\n    })\n\n    currentX += w + hGap\n    maxRowH = Math.max(maxRowH, h)\n    colCount++\n  }\n\n  // --- Create canvas ---\n  let totalW = 0\n  let totalH = 0\n  for (const p of placed.values()) {\n    totalW = Math.max(totalW, p.x + p.width)\n    totalH = Math.max(totalH, p.y + p.height)\n  }\n  totalW += 4\n  totalH += 2\n\n  const canvas = mkCanvas(totalW - 1, totalH - 1)\n\n  // --- Draw entity boxes ---\n  for (const p of placed.values()) {\n    const boxCanvas = drawMultiBox(p.sections, useAscii)\n    for (let bx = 0; bx < boxCanvas.length; bx++) {\n      for (let by = 0; by < boxCanvas[0]!.length; by++) {\n        const ch = boxCanvas[bx]![by]!\n        if (ch !== ' ') {\n          const cx = p.x + bx\n          const cy = p.y + by\n          if (cx < totalW && cy < totalH) {\n            canvas[cx]![cy] = ch\n          }\n        }\n      }\n    }\n  }\n\n  // --- Draw relationships ---\n  const H = useAscii ? '-' : ''\n  const V = useAscii ? '|' : ''\n  const dashH = useAscii ? '.' : ''\n  const dashV = useAscii ? ':' : ''\n\n  for (const rel of diagram.relationships) {\n    const e1 = placed.get(rel.entity1)\n    const e2 = placed.get(rel.entity2)\n    if (!e1 || !e2) continue\n\n    const lineH = rel.identifying ? H : dashH\n    const lineV = rel.identifying ? V : dashV\n\n    // Determine connection direction based on relative position.\n    // Connect from right side of left entity to left side of right entity (horizontal),\n    // or from bottom of upper entity to top of lower entity (vertical).\n    const e1CX = e1.x + Math.floor(e1.width / 2)\n    const e1CY = e1.y + Math.floor(e1.height / 2)\n    const e2CX = e2.x + Math.floor(e2.width / 2)\n    const e2CY = e2.y + Math.floor(e2.height / 2)\n\n    // Check if entities are on the same row (horizontal connection)\n    const sameRow = Math.abs(e1CY - e2CY) < Math.max(e1.height, e2.height)\n\n    if (sameRow) {\n      // Horizontal connection: right side of left entity  left side of right entity\n      const [left, right] = e1CX < e2CX ? [e1, e2] : [e2, e1]\n      const [leftCard, rightCard] = e1CX < e2CX\n        ? [rel.cardinality1, rel.cardinality2]\n        : [rel.cardinality2, rel.cardinality1]\n\n      const startX = left.x + left.width\n      const endX = right.x - 1\n      const lineY = left.y + Math.floor(left.height / 2)\n\n      // Draw horizontal line\n      for (let x = startX; x <= endX; x++) {\n        if (x < totalW) canvas[x]![lineY] = lineH\n      }\n\n      // Draw crow's foot markers at endpoints\n      const leftChars = getCrowsFootChars(leftCard, useAscii)\n      for (let i = 0; i < leftChars.length; i++) {\n        const mx = startX + i\n        if (mx < totalW) canvas[mx]![lineY] = leftChars[i]!\n      }\n\n      const rightChars = getCrowsFootChars(rightCard, useAscii)\n      for (let i = 0; i < rightChars.length; i++) {\n        const mx = endX - rightChars.length + 1 + i\n        if (mx >= 0 && mx < totalW) canvas[mx]![lineY] = rightChars[i]!\n      }\n\n      // Relationship label centered in the gap between the two entities, above the line.\n      // Clamp label to the gap region [startX, endX] to avoid overwriting box borders.\n      if (rel.label) {\n        const gapMid = Math.floor((startX + endX) / 2)\n        const labelStart = Math.max(startX, gapMid - Math.floor(rel.label.length / 2))\n        const labelY = lineY - 1\n        if (labelY >= 0) {\n          for (let i = 0; i < rel.label.length; i++) {\n            const lx = labelStart + i\n            if (lx >= startX && lx <= endX && lx < totalW) {\n              canvas[lx]![labelY] = rel.label[i]!\n            }\n          }\n        }\n      }\n    } else {\n      // Vertical connection: bottom of upper entity  top of lower entity\n      const [upper, lower] = e1CY < e2CY ? [e1, e2] : [e2, e1]\n      const [upperCard, lowerCard] = e1CY < e2CY\n        ? [rel.cardinality1, rel.cardinality2]\n        : [rel.cardinality2, rel.cardinality1]\n\n      const startY = upper.y + upper.height\n      const endY = lower.y - 1\n      const lineX = upper.x + Math.floor(upper.width / 2)\n\n      // Vertical line\n      for (let y = startY; y <= endY; y++) {\n        if (y < totalH) canvas[lineX]![y] = lineV\n      }\n\n      // If horizontal offset needed, add a horizontal segment\n      const lowerCX = lower.x + Math.floor(lower.width / 2)\n      if (lineX !== lowerCX) {\n        const midY = Math.floor((startY + endY) / 2)\n        // Horizontal segment at midY\n        const lx = Math.min(lineX, lowerCX)\n        const rx = Math.max(lineX, lowerCX)\n        for (let x = lx; x <= rx; x++) {\n          if (x < totalW && midY < totalH) canvas[x]![midY] = lineH\n        }\n        // Vertical from midY to lower entity\n        for (let y = midY + 1; y <= endY; y++) {\n          if (y < totalH) canvas[lowerCX]![y] = lineV\n        }\n      }\n\n      // Crow's foot markers (vertical direction)\n      // Place markers near the entity connection points\n      const upperChars = getCrowsFootChars(upperCard, useAscii)\n      if (startY < totalH) {\n        for (let i = 0; i < upperChars.length; i++) {\n          const mx = lineX - Math.floor(upperChars.length / 2) + i\n          if (mx >= 0 && mx < totalW) canvas[mx]![startY] = upperChars[i]!\n        }\n      }\n\n      const targetX = lineX !== lowerCX ? lowerCX : lineX\n      const lowerChars = getCrowsFootChars(lowerCard, useAscii)\n      if (endY >= 0 && endY < totalH) {\n        for (let i = 0; i < lowerChars.length; i++) {\n          const mx = targetX - Math.floor(lowerChars.length / 2) + i\n          if (mx >= 0 && mx < totalW) canvas[mx]![endY] = lowerChars[i]!\n        }\n      }\n\n      // Relationship label  placed to the right of the vertical line at the midpoint.\n      // We expand the canvas as needed since labels can extend beyond the initial bounds.\n      if (rel.label) {\n        const midY = Math.floor((startY + endY) / 2)\n        const labelX = lineX + 2\n        if (midY >= 0) {\n          for (let i = 0; i < rel.label.length; i++) {\n            const lx = labelX + i\n            if (lx >= 0) {\n              increaseSize(canvas, lx + 1, midY + 1)\n              canvas[lx]![midY] = rel.label[i]!\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return canvasToString(canvas)\n}\n","// ============================================================================\n// beautiful-mermaid  ASCII renderer public API\n//\n// Renders Mermaid diagrams to ASCII or Unicode box-drawing art.\n// No external dependencies  pure TypeScript.\n//\n// Supported diagram types:\n//   - Flowcharts (graph TD / flowchart LR)  grid-based layout with A* pathfinding\n//   - State diagrams (stateDiagram-v2)  same pipeline as flowcharts\n//   - Sequence diagrams (sequenceDiagram)  column-based timeline layout\n//   - Class diagrams (classDiagram)  level-based UML layout\n//   - ER diagrams (erDiagram)  grid layout with crow's foot notation\n//\n// Usage:\n//   import { renderMermaidAscii } from 'beautiful-mermaid'\n//   const ascii = renderMermaidAscii('graph LR\\n  A --> B')\n// ============================================================================\n\nimport { parseMermaid } from '../parser.ts'\nimport { convertToAsciiGraph } from './converter.ts'\nimport { createMapping } from './grid.ts'\nimport { drawGraph } from './draw.ts'\nimport { canvasToString, flipCanvasVertically } from './canvas.ts'\nimport { renderSequenceAscii } from './sequence.ts'\nimport { renderClassAscii } from './class-diagram.ts'\nimport { renderErAscii } from './er-diagram.ts'\nimport type { AsciiConfig } from './types.ts'\n\nexport interface AsciiRenderOptions {\n  /** true = ASCII chars (+,-,|,>), false = Unicode box-drawing (,,,). Default: false */\n  useAscii?: boolean\n  /** Horizontal spacing between nodes. Default: 5 */\n  paddingX?: number\n  /** Vertical spacing between nodes. Default: 5 */\n  paddingY?: number\n  /** Padding inside node boxes. Default: 1 */\n  boxBorderPadding?: number\n}\n\n/**\n * Detect the diagram type from the mermaid source text.\n * Mirrors the detection logic in src/index.ts for the SVG renderer.\n */\nfunction detectDiagramType(text: string): 'flowchart' | 'sequence' | 'class' | 'er' {\n  const firstLine = text.trim().split('\\n')[0]?.trim().toLowerCase() ?? ''\n\n  if (/^sequencediagram\\s*$/.test(firstLine)) return 'sequence'\n  if (/^classdiagram\\s*$/.test(firstLine)) return 'class'\n  if (/^erdiagram\\s*$/.test(firstLine)) return 'er'\n\n  // Default: flowchart/state (handled by parseMermaid internally)\n  return 'flowchart'\n}\n\n/**\n * Render Mermaid diagram text to an ASCII/Unicode string.\n *\n * Synchronous  no async layout engine needed (unlike the SVG renderer).\n * Auto-detects diagram type from the header line and dispatches to\n * the appropriate renderer.\n *\n * @param text - Mermaid source text (any supported diagram type)\n * @param options - Rendering options\n * @returns Multi-line ASCII/Unicode string\n *\n * @example\n * ```ts\n * const result = renderMermaidAscii(`\n *   graph LR\n *     A --> B --> C\n * `, { useAscii: true })\n *\n * // Output:\n * // +---+     +---+     +---+\n * // |   |     |   |     |   |\n * // | A |---->| B |---->| C |\n * // |   |     |   |     |   |\n * // +---+     +---+     +---+\n * ```\n */\nexport function renderMermaidAscii(\n  text: string,\n  options: AsciiRenderOptions = {},\n): string {\n  const config: AsciiConfig = {\n    useAscii: options.useAscii ?? false,\n    paddingX: options.paddingX ?? 5,\n    paddingY: options.paddingY ?? 5,\n    boxBorderPadding: options.boxBorderPadding ?? 1,\n    graphDirection: 'TD', // default, overridden for flowcharts below\n  }\n\n  const diagramType = detectDiagramType(text)\n\n  switch (diagramType) {\n    case 'sequence':\n      return renderSequenceAscii(text, config)\n\n    case 'class':\n      return renderClassAscii(text, config)\n\n    case 'er':\n      return renderErAscii(text, config)\n\n    case 'flowchart':\n    default: {\n      // Flowchart + state diagram pipeline (original)\n      const parsed = parseMermaid(text)\n\n      // Normalize direction for grid layout.\n      // BT is laid out as TD then flipped vertically after drawing.\n      // RL is treated as LR (full RL support not yet implemented).\n      if (parsed.direction === 'LR' || parsed.direction === 'RL') {\n        config.graphDirection = 'LR'\n      } else {\n        config.graphDirection = 'TD'\n      }\n\n      const graph = convertToAsciiGraph(parsed, config)\n      createMapping(graph)\n      drawGraph(graph)\n\n      // BT: flip the finished canvas vertically so the flow runs bottomtop.\n      // The grid layout ran as TD; flipping + character remapping produces BT.\n      if (parsed.direction === 'BT') {\n        flipCanvasVertically(graph.canvas)\n      }\n\n      return canvasToString(graph.canvas)\n    }\n  }\n}\n","// ============================================================================\n// Font metrics  character width estimates for Inter at different sizes.\n// Used to approximate text bounding boxes without DOM measurement.\n// These are calibrated for Inter's typical glyph widths.\n//\n// NOTE: Theme/color system has moved to src/theme.ts. This file only\n// contains font metrics, spacing constants, and stroke widths.\n// ============================================================================\n\n/** Average character width in px at the given font size and weight (proportional font) */\nexport function estimateTextWidth(text: string, fontSize: number, fontWeight: number): number {\n  // Inter average character widths as fraction of fontSize, per weight.\n  // Heavier weights are slightly wider.\n  const widthRatio = fontWeight >= 600 ? 0.58 : fontWeight >= 500 ? 0.55 : 0.52\n  return text.length * fontSize * widthRatio\n}\n\n/** Average character width in px for monospace fonts (uniform glyph width) */\nexport function estimateMonoTextWidth(text: string, fontSize: number): number {\n  // Monospace fonts have uniform character width  0.6 of fontSize matches actual\n  // glyph widths for JetBrains Mono / SF Mono / Fira Code at small sizes (11px).\n  // Previous value of 0.55 underestimated widths, causing class member labels to\n  // extend beyond their box boundaries.\n  return text.length * fontSize * 0.6\n}\n\n/** Monospace font family used for code-like text (class members, types) */\nexport const MONO_FONT = \"'JetBrains Mono'\" as const\n\n/** Full CSS fallback chain for monospace text */\nexport const MONO_FONT_STACK = `${MONO_FONT}, 'SF Mono', 'Fira Code', ui-monospace, monospace` as const\n\n/** Fixed font sizes used in the renderer (in px) */\nexport const FONT_SIZES = {\n  /** Node label text */\n  nodeLabel: 13,\n  /** Edge label text */\n  edgeLabel: 11,\n  /** Subgraph header text */\n  groupHeader: 12,\n} as const\n\n/** Font weights used per element type */\nexport const FONT_WEIGHTS = {\n  nodeLabel: 500,\n  edgeLabel: 400,\n  groupHeader: 600,\n} as const\n\n// ============================================================================\n// Spacing & sizing constants\n// ============================================================================\n\n/** Vertical gap between a subgraph header band and the content area below it (px).\n * Without this, nested subgraph headers sit flush against their parent's header band. */\nexport const GROUP_HEADER_CONTENT_PAD = 8\n\n/** Padding inside node shapes */\nexport const NODE_PADDING = {\n  /** Horizontal padding inside rectangles/rounded/stadium */\n  horizontal: 16,\n  /** Vertical padding inside rectangles/rounded/stadium */\n  vertical: 10,\n  /** Extra padding for diamond shapes (they need more space due to rotation) */\n  diamondExtra: 24,\n} as const\n\n/** Stroke widths per element type (in px) */\nexport const STROKE_WIDTHS = {\n  outerBox: 1,\n  innerBox: 0.75,\n  connector: 0.75,\n} as const\n\n/**\n * Vertical shift applied to all text elements for font-agnostic centering.\n *\n * Instead of relying on `dominant-baseline=\"central\"` (which each font interprets\n * differently based on its own ascent/descent metrics), we use the default alphabetic\n * baseline and shift down by 0.35em. This places the optical center of text at the\n * y coordinate, regardless of font family (Inter, JetBrains Mono, system fallbacks).\n *\n * The 0.35em value approximates the distance from alphabetic baseline to visual\n * center of Latin text. Using `em` units ensures it scales with font size.\n */\nexport const TEXT_BASELINE_SHIFT = '0.35em' as const\n\n/** Arrow head dimensions */\nexport const ARROW_HEAD = {\n  width: 8,\n  height: 4.8,\n} as const\n\n","// ============================================================================\n// Dagre layout adapter  shared utilities for @dagrejs/dagre integration\n//\n// Provides:\n//   1. snapToOrthogonal()        post-processes edge points into 90-degree segments\n//   2. centerToTopLeft()         converts dagre's center-based coords to top-left\n//   3. clipToDiamondBoundary()   projects rectangle-boundary points onto the diamond\n//   4. clipEndpointsToNodes()    fixes endpoints after orthogonalization\n//\n// Dagre outputs node positions as center coordinates and edge points that\n// may not be strictly orthogonal. These helpers bridge the gap so our SVG\n// renderers receive the same top-left coords and orthogonal edge paths\n// they previously got from ELK.\n// ============================================================================\n\nimport type { Point } from './types.ts'\n\n/**\n * Convert dagre's center-based node coordinates to top-left origin.\n * Dagre returns (x, y) as the center of the node bounding box.\n * Our renderers expect top-left coordinates.\n */\nexport function centerToTopLeft(cx: number, cy: number, width: number, height: number): Point {\n  return { x: cx - width / 2, y: cy - height / 2 }\n}\n\n/**\n * Project a point from the rectangular bounding box onto the diamond boundary.\n *\n * Dagre treats all nodes as rectangles, so edge connection points land on the\n * rectangle boundary. For diamond shapes (rotated squares), the actual visual\n * boundary is an inscribed diamond whose vertices touch the rectangle's edge\n * midpoints. At non-cardinal angles, the rectangle boundary is *outside* the\n * diamond  making edges appear to float in the air.\n *\n * Math: the diamond boundary satisfies |dx|/hw + |dy|/hh = 1 where (dx,dy) is\n * the offset from center and (hw,hh) are half-width/height. We scale the\n * direction vector so it lands exactly on this boundary.\n */\nexport function clipToDiamondBoundary(\n  point: Point,\n  cx: number,\n  cy: number,\n  hw: number,\n  hh: number,\n): Point {\n  const dx = point.x - cx\n  const dy = point.y - cy\n  // Point is at (or very near) center  nothing to clip\n  if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return point\n  // Scale the direction vector to land on the diamond boundary\n  const scale = 1 / (Math.abs(dx) / hw + Math.abs(dy) / hh)\n  return { x: cx + scale * dx, y: cy + scale * dy }\n}\n\n/**\n * Project a point from the rectangular bounding box onto the circle boundary.\n *\n * Dagre treats all nodes as rectangles, so edge connection points land on the\n * rectangle boundary. For circular shapes (circle, doublecircle, state-start,\n * state-end), the actual visual boundary is inscribed within the rectangle.\n * At non-cardinal angles, the rectangle boundary is *outside* the circle \n * making edges appear to float in the air.\n *\n * Math: scale the direction vector (from center to point) so its length equals\n * the circle radius.\n */\nexport function clipToCircleBoundary(\n  point: Point,\n  cx: number,\n  cy: number,\n  r: number,\n): Point {\n  const dx = point.x - cx\n  const dy = point.y - cy\n  const dist = Math.sqrt(dx * dx + dy * dy)\n  // Point is at (or very near) center  nothing to clip\n  if (dist < 0.5) return point\n  const scale = r / dist\n  return { x: cx + scale * dx, y: cy + scale * dy }\n}\n\n/**\n * Post-process dagre edge points into strictly orthogonal (90-degree) segments.\n *\n * Dagre's Sugiyama layout routes edges through intermediate dummy nodes at each\n * rank, so most segments are already axis-aligned. However, when source and target\n * are at different horizontal positions, diagonal segments can appear.\n *\n * Strategy: walk consecutive point pairs. If both x and y differ, insert an\n * intermediate bend point to create an L-shaped orthogonal path. The bend\n * direction depends on the layout axis:\n *   - verticalFirst=true  (TD/BT): drop vertically, then adjust sideways\n *   - verticalFirst=false (LR/RL): move sideways, then adjust vertically\n *\n * After orthogonalization, collinear points (three consecutive points on the\n * same axis) are eliminated to avoid redundant micro-segments.\n */\nexport function snapToOrthogonal(points: Point[], verticalFirst = true): Point[] {\n  if (points.length < 2) return points\n\n  const result: Point[] = [points[0]!]\n\n  for (let i = 1; i < points.length; i++) {\n    const prev = result[result.length - 1]!\n    const curr = points[i]!\n\n    const dx = Math.abs(curr.x - prev.x)\n    const dy = Math.abs(curr.y - prev.y)\n\n    // If already axis-aligned (or close enough), keep as-is\n    if (dx < 1 || dy < 1) {\n      result.push(curr)\n      continue\n    }\n\n    // Insert an L-bend whose direction matches the layout flow.\n    // TD/BT layouts: vertical first  edge drops along the rank axis, then adjusts.\n    // LR/RL layouts: horizontal first  edge moves along the rank axis, then adjusts.\n    if (verticalFirst) {\n      result.push({ x: prev.x, y: curr.y })\n    } else {\n      result.push({ x: curr.x, y: prev.y })\n    }\n    result.push(curr)\n  }\n\n  // Eliminate collinear points  if three consecutive points share the same x\n  // (vertical segment) or same y (horizontal segment), the middle point is\n  // redundant and creates visual artifacts at polyline corners.\n  return removeCollinear(result)\n}\n\n/** Remove middle points from three-in-a-row collinear sequences. */\nfunction removeCollinear(pts: Point[]): Point[] {\n  if (pts.length < 3) return pts\n  const out: Point[] = [pts[0]!]\n  for (let i = 1; i < pts.length - 1; i++) {\n    const a = out[out.length - 1]!\n    const b = pts[i]!\n    const c = pts[i + 1]!\n    // Skip b if a-b-c are all on the same horizontal or vertical line\n    const sameX = Math.abs(a.x - b.x) < 1 && Math.abs(b.x - c.x) < 1\n    const sameY = Math.abs(a.y - b.y) < 1 && Math.abs(b.y - c.y) < 1\n    if (sameX || sameY) continue\n    out.push(b)\n  }\n  out.push(pts[pts.length - 1]!)\n  return out\n}\n\n/**\n * Node rectangle for endpoint clipping  uses dagre's center-based coordinates.\n */\nexport interface NodeRect {\n  /** Center x (dagre coordinate) */\n  cx: number\n  /** Center y (dagre coordinate) */\n  cy: number\n  /** Half-width */\n  hw: number\n  /** Half-height */\n  hh: number\n}\n\n/**\n * Clip edge endpoints to the correct side of rectangular node boundaries.\n *\n * After snapToOrthogonal(), the final/first segment direction may differ from\n * dagre's original boundary intersection direction. Dagre computes boundary\n * points based on the diagonal direction between nodes, but orthogonalization\n * converts the path to L-bends  changing the approach direction of the\n * first/last segment.\n *\n * Example: in a TB layout, dagre places the target endpoint at the TOP of a\n * node (correct for a diagonal approach). After snapToOrthogonal, the last\n * segment becomes horizontal  but the endpoint stays on the top edge. The\n * arrow visually enters the box from the side at the top, going \"inside.\"\n *\n * This function corrects both endpoints so they connect to the side the edge\n * actually approaches from:\n *   - Horizontal last segment  endpoint on left/right side\n *   - Vertical last segment   endpoint on top/bottom\n *   - Similarly for the first segment and source node\n *\n * When the edge path is within the node's bounds, connects at the natural\n * position to avoid unnecessary bends. Otherwise routes to node center.\n *\n * For 2-point edges (direct connections), clips based on the overall direction\n * between endpoints to ensure arrowheads render at node boundaries.\n */\nexport function clipEndpointsToNodes(\n  points: Point[],\n  sourceNode: NodeRect | null,\n  targetNode: NodeRect | null,\n): Point[] {\n  if (points.length < 2) return points\n  const result = points.map(p => ({ ...p }))\n\n  // --- Fix target endpoint ---\n  if (targetNode) {\n    const last = result.length - 1\n\n    if (points.length === 2) {\n      // 2-point edge: clip based on overall direction between endpoints\n      // This ensures arrowheads render at node boundaries, not inside nodes\n      const first = result[0]!\n      const curr = result[last]!\n      const dx = Math.abs(curr.x - first.x)\n      const dy = Math.abs(curr.y - first.y)\n\n      if (dy >= dx) {\n        // Primarily vertical  clip to top/bottom\n        const approachFromTop = curr.y > first.y\n        const sideY = approachFromTop\n          ? targetNode.cy - targetNode.hh\n          : targetNode.cy + targetNode.hh\n        result[last] = { x: curr.x, y: sideY }\n      } else {\n        // Primarily horizontal  clip to left/right\n        const approachFromLeft = curr.x > first.x\n        const sideX = approachFromLeft\n          ? targetNode.cx - targetNode.hw\n          : targetNode.cx + targetNode.hw\n        result[last] = { x: sideX, y: curr.y }\n      }\n    } else {\n      // 3+ point edge: use last segment direction\n      const prev = result[last - 1]!\n      const curr = result[last]!\n      const dx = Math.abs(curr.x - prev.x)\n      const dy = Math.abs(curr.y - prev.y)\n\n      // Strictly axis-aligned segments (< 1px deviation) route to center for visual balance.\n      // Primarily axis-aligned segments (dx >> dy) can use natural positions within bounds.\n      const isStrictlyHorizontal = dy < 1 && dx >= 1\n      const isStrictlyVertical = dx < 1 && dy >= 1\n      const isPrimarilyHorizontal = !isStrictlyHorizontal && !isStrictlyVertical && dy < dx\n      const isPrimarilyVertical = !isStrictlyHorizontal && !isStrictlyVertical && dx < dy\n\n      if (isStrictlyHorizontal) {\n        // Strictly horizontal  route to center for visual balance\n        const approachFromLeft = curr.x > prev.x\n        const sideX = approachFromLeft\n          ? targetNode.cx - targetNode.hw\n          : targetNode.cx + targetNode.hw\n        result[last] = { x: sideX, y: targetNode.cy }\n        result[last - 1] = { ...prev, y: targetNode.cy }\n      } else if (isStrictlyVertical) {\n        // Strictly vertical  route to center for visual balance\n        const approachFromTop = curr.y > prev.y\n        const sideY = approachFromTop\n          ? targetNode.cy - targetNode.hh\n          : targetNode.cy + targetNode.hh\n        result[last] = { x: targetNode.cx, y: sideY }\n        result[last - 1] = { ...prev, x: targetNode.cx }\n      } else if (isPrimarilyHorizontal) {\n        // Primarily horizontal  use natural Y if within bounds\n        const approachFromLeft = curr.x > prev.x\n        const sideX = approachFromLeft\n          ? targetNode.cx - targetNode.hw\n          : targetNode.cx + targetNode.hw\n\n        const withinVerticalBounds =\n          prev.y >= targetNode.cy - targetNode.hh &&\n          prev.y <= targetNode.cy + targetNode.hh\n\n        if (withinVerticalBounds) {\n          result[last] = { x: sideX, y: prev.y }\n        } else {\n          result[last] = { x: sideX, y: targetNode.cy }\n          result[last - 1] = { ...prev, y: targetNode.cy }\n        }\n      } else if (isPrimarilyVertical) {\n        // Primarily vertical  use natural X if within bounds\n        const approachFromTop = curr.y > prev.y\n        const sideY = approachFromTop\n          ? targetNode.cy - targetNode.hh\n          : targetNode.cy + targetNode.hh\n\n        const withinHorizontalBounds =\n          prev.x >= targetNode.cx - targetNode.hw &&\n          prev.x <= targetNode.cx + targetNode.hw\n\n        if (withinHorizontalBounds) {\n          result[last] = { x: prev.x, y: sideY }\n        } else {\n          result[last] = { x: targetNode.cx, y: sideY }\n          result[last - 1] = { ...prev, x: targetNode.cx }\n        }\n      }\n    }\n  }\n\n  // --- Fix source endpoint (first segment) ---\n  if (sourceNode && points.length >= 3) {\n    // Only process 3+ point edges for source  2-point edges don't need source adjustment\n    const first = result[0]!\n    const next = result[1]!\n    const dx = Math.abs(next.x - first.x)\n    const dy = Math.abs(next.y - first.y)\n\n    // Strictly axis-aligned segments (< 1px deviation) route to center for visual balance.\n    // Primarily axis-aligned segments (dx >> dy) can use natural positions within bounds.\n    const isStrictlyHorizontal = dy < 1 && dx >= 1\n    const isStrictlyVertical = dx < 1 && dy >= 1\n    const isPrimarilyHorizontal = !isStrictlyHorizontal && !isStrictlyVertical && dy < dx\n    const isPrimarilyVertical = !isStrictlyHorizontal && !isStrictlyVertical && dx < dy\n\n    if (isStrictlyHorizontal) {\n      // Strictly horizontal  route from center for visual balance\n      const exitToRight = next.x > first.x\n      const sideX = exitToRight\n        ? sourceNode.cx + sourceNode.hw\n        : sourceNode.cx - sourceNode.hw\n      result[0] = { x: sideX, y: sourceNode.cy }\n      result[1] = { ...result[1]!, y: sourceNode.cy }\n    } else if (isStrictlyVertical) {\n      // Strictly vertical  route from center for visual balance\n      const exitDownward = next.y > first.y\n      const sideY = exitDownward\n        ? sourceNode.cy + sourceNode.hh\n        : sourceNode.cy - sourceNode.hh\n      result[0] = { x: sourceNode.cx, y: sideY }\n      result[1] = { ...result[1]!, x: sourceNode.cx }\n    } else if (isPrimarilyHorizontal) {\n      // Primarily horizontal  use natural Y if within bounds\n      const exitToRight = next.x > first.x\n      const sideX = exitToRight\n        ? sourceNode.cx + sourceNode.hw\n        : sourceNode.cx - sourceNode.hw\n\n      const withinVerticalBounds =\n        next.y >= sourceNode.cy - sourceNode.hh &&\n        next.y <= sourceNode.cy + sourceNode.hh\n\n      if (withinVerticalBounds) {\n        result[0] = { x: sideX, y: next.y }\n      } else {\n        result[0] = { x: sideX, y: sourceNode.cy }\n        result[1] = { ...result[1]!, y: sourceNode.cy }\n      }\n    } else if (isPrimarilyVertical) {\n      // Primarily vertical  use natural X if within bounds\n      const exitDownward = next.y > first.y\n      const sideY = exitDownward\n        ? sourceNode.cy + sourceNode.hh\n        : sourceNode.cy - sourceNode.hh\n\n      const withinHorizontalBounds =\n        next.x >= sourceNode.cx - sourceNode.hw &&\n        next.x <= sourceNode.cx + sourceNode.hw\n\n      if (withinHorizontalBounds) {\n        result[0] = { x: next.x, y: sideY }\n      } else {\n        result[0] = { x: sourceNode.cx, y: sideY }\n        result[1] = { ...result[1]!, x: sourceNode.cx }\n      }\n    }\n  }\n\n  return result\n}\n","// @ts-expect-error  dagre types are declared for the package root, not the dist path;\n// importing the pre-built browser bundle avoids Bun.build hanging on 30+ CJS file resolution\nimport dagre from '@dagrejs/dagre/dist/dagre.js'\nimport type { MermaidGraph, MermaidSubgraph, PositionedGraph, PositionedNode, PositionedEdge, PositionedGroup, Point, RenderOptions } from './types.ts'\nimport { estimateTextWidth, FONT_SIZES, FONT_WEIGHTS, NODE_PADDING, GROUP_HEADER_CONTENT_PAD } from './styles.ts'\nimport { centerToTopLeft, snapToOrthogonal, clipToDiamondBoundary, clipToCircleBoundary, clipEndpointsToNodes } from './dagre-adapter.ts'\n\n/** Shapes that render as circles  need edge endpoint clipping to the circle boundary */\nconst CIRCULAR_SHAPES = new Set(['circle', 'doublecircle', 'state-start', 'state-end'])\n\n/** Non-rectangular shapes  skip rectangular endpoint clipping for these (they use\n *  their own boundary equations via clipToDiamondBoundary / clipToCircleBoundary) */\nconst NON_RECT_SHAPES = new Set(['diamond', 'circle', 'doublecircle', 'state-start', 'state-end'])\n\n// ============================================================================\n// Layout engine  converts MermaidGraph to PositionedGraph via dagre\n//\n// Pipeline:\n//   1. Estimate node sizes from label text + shape padding\n//   2. Build dagre graph (nodes, edges, compound parents for subgraphs)\n//   3. Run dagre.layout() synchronously\n//   4. Extract positions back into our PositionedGraph format\n//\n// Dagre differences from ELK:\n//   - Synchronous (no web worker / WASM)\n//   - Node coords are center-based (converted to top-left via adapter)\n//   - Edge points may not be orthogonal (post-processed via adapter)\n//   - Compound nodes use setParent() instead of nested children JSON\n//   - All coordinates are absolute (no container-relative offsets)\n// ============================================================================\n\n/** Default render options (layout-only  color defaults are in theme.ts) */\nconst DEFAULTS: Required<Pick<RenderOptions, 'font' | 'padding' | 'nodeSpacing' | 'layerSpacing'>> = {\n  font: 'Inter',\n  padding: 40,\n  nodeSpacing: 24,\n  layerSpacing: 40,\n}\n\n// ============================================================================\n// Two-pass layout for subgraph direction overrides\n//\n// Dagre only supports a single global rankdir. When a subgraph has a different\n// direction (e.g. `direction LR` inside a `graph TD`), we pre-compute its\n// internal layout in a separate dagre pass, then inject the result as a\n// fixed-size placeholder in the main layout.\n// ============================================================================\n\n/** Pre-computed layout data for a direction-overridden subgraph */\ninterface PreComputedSubgraph {\n  id: string\n  label: string\n  /** Bounding box for the placeholder node in the main layout */\n  width: number\n  height: number\n  /** Internal nodes positioned relative to (0,0) of the bounding box */\n  nodes: PositionedNode[]\n  /** Internal edges positioned relative to (0,0) of the bounding box */\n  edges: PositionedEdge[]\n  /** Nested subgroup boxes positioned relative to (0,0) */\n  groups: PositionedGroup[]\n  /** All node IDs contained in this subgraph */\n  nodeIds: Set<string>\n  /** Indices of edges in graph.edges[] that are internal to this subgraph */\n  internalEdgeIndices: Set<number>\n}\n\n/**\n * Pre-compute the internal layout of a subgraph that has a direction override.\n *\n * Runs a separate dagre layout using the subgraph's direction as rankdir,\n * with only the subgraph's internal nodes and edges. Returns positioned\n * elements relative to a (0,0) origin, plus the overall bounding box.\n */\nfunction preComputeSubgraphLayout(\n  sg: MermaidSubgraph,\n  graph: MermaidGraph,\n  opts: Required<Pick<RenderOptions, 'font' | 'padding' | 'nodeSpacing' | 'layerSpacing'>>,\n): PreComputedSubgraph {\n  const subG = new dagre.graphlib.Graph({ directed: true, compound: true })\n  subG.setGraph({\n    rankdir: directionToDagre(sg.direction!),\n    acyclicer: 'greedy',\n    nodesep: opts.nodeSpacing,\n    ranksep: opts.layerSpacing,\n    // Tighter margins for subgraph internals  the parent group provides outer padding\n    marginx: 16,\n    marginy: 12,\n  })\n  subG.setDefaultEdgeLabel(() => ({}))\n\n  // Collect all node IDs in this subgraph (including nested children)\n  const nodeIds = new Set<string>()\n  nodeIds.add(sg.id)\n  collectSubgraphNodeIds(sg, nodeIds)\n\n  // Add direct child nodes\n  for (const nodeId of sg.nodeIds) {\n    const node = graph.nodes.get(nodeId)\n    if (node) {\n      const size = estimateNodeSize(nodeId, node.label, node.shape)\n      subG.setNode(nodeId, { label: node.label, width: size.width, height: size.height })\n    }\n  }\n\n  // Add nested subgraphs as compound nodes (they keep the parent's direction)\n  for (const child of sg.children) {\n    addSubgraphToDagre(subG, child, graph)\n  }\n\n  // Identify and add internal edges (both endpoints inside this subgraph)\n  const internalEdgeIndices = new Set<number>()\n  for (let i = 0; i < graph.edges.length; i++) {\n    const edge = graph.edges[i]!\n    if (nodeIds.has(edge.source) && nodeIds.has(edge.target)) {\n      internalEdgeIndices.add(i)\n      const edgeLabel: Record<string, unknown> = { _index: i }\n      if (edge.label) {\n        edgeLabel.label = edge.label\n        edgeLabel.width = estimateTextWidth(edge.label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel) + 8\n        edgeLabel.height = FONT_SIZES.edgeLabel + 6\n        edgeLabel.labelpos = 'c'\n      }\n      subG.setEdge(edge.source, edge.target, edgeLabel)\n    }\n  }\n\n  // Run layout on the isolated subgraph\n  dagre.layout(subG)\n\n  // Determine orthogonal bend direction for the overridden direction\n  const verticalFirst = sg.direction === 'TD' || sg.direction === 'TB' || sg.direction === 'BT'\n\n  // Build a set of subgraph IDs within this subgraph for node/group separation\n  const nestedSubgraphIds = new Set<string>()\n  for (const child of sg.children) {\n    collectAllSubgraphIds(child, nestedSubgraphIds)\n  }\n\n  // Extract positioned nodes (skip nested subgraph compound nodes)\n  const nodes: PositionedNode[] = []\n  for (const nodeId of subG.nodes()) {\n    if (nestedSubgraphIds.has(nodeId)) continue\n    const mNode = graph.nodes.get(nodeId)\n    if (!mNode) continue\n    const dagreNode = subG.node(nodeId)\n    if (!dagreNode) continue\n    const topLeft = centerToTopLeft(dagreNode.x, dagreNode.y, dagreNode.width, dagreNode.height)\n    nodes.push({\n      id: nodeId,\n      label: mNode.label,\n      shape: mNode.shape,\n      x: topLeft.x,\n      y: topLeft.y,\n      width: dagreNode.width,\n      height: dagreNode.height,\n      inlineStyle: resolveNodeStyle(graph, nodeId),\n    })\n  }\n\n  // Extract positioned edges\n  const edges: PositionedEdge[] = subG.edges().map(edgeObj => {\n    const dagreEdge = subG.edge(edgeObj)\n    const originalEdge = graph.edges[dagreEdge._index as number]!\n    const rawPoints: Point[] = dagreEdge.points ?? []\n\n    // Clip edge endpoints to non-rectangular shape boundaries.\n    // Dagre computes endpoints on the rectangular bounding box, but diamonds\n    // and circles are inscribed within the rectangle  endpoints float in the air.\n    if (rawPoints.length > 0) {\n      const srcShape = graph.nodes.get(edgeObj.v)?.shape\n      if (srcShape === 'diamond') {\n        const sn = subG.node(edgeObj.v)\n        rawPoints[0] = clipToDiamondBoundary(rawPoints[0]!, sn.x, sn.y, sn.width / 2, sn.height / 2)\n      } else if (srcShape && CIRCULAR_SHAPES.has(srcShape)) {\n        const sn = subG.node(edgeObj.v)\n        rawPoints[0] = clipToCircleBoundary(rawPoints[0]!, sn.x, sn.y, Math.min(sn.width, sn.height) / 2)\n      }\n      const tgtShape = graph.nodes.get(edgeObj.w)?.shape\n      if (tgtShape === 'diamond') {\n        const tn = subG.node(edgeObj.w)\n        const last = rawPoints.length - 1\n        rawPoints[last] = clipToDiamondBoundary(rawPoints[last]!, tn.x, tn.y, tn.width / 2, tn.height / 2)\n      } else if (tgtShape && CIRCULAR_SHAPES.has(tgtShape)) {\n        const tn = subG.node(edgeObj.w)\n        const last = rawPoints.length - 1\n        rawPoints[last] = clipToCircleBoundary(rawPoints[last]!, tn.x, tn.y, Math.min(tn.width, tn.height) / 2)\n      }\n    }\n\n    const orthoPoints = snapToOrthogonal(rawPoints, verticalFirst)\n\n    // Clip rectangular endpoints to the correct side after orthogonalization.\n    // Non-rectangular shapes (diamond, circle) are already handled above.\n    const srcShape = graph.nodes.get(edgeObj.v)?.shape\n    const tgtShape = graph.nodes.get(edgeObj.w)?.shape\n    const srcRect = (srcShape && !NON_RECT_SHAPES.has(srcShape)) || !srcShape\n      ? (() => { const sn = subG.node(edgeObj.v); return sn ? { cx: sn.x, cy: sn.y, hw: sn.width / 2, hh: sn.height / 2 } : null })()\n      : null\n    const tgtRect = (tgtShape && !NON_RECT_SHAPES.has(tgtShape)) || !tgtShape\n      ? (() => { const tn = subG.node(edgeObj.w); return tn ? { cx: tn.x, cy: tn.y, hw: tn.width / 2, hh: tn.height / 2 } : null })()\n      : null\n    const points = clipEndpointsToNodes(orthoPoints, srcRect, tgtRect)\n\n    let labelPosition: Point | undefined\n    if (originalEdge.label && dagreEdge.x != null && dagreEdge.y != null) {\n      labelPosition = { x: dagreEdge.x, y: dagreEdge.y }\n    }\n\n    return {\n      source: originalEdge.source,\n      target: originalEdge.target,\n      label: originalEdge.label,\n      style: originalEdge.style,\n      hasArrowStart: originalEdge.hasArrowStart,\n      hasArrowEnd: originalEdge.hasArrowEnd,\n      points,\n      labelPosition,\n    }\n  })\n\n  // Extract nested subgroup positions\n  const groups: PositionedGroup[] = sg.children.map(child => extractGroup(subG, child))\n\n  const graphInfo = subG.graph()\n  return {\n    id: sg.id,\n    label: sg.label,\n    width: graphInfo.width ?? 200,\n    height: graphInfo.height ?? 100,\n    nodes,\n    edges,\n    groups,\n    nodeIds,\n    internalEdgeIndices,\n  }\n}\n\n/**\n * Lay out a parsed mermaid graph using dagre.\n * Returns a fully positioned graph ready for SVG rendering.\n *\n * Kept async for API compatibility  dagre itself is synchronous.\n */\nexport async function layoutGraph(\n  graph: MermaidGraph,\n  options: RenderOptions = {}\n): Promise<PositionedGraph> {\n  const opts = { ...DEFAULTS, ...options }\n\n  // -------------------------------------------------------------------------\n  // Phase 1: Pre-compute layouts for subgraphs with direction overrides.\n  //\n  // Dagre only supports a single global rankdir. Subgraphs with a different\n  // direction (e.g. `direction LR` inside `graph TD`) get their own dagre\n  // layout pass. The result is injected as a fixed-size placeholder in the\n  // main layout, then composited back after positioning.\n  // -------------------------------------------------------------------------\n  const preComputed = new Map<string, PreComputedSubgraph>()\n  for (const sg of graph.subgraphs) {\n    if (sg.direction && sg.direction !== graph.direction) {\n      preComputed.set(sg.id, preComputeSubgraphLayout(sg, graph, opts))\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Phase 2: Build the main dagre graph.\n  // Pre-computed subgraphs become fixed-size leaf nodes instead of compound nodes.\n  // -------------------------------------------------------------------------\n  const g = new dagre.graphlib.Graph({ directed: true, compound: true })\n  g.setGraph({\n    rankdir: directionToDagre(graph.direction),\n    acyclicer: 'greedy',\n    nodesep: opts.nodeSpacing,\n    ranksep: opts.layerSpacing,\n    marginx: opts.padding,\n    marginy: opts.padding,\n  })\n  g.setDefaultEdgeLabel(() => ({}))\n\n  // Collect node IDs that belong to subgraphs (to exclude from root level).\n  // Also exclude the subgraph IDs themselves  in state diagrams, a composite\n  // state like \"Processing\" exists as both a node (from transition references)\n  // and a subgraph (from the composite definition). Without this exclusion,\n  // dagre receives a duplicate node for the same ID.\n  const subgraphNodeIds = new Set<string>()\n  for (const sg of graph.subgraphs) {\n    subgraphNodeIds.add(sg.id)\n    collectSubgraphNodeIds(sg, subgraphNodeIds)\n  }\n\n  // Add top-level nodes (those not in any subgraph)\n  for (const [id, node] of graph.nodes) {\n    if (!subgraphNodeIds.has(id)) {\n      const size = estimateNodeSize(id, node.label, node.shape)\n      g.setNode(id, { label: node.label, width: size.width, height: size.height })\n    }\n  }\n\n  // Add subgraph compound nodes and their children recursively.\n  // Pre-computed subgraphs are added as fixed-size leaf nodes instead.\n  for (const sg of graph.subgraphs) {\n    if (preComputed.has(sg.id)) {\n      const pc = preComputed.get(sg.id)!\n      g.setNode(sg.id, { width: pc.width, height: pc.height })\n    } else {\n      addSubgraphToDagre(g, sg, graph)\n    }\n  }\n\n  // Build redirect maps for edges that target/originate from compound nodes.\n  // Dagre crashes when edges connect directly to compound parent nodes (known bug\n  // in its ranking algorithm). Workaround: redirect edges to the first/last child\n  // of the subgraph  \"first\" for incoming edges, \"last\" for outgoing.\n  const subgraphEntryNode = new Map<string, string>()\n  const subgraphExitNode = new Map<string, string>()\n  for (const sg of graph.subgraphs) {\n    if (!preComputed.has(sg.id)) {\n      buildSubgraphRedirects(sg, subgraphEntryNode, subgraphExitNode)\n    }\n  }\n\n  // For pre-computed subgraphs, redirect all internal node references to the\n  // placeholder leaf node. External edges to/from internal nodes get routed\n  // to the placeholder boundary; endpoints are fixed up after compositing.\n  for (const [sgId, pc] of preComputed) {\n    for (const nodeId of pc.nodeIds) {\n      subgraphEntryNode.set(nodeId, sgId)\n      subgraphExitNode.set(nodeId, sgId)\n    }\n  }\n\n  // Add edges  skip internal edges of pre-computed subgraphs (handled by pre-computation).\n  // Track cross-boundary edges for post-layout endpoint fixup.\n  const allInternalIndices = new Set<number>()\n  for (const pc of preComputed.values()) {\n    for (const idx of pc.internalEdgeIndices) allInternalIndices.add(idx)\n  }\n\n  // Weight heuristic for stable rank ordering in cyclic graphs (e.g. state diagrams).\n  //\n  // Dagre's acyclicer reverses feedback edges to break cycles, but equal-weight edges\n  // give the ranking algorithm freedom to collapse nodes onto the same rank.\n  // Fix: \"spine\" edges (those that introduce a node as a target for the first time)\n  // get higher weight, biasing dagre to keep them short (1 rank apart). Feedback\n  // edges (target already introduced) keep default weight, allowing them to stretch.\n  const introducedTargets = new Set<string>()\n\n  for (let i = 0; i < graph.edges.length; i++) {\n    if (allInternalIndices.has(i)) continue\n\n    const edge = graph.edges[i]!\n    const source = subgraphExitNode.get(edge.source) ?? edge.source\n    const target = subgraphEntryNode.get(edge.target) ?? edge.target\n    const edgeLabel: Record<string, unknown> = { _index: i }\n    if (edge.label) {\n      edgeLabel.label = edge.label\n      edgeLabel.width = estimateTextWidth(edge.label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel) + 8\n      edgeLabel.height = FONT_SIZES.edgeLabel + 6\n      edgeLabel.labelpos = 'c'\n    }\n\n    // Spine edges get higher weight to maintain sequential ordering\n    if (!introducedTargets.has(target)) {\n      edgeLabel.weight = 2\n      introducedTargets.add(target)\n    }\n\n    g.setEdge(source, target, edgeLabel)\n  }\n\n  // -------------------------------------------------------------------------\n  // Phase 3: Run synchronous layout  mutates g in place.\n  // -------------------------------------------------------------------------\n  try {\n    dagre.layout(g)\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err)\n    throw new Error(`Dagre layout failed: ${message}`)\n  }\n\n  // -------------------------------------------------------------------------\n  // Phase 4: Extract positions and compose pre-computed layouts.\n  // -------------------------------------------------------------------------\n  return extractPositionedGraph(g, graph, opts.padding, preComputed)\n}\n\n// ============================================================================\n// Dagre graph construction helpers\n// ============================================================================\n\n/** Convert mermaid direction to dagre rankdir value */\nfunction directionToDagre(dir: MermaidGraph['direction']): string {\n  switch (dir) {\n    case 'LR': return 'LR'\n    case 'RL': return 'RL'\n    case 'BT': return 'BT'\n    case 'TD':\n    case 'TB':\n    default: return 'TB'\n  }\n}\n\n/** Estimate node size based on label text + shape padding */\nfunction estimateNodeSize(id: string, label: string, shape: string): { width: number; height: number } {\n  const textWidth = estimateTextWidth(label, FONT_SIZES.nodeLabel, FONT_WEIGHTS.nodeLabel)\n\n  let width = textWidth + NODE_PADDING.horizontal * 2\n  let height = FONT_SIZES.nodeLabel + NODE_PADDING.vertical * 2\n\n  // Diamonds need extra space because text is inside a rotated square\n  if (shape === 'diamond') {\n    const side = Math.max(width, height) + NODE_PADDING.diamondExtra\n    width = side\n    height = side\n  }\n\n  // Circles and double circles: bounding box must be square, diameter must fit text rect\n  // For a rect (w x h) inscribed in a circle: diameter >= sqrt(w^2 + h^2)\n  if (shape === 'circle' || shape === 'doublecircle') {\n    const diameter = Math.ceil(Math.sqrt(width * width + height * height)) + 8\n    width = shape === 'doublecircle' ? diameter + 12 : diameter\n    height = width\n  }\n\n  // Hexagons need extra horizontal padding for the angled sides\n  if (shape === 'hexagon') {\n    width += NODE_PADDING.horizontal\n  }\n\n  // Trapezoids need extra horizontal padding for angled edges\n  if (shape === 'trapezoid' || shape === 'trapezoid-alt') {\n    width += NODE_PADDING.horizontal\n  }\n\n  // Asymmetric flag shape needs left padding for the pointed end\n  if (shape === 'asymmetric') {\n    width += 12\n  }\n\n  // Cylinder needs extra vertical space for the ellipse cap\n  if (shape === 'cylinder') {\n    height += 14\n  }\n\n  // State diagram pseudostates  small fixed-size circles\n  if (shape === 'state-start' || shape === 'state-end') {\n    width = 28\n    height = 28\n  }\n\n  // Minimum sizes for aesthetics\n  width = Math.max(width, 60)\n  height = Math.max(height, 36)\n\n  return { width, height }\n}\n\n/**\n * Recursively add a subgraph and its children to the dagre graph.\n *\n * Dagre compound nodes work via setParent(child, parent)  unlike ELK's\n * nested children[] JSON tree. We set padding on compound nodes so dagre\n * allocates space for children plus the subgraph header label.\n */\nfunction addSubgraphToDagre(\n  g: dagre.graphlib.Graph,\n  sg: MermaidSubgraph,\n  graph: MermaidGraph,\n  parentId?: string,\n): void {\n  // Register the subgraph as a compound node.\n  // Note: dagre ignores paddingX/paddingY/clusterLabelPos on compound nodes \n  // they're not in dagre's nodeNumAttrs. Header space is handled by post-processing\n  // in extractPositionedGraph() via expandGroupsForHeaders().\n  g.setNode(sg.id, { label: sg.label })\n\n  // Set parent if this is a nested subgraph\n  if (parentId) {\n    g.setParent(sg.id, parentId)\n  }\n\n  // Add direct child nodes inside this subgraph\n  for (const nodeId of sg.nodeIds) {\n    const node = graph.nodes.get(nodeId)\n    if (node) {\n      const size = estimateNodeSize(nodeId, node.label, node.shape)\n      g.setNode(nodeId, { label: node.label, width: size.width, height: size.height })\n      g.setParent(nodeId, sg.id)\n    }\n  }\n\n  // Add nested subgraphs recursively\n  for (const child of sg.children) {\n    addSubgraphToDagre(g, child, graph, sg.id)\n  }\n}\n\n/**\n * Build redirect maps for subgraph entry/exit nodes.\n *\n * Dagre's ranking algorithm crashes when edges connect to compound parent nodes.\n * This maps each subgraph ID to its first child (entry) and last child (exit),\n * so edges targeting a subgraph get redirected to a real leaf node inside it.\n * Handles nested subgraphs by recursing into children.\n */\nfunction buildSubgraphRedirects(\n  sg: MermaidSubgraph,\n  entryMap: Map<string, string>,\n  exitMap: Map<string, string>,\n): void {\n  // Recurse into nested subgraphs FIRST so their entries are available\n  // for transitive resolution when we set this subgraph's redirects.\n  for (const child of sg.children) {\n    buildSubgraphRedirects(child, entryMap, exitMap)\n  }\n\n  // Collect all direct child IDs (both leaf nodes and nested subgraphs)\n  const childIds = [...sg.nodeIds, ...sg.children.map(c => c.id)]\n\n  if (childIds.length === 0) {\n    // Empty subgraph  no children to redirect to.\n    // Dagre treats it as a regular node (no setParent calls) so edges\n    // targeting it won't trigger the compound-node ranking crash.\n    // Map it to itself so consumers of the redirect maps always get a result.\n    entryMap.set(sg.id, sg.id)\n    exitMap.set(sg.id, sg.id)\n    return\n  }\n\n  // For nested subgraphs as entry/exit: resolve transitively to a leaf node\n  const firstChild = childIds[0]!\n  const lastChild = childIds[childIds.length - 1]!\n  entryMap.set(sg.id, entryMap.get(firstChild) ?? firstChild)\n  exitMap.set(sg.id, exitMap.get(lastChild) ?? lastChild)\n}\n\n/**\n * Resolve the final inline style for a node by merging classDef base styles\n * with any explicit `style` overrides. The renderer only reads inlineStyle,\n * so class-based styles must be folded in at construction time.\n */\nfunction resolveNodeStyle(graph: MermaidGraph, nodeId: string): Record<string, string> | undefined {\n  const className = graph.classAssignments.get(nodeId)\n  const classProps = className ? graph.classDefs.get(className) : undefined\n  const inlineProps = graph.nodeStyles.get(nodeId)\n  if (!classProps && !inlineProps) return undefined\n  // Class styles as base, explicit inline `style` overrides on top\n  return { ...classProps, ...inlineProps }\n}\n\n/** Recursively collect all node IDs that belong to any subgraph */\nfunction collectSubgraphNodeIds(sg: MermaidSubgraph, out: Set<string>): void {\n  for (const id of sg.nodeIds) {\n    out.add(id)\n  }\n  for (const child of sg.children) {\n    collectSubgraphNodeIds(child, out)\n  }\n}\n\n// ============================================================================\n// Position extraction  convert dagre layout results to our PositionedGraph\n// ============================================================================\n\nfunction extractPositionedGraph(\n  g: dagre.graphlib.Graph,\n  graph: MermaidGraph,\n  padding: number,\n  preComputed?: Map<string, PreComputedSubgraph>,\n): PositionedGraph {\n  const nodes: PositionedNode[] = []\n  const groups: PositionedGroup[] = []\n\n  // Build a set of subgraph IDs for distinguishing compound nodes from leaf nodes\n  const subgraphIds = new Set<string>()\n  for (const sg of graph.subgraphs) {\n    collectAllSubgraphIds(sg, subgraphIds)\n  }\n\n  // Collect all pre-computed internal node IDs (they're not in the dagre graph)\n  const preComputedNodeIds = new Set<string>()\n  if (preComputed) {\n    for (const pc of preComputed.values()) {\n      for (const nodeId of pc.nodeIds) preComputedNodeIds.add(nodeId)\n    }\n  }\n\n  // Extract leaf nodes (non-subgraph nodes, non-pre-computed-internal nodes)\n  for (const nodeId of g.nodes()) {\n    if (subgraphIds.has(nodeId)) continue\n\n    const mNode = graph.nodes.get(nodeId)\n    if (!mNode) continue\n\n    const dagreNode = g.node(nodeId)\n    if (!dagreNode) continue\n\n    const topLeft = centerToTopLeft(dagreNode.x, dagreNode.y, dagreNode.width, dagreNode.height)\n\n    nodes.push({\n      id: nodeId,\n      label: mNode.label,\n      shape: mNode.shape,\n      x: topLeft.x,\n      y: topLeft.y,\n      width: dagreNode.width,\n      height: dagreNode.height,\n      inlineStyle: resolveNodeStyle(graph, nodeId),\n    })\n  }\n\n  // Extract subgraph groups recursively from the original subgraph tree structure.\n  // For pre-computed subgraphs, the dagre leaf node position provides the group box.\n  for (const sg of graph.subgraphs) {\n    groups.push(extractGroup(g, sg))\n  }\n\n  // Vertical-first bends for TD/BT layouts; horizontal-first for LR/RL\n  const verticalFirst = graph.direction === 'TD' || graph.direction === 'TB' || graph.direction === 'BT'\n\n  // Extract edges  dagre gives us flat points arrays (no sections/container offsets)\n  const edges: PositionedEdge[] = g.edges().map(edgeObj => {\n    const dagreEdge = g.edge(edgeObj)\n    // Retrieve the original edge index stored during graph construction\n    const originalEdge = graph.edges[dagreEdge._index as number]!\n    const rawPoints: Point[] = dagreEdge.points ?? []\n\n    // Clip edge endpoints to non-rectangular shape boundaries.\n    // Dagre computes endpoints on the rectangular bounding box, but diamonds\n    // and circles are inscribed within the rectangle  endpoints float in the air.\n    if (rawPoints.length > 0) {\n      const srcShape = graph.nodes.get(edgeObj.v)?.shape\n      if (srcShape === 'diamond') {\n        const sn = g.node(edgeObj.v)\n        rawPoints[0] = clipToDiamondBoundary(rawPoints[0]!, sn.x, sn.y, sn.width / 2, sn.height / 2)\n      } else if (srcShape && CIRCULAR_SHAPES.has(srcShape)) {\n        const sn = g.node(edgeObj.v)\n        rawPoints[0] = clipToCircleBoundary(rawPoints[0]!, sn.x, sn.y, Math.min(sn.width, sn.height) / 2)\n      }\n      const tgtShape = graph.nodes.get(edgeObj.w)?.shape\n      if (tgtShape === 'diamond') {\n        const tn = g.node(edgeObj.w)\n        const last = rawPoints.length - 1\n        rawPoints[last] = clipToDiamondBoundary(rawPoints[last]!, tn.x, tn.y, tn.width / 2, tn.height / 2)\n      } else if (tgtShape && CIRCULAR_SHAPES.has(tgtShape)) {\n        const tn = g.node(edgeObj.w)\n        const last = rawPoints.length - 1\n        rawPoints[last] = clipToCircleBoundary(rawPoints[last]!, tn.x, tn.y, Math.min(tn.width, tn.height) / 2)\n      }\n    }\n\n    // Post-process to orthogonal segments (direction-aware bend order)\n    const orthoPoints = snapToOrthogonal(rawPoints, verticalFirst)\n\n    // Clip rectangular endpoints to the correct side after orthogonalization.\n    // Non-rectangular shapes (diamond, circle) are already handled above.\n    const srcShapeForClip = graph.nodes.get(edgeObj.v)?.shape\n    const tgtShapeForClip = graph.nodes.get(edgeObj.w)?.shape\n    const srcRect = (srcShapeForClip && !NON_RECT_SHAPES.has(srcShapeForClip)) || !srcShapeForClip\n      ? (() => { const sn = g.node(edgeObj.v); return sn ? { cx: sn.x, cy: sn.y, hw: sn.width / 2, hh: sn.height / 2 } : null })()\n      : null\n    const tgtRect = (tgtShapeForClip && !NON_RECT_SHAPES.has(tgtShapeForClip)) || !tgtShapeForClip\n      ? (() => { const tn = g.node(edgeObj.w); return tn ? { cx: tn.x, cy: tn.y, hw: tn.width / 2, hh: tn.height / 2 } : null })()\n      : null\n    const points = clipEndpointsToNodes(orthoPoints, srcRect, tgtRect)\n\n    // Dagre returns edge label center position directly as edge.x, edge.y\n    let labelPosition: Point | undefined\n    if (originalEdge.label && dagreEdge.x != null && dagreEdge.y != null) {\n      labelPosition = { x: dagreEdge.x, y: dagreEdge.y }\n    }\n\n    return {\n      source: originalEdge.source,\n      target: originalEdge.target,\n      label: originalEdge.label,\n      style: originalEdge.style,\n      hasArrowStart: originalEdge.hasArrowStart,\n      hasArrowEnd: originalEdge.hasArrowEnd,\n      points,\n      labelPosition,\n    }\n  })\n\n  // ---------------------------------------------------------------------------\n  // Compose pre-computed subgraph layouts into the main layout.\n  //\n  // The main dagre graph positioned each pre-computed subgraph as a leaf node.\n  // Now we inject the internal elements at the correct offset and fix cross-\n  // boundary edge endpoints so they connect to actual internal nodes.\n  // ---------------------------------------------------------------------------\n  if (preComputed && preComputed.size > 0) {\n    // Build a map of all composed node positions for endpoint fixup\n    const nodePositionMap = new Map<string, { cx: number; cy: number }>()\n    for (const n of nodes) {\n      nodePositionMap.set(n.id, { cx: n.x + n.width / 2, cy: n.y + n.height / 2 })\n    }\n\n    for (const [sgId, pc] of preComputed) {\n      // Get the placeholder's position from dagre (center-based)\n      const placeholder = g.node(sgId)\n      if (!placeholder) continue\n      const topLeft = centerToTopLeft(placeholder.x, placeholder.y, placeholder.width, placeholder.height)\n\n      // Inject internal nodes at the correct offset\n      for (const pcNode of pc.nodes) {\n        const composed = {\n          ...pcNode,\n          x: pcNode.x + topLeft.x,\n          y: pcNode.y + topLeft.y,\n        }\n        nodes.push(composed)\n        nodePositionMap.set(composed.id, {\n          cx: composed.x + composed.width / 2,\n          cy: composed.y + composed.height / 2,\n        })\n      }\n\n      // Inject internal edges at the correct offset\n      for (const pcEdge of pc.edges) {\n        edges.push({\n          ...pcEdge,\n          points: pcEdge.points.map(p => ({ x: p.x + topLeft.x, y: p.y + topLeft.y })),\n          labelPosition: pcEdge.labelPosition\n            ? { x: pcEdge.labelPosition.x + topLeft.x, y: pcEdge.labelPosition.y + topLeft.y }\n            : undefined,\n        })\n      }\n\n      // Update the group's nested children positions (from pre-computation)\n      const group = findGroupById(groups, sgId)\n      if (group && pc.groups.length > 0) {\n        group.children = pc.groups.map(cg => offsetGroup(cg, topLeft.x, topLeft.y))\n      }\n    }\n\n    // Fix cross-boundary edge endpoints.\n    // Edges that originally connected to internal nodes were redirected to the\n    // placeholder during main layout. Now replace the endpoint with the actual\n    // composed node position and re-run orthogonal snapping.\n    for (const edge of edges) {\n      // Skip edges that are from pre-computed layouts (already correctly routed)\n      if (preComputedNodeIds.has(edge.source) && preComputedNodeIds.has(edge.target)) continue\n\n      let modified = false\n\n      // Fix source endpoint  if the source is inside a pre-computed subgraph\n      if (preComputedNodeIds.has(edge.source)) {\n        const pos = nodePositionMap.get(edge.source)\n        if (pos && edge.points.length > 0) {\n          edge.points[0] = { x: pos.cx, y: pos.cy }\n          modified = true\n        }\n      }\n\n      // Fix target endpoint  if the target is inside a pre-computed subgraph\n      if (preComputedNodeIds.has(edge.target)) {\n        const pos = nodePositionMap.get(edge.target)\n        if (pos && edge.points.length > 0) {\n          edge.points[edge.points.length - 1] = { x: pos.cx, y: pos.cy }\n          modified = true\n        }\n      }\n\n      // Re-snap to orthogonal after modifying endpoints\n      if (modified) {\n        edge.points = snapToOrthogonal(edge.points, verticalFirst)\n      }\n    }\n  }\n\n  // ---------------------------------------------------------------------------\n  // Post-process: add header space to subgraph groups.\n  //\n  // Dagre's compound node bounds tightly wrap children  it ignores paddingX/paddingY\n  // (those aren't in dagre's nodeNumAttrs). This means the subgraph header label\n  // overlaps with the first child node.\n  //\n  // Fix: expand each labeled group upward by headerHeight so the header band\n  // occupies its own space above the children. Process depth-first so child\n  // expansions are incorporated before parent bounds are recalculated.\n  // ---------------------------------------------------------------------------\n  const headerHeight = FONT_SIZES.groupHeader + 16\n  expandGroupsForHeaders(groups, headerHeight)\n\n  // After expanding groups upward, some may extend above dagre's original margins.\n  // Compute the global minimum Y and shift everything down uniformly if needed.\n  const flatGroups = flattenAllGroups(groups)\n  const allYs = [\n    ...nodes.map(n => n.y),\n    ...flatGroups.map(g => g.y),\n  ]\n  const currentMinY = allYs.length > 0 ? Math.min(...allYs) : padding\n  let graphWidth = g.graph().width ?? 800\n  let graphHeight = g.graph().height ?? 600\n\n  if (currentMinY < padding) {\n    const dy = padding - currentMinY\n    for (const n of nodes) n.y += dy\n    for (const e of edges) {\n      for (const p of e.points) p.y += dy\n      if (e.labelPosition) e.labelPosition.y += dy\n    }\n    for (const fg of flatGroups) fg.y += dy\n    graphHeight += dy\n  }\n\n  // Also expand graph height if any group extends beyond the original bottom margin\n  const maxBottom = Math.max(\n    ...nodes.map(n => n.y + n.height),\n    ...flatGroups.map(g => g.y + g.height),\n    ...edges.flatMap(e => e.points.map(p => p.y)),\n  )\n  if (maxBottom + padding > graphHeight) {\n    graphHeight = maxBottom + padding\n  }\n\n  return {\n    width: graphWidth,\n    height: graphHeight,\n    nodes,\n    edges,\n    groups,\n  }\n}\n\n/**\n * Extract a positioned group from a subgraph in the dagre layout.\n * Dagre gives compound nodes absolute coordinates (center-based),\n * so no container-relative offset math is needed.\n */\nfunction extractGroup(\n  g: dagre.graphlib.Graph,\n  sg: MermaidSubgraph,\n): PositionedGroup {\n  const dagreNode = g.node(sg.id)\n  const topLeft = dagreNode\n    ? centerToTopLeft(dagreNode.x, dagreNode.y, dagreNode.width, dagreNode.height)\n    : { x: 0, y: 0 }\n\n  return {\n    id: sg.id,\n    label: sg.label,\n    x: topLeft.x,\n    y: topLeft.y,\n    width: dagreNode?.width ?? 0,\n    height: dagreNode?.height ?? 0,\n    children: sg.children.map(child => extractGroup(g, child)),\n  }\n}\n\n// ============================================================================\n// Header space post-processing\n//\n// Dagre ignores paddingX/paddingY on compound nodes (not in nodeNumAttrs).\n// These helpers expand group boxes upward to create space for header labels.\n// ============================================================================\n\n/**\n * Expand all groups upward to make room for header labels.\n * Processes depth-first so child expansions are accounted for when\n * parent bounds are recalculated.\n */\nfunction expandGroupsForHeaders(groups: PositionedGroup[], headerHeight: number): void {\n  for (const group of groups) {\n    expandGroupForHeader(group, headerHeight)\n  }\n}\n\n/**\n * Recursively expand a single group and its children for header space.\n *\n * Algorithm (depth-first):\n *   1. Expand all children first\n *   2. Re-fit this group's bounds to encompass any expanded children\n *   3. Expand this group upward by headerHeight for its own header\n */\nfunction expandGroupForHeader(group: PositionedGroup, headerHeight: number): void {\n  // Step 1: process children first\n  for (const child of group.children) {\n    expandGroupForHeader(child, headerHeight)\n  }\n\n  // Step 2: re-fit bounds to encompass expanded children.\n  // After children expand upward, they may extend above this group's dagre-computed top.\n  if (group.children.length > 0) {\n    let minY = group.y\n    let maxY = group.y + group.height\n    for (const child of group.children) {\n      minY = Math.min(minY, child.y)\n      maxY = Math.max(maxY, child.y + child.height)\n    }\n    group.height = maxY - minY\n    group.y = minY\n  }\n\n  // Step 3: expand upward for this group's own header band + content padding.\n  // The content padding (GROUP_HEADER_CONTENT_PAD) creates a gap between the header\n  // band bottom and the content area, preventing nested subgraph headers from being\n  // flush against their parent's header band.\n  if (group.label) {\n    const expansion = headerHeight + GROUP_HEADER_CONTENT_PAD\n    group.y -= expansion\n    group.height += expansion\n  }\n}\n\n/** Flatten a group tree into a flat array of all groups (including nested). */\nfunction flattenAllGroups(groups: PositionedGroup[]): PositionedGroup[] {\n  const result: PositionedGroup[] = []\n  for (const g of groups) {\n    result.push(g)\n    result.push(...flattenAllGroups(g.children))\n  }\n  return result\n}\n\n/** Find a group by ID in a nested group tree (depth-first). */\nfunction findGroupById(groups: PositionedGroup[], id: string): PositionedGroup | undefined {\n  for (const g of groups) {\n    if (g.id === id) return g\n    const found = findGroupById(g.children, id)\n    if (found) return found\n  }\n  return undefined\n}\n\n/** Create a copy of a positioned group with all positions offset by (dx, dy). */\nfunction offsetGroup(group: PositionedGroup, dx: number, dy: number): PositionedGroup {\n  return {\n    ...group,\n    x: group.x + dx,\n    y: group.y + dy,\n    children: group.children.map(c => offsetGroup(c, dx, dy)),\n  }\n}\n\n/** Recursively collect all subgraph IDs (including nested) */\nfunction collectAllSubgraphIds(sg: MermaidSubgraph, out: Set<string>): void {\n  out.add(sg.id)\n  for (const child of sg.children) {\n    collectAllSubgraphIds(child, out)\n  }\n}\n","import type { PositionedGraph, PositionedNode, PositionedEdge, PositionedGroup, Point } from './types.ts'\nimport type { DiagramColors } from './theme.ts'\nimport { svgOpenTag, buildStyleBlock } from './theme.ts'\nimport { FONT_SIZES, FONT_WEIGHTS, STROKE_WIDTHS, ARROW_HEAD, estimateTextWidth, TEXT_BASELINE_SHIFT } from './styles.ts'\n\n// ============================================================================\n// SVG renderer  converts a PositionedGraph into an SVG string.\n//\n// Pure string concatenation, no DOM manipulation.\n// Renders back-to-front: groups  edges  arrow heads  edge labels  nodes  node labels.\n//\n// All colors are referenced via CSS custom properties (var(--_xxx)) defined\n// in the <style> block. The caller provides bg/fg (+ optional enrichment\n// colors) via DiagramColors, which are set as inline CSS variables on the\n// <svg> tag. See src/theme.ts for the full variable system.\n//\n// Style spec:\n// - All corners rx=0 ry=0 (sharp)\n// - Stroke widths: outer box 1px, inner box 0.75px, connectors 0.75px\n// - Arrow heads: filled triangles, 8px wide  4.8px tall\n// - Dashed edges: stroke-dasharray=\"4 4\"\n// - Font: Inter with weight per element type\n// ============================================================================\n\n/**\n * Render a positioned graph as an SVG string.\n *\n * @param colors - DiagramColors with bg/fg and optional enrichment variables.\n *                 These are set as CSS custom properties on the <svg> tag.\n *                 All element colors reference derived --_xxx variables.\n * @param transparent - If true, renders with transparent background.\n */\nexport function renderSvg(\n  graph: PositionedGraph,\n  colors: DiagramColors,\n  font: string = 'Inter',\n  transparent: boolean = false\n): string {\n  const parts: string[] = []\n\n  // SVG root with CSS variables + style block + defs\n  parts.push(svgOpenTag(graph.width, graph.height, colors, transparent))\n  parts.push(buildStyleBlock(font, false))\n  parts.push('<defs>')\n  parts.push(arrowMarkerDefs())\n  parts.push('</defs>')\n\n  // 1. Group backgrounds (subgraph rectangles with header bands)\n  for (const group of graph.groups) {\n    parts.push(renderGroup(group, font))\n  }\n\n  // 2. Edges (polylines  rendered behind nodes)\n  for (const edge of graph.edges) {\n    parts.push(renderEdge(edge))\n  }\n\n  // 3. Edge labels (positioned at midpoint of edge)\n  for (const edge of graph.edges) {\n    if (edge.label) {\n      parts.push(renderEdgeLabel(edge, font))\n    }\n  }\n\n  // 4. Node shapes\n  for (const node of graph.nodes) {\n    parts.push(renderNodeShape(node))\n  }\n\n  // 5. Node labels\n  for (const node of graph.nodes) {\n    parts.push(renderNodeLabel(node, font))\n  }\n\n  parts.push('</svg>')\n\n  return parts.join('\\n')\n}\n\n// ============================================================================\n// Arrow marker definitions\n// ============================================================================\n\n/**\n * Reusable arrow head markers  both forward (end) and reverse (start) variants.\n * The reverse marker uses orient=\"auto-start-reverse\" to flip automatically.\n * Arrow color uses var(--_arrow) CSS variable.\n */\nfunction arrowMarkerDefs(): string {\n  const w = ARROW_HEAD.width\n  const h = ARROW_HEAD.height\n  return (\n    // Forward arrow (marker-end)  orient=\"auto\" ensures arrow points along line direction\n    `  <marker id=\"arrowhead\" markerWidth=\"${w}\" markerHeight=\"${h}\" refX=\"${w}\" refY=\"${h / 2}\" orient=\"auto\">` +\n    `\\n    <polygon points=\"0 0, ${w} ${h / 2}, 0 ${h}\" fill=\"var(--_arrow)\" />` +\n    `\\n  </marker>` +\n    // Reverse arrow (marker-start)  refX=0 so it sits at the line start, auto-start-reverse flips it\n    `\\n  <marker id=\"arrowhead-start\" markerWidth=\"${w}\" markerHeight=\"${h}\" refX=\"0\" refY=\"${h / 2}\" orient=\"auto-start-reverse\">` +\n    `\\n    <polygon points=\"${w} 0, 0 ${h / 2}, ${w} ${h}\" fill=\"var(--_arrow)\" />` +\n    `\\n  </marker>`\n  )\n}\n\n// ============================================================================\n// Group rendering (subgraph backgrounds)\n// ============================================================================\n\nfunction renderGroup(group: PositionedGroup, font: string): string {\n  const headerHeight = FONT_SIZES.groupHeader + 16\n  const parts: string[] = []\n\n  // Outer rectangle\n  parts.push(\n    `<rect x=\"${group.x}\" y=\"${group.y}\" width=\"${group.width}\" height=\"${group.height}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"var(--_group-fill)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Header band\n  parts.push(\n    `<rect x=\"${group.x}\" y=\"${group.y}\" width=\"${group.width}\" height=\"${headerHeight}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"var(--_group-hdr)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Header label\n  parts.push(\n    `<text x=\"${group.x + 12}\" y=\"${group.y + headerHeight / 2}\" ` +\n    `dy=\"${TEXT_BASELINE_SHIFT}\" font-size=\"${FONT_SIZES.groupHeader}\" font-weight=\"${FONT_WEIGHTS.groupHeader}\" ` +\n    `fill=\"var(--_text-sec)\">${escapeXml(group.label)}</text>`\n  )\n\n  // Render nested groups recursively\n  for (const child of group.children) {\n    parts.push(renderGroup(child, font))\n  }\n\n  return parts.join('\\n')\n}\n\n// ============================================================================\n// Edge rendering\n// ============================================================================\n\nfunction renderEdge(edge: PositionedEdge): string {\n  if (edge.points.length < 2) return ''\n\n  const pathData = pointsToPolylinePath(edge.points)\n  const dashArray = edge.style === 'dotted' ? ' stroke-dasharray=\"4 4\"' : ''\n  const strokeWidth = edge.style === 'thick' ? STROKE_WIDTHS.connector * 2 : STROKE_WIDTHS.connector\n\n  // Build marker attributes based on arrow direction flags\n  let markers = ''\n  if (edge.hasArrowEnd) markers += ' marker-end=\"url(#arrowhead)\"'\n  if (edge.hasArrowStart) markers += ' marker-start=\"url(#arrowhead-start)\"'\n\n  return (\n    `<polyline points=\"${pathData}\" fill=\"none\" stroke=\"var(--_line)\" ` +\n    `stroke-width=\"${strokeWidth}\"${dashArray}${markers} />`\n  )\n}\n\n/** Convert points to SVG polyline points attribute: \"x1,y1 x2,y2 ...\" */\nfunction pointsToPolylinePath(points: Point[]): string {\n  return points.map(p => `${p.x},${p.y}`).join(' ')\n}\n\nfunction renderEdgeLabel(edge: PositionedEdge, font: string): string {\n  // Use dagre-computed label position when available (layout-aware, avoids collisions).\n  // Fall back to geometric midpoint of the edge polyline.\n  const mid = edge.labelPosition ?? edgeMidpoint(edge.points)\n  const label = edge.label!\n  const textWidth = estimateTextWidth(label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel)\n  const padding = 8\n\n  // Background pill behind text for readability\n  const bgWidth = textWidth + padding * 2\n  const bgHeight = FONT_SIZES.edgeLabel + padding * 2\n\n  return (\n    `<rect x=\"${mid.x - bgWidth / 2}\" y=\"${mid.y - bgHeight / 2}\" ` +\n    `width=\"${bgWidth}\" height=\"${bgHeight}\" rx=\"4\" ry=\"4\" ` +\n    `fill=\"var(--bg)\" stroke=\"var(--_inner-stroke)\" stroke-width=\"0.5\" />\\n` +\n    `<text x=\"${mid.x}\" y=\"${mid.y}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" ` +\n    `fill=\"var(--_text-muted)\">${escapeXml(label)}</text>`\n  )\n}\n\n/** Get the midpoint of a polyline (by walking segments) */\nfunction edgeMidpoint(points: Point[]): Point {\n  if (points.length === 0) return { x: 0, y: 0 }\n  if (points.length === 1) return points[0]!\n\n  // Calculate total length\n  let totalLength = 0\n  for (let i = 1; i < points.length; i++) {\n    totalLength += dist(points[i - 1]!, points[i]!)\n  }\n\n  // Walk to the halfway point\n  let remaining = totalLength / 2\n  for (let i = 1; i < points.length; i++) {\n    const segLen = dist(points[i - 1]!, points[i]!)\n    if (remaining <= segLen) {\n      const t = remaining / segLen\n      return {\n        x: points[i - 1]!.x + t * (points[i]!.x - points[i - 1]!.x),\n        y: points[i - 1]!.y + t * (points[i]!.y - points[i - 1]!.y),\n      }\n    }\n    remaining -= segLen\n  }\n\n  return points[points.length - 1]!\n}\n\nfunction dist(a: Point, b: Point): number {\n  return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2)\n}\n\n// ============================================================================\n// Node rendering\n// ============================================================================\n\nfunction renderNodeShape(node: PositionedNode): string {\n  const { x, y, width, height, shape, inlineStyle } = node\n\n  // Resolve fill and stroke  inline styles (from mermaid `style` directives)\n  // override the CSS variable defaults. When no inline style is present, the\n  // CSS variable handles theming automatically via color-mix() derivation.\n  const fill = escapeXml(inlineStyle?.fill ?? 'var(--_node-fill)')\n  const stroke = escapeXml(inlineStyle?.stroke ?? 'var(--_node-stroke)')\n  const sw = escapeXml(inlineStyle?.['stroke-width'] ?? String(STROKE_WIDTHS.innerBox))\n\n  switch (shape) {\n    case 'diamond':\n      return renderDiamond(x, y, width, height, fill, stroke, sw)\n    case 'rounded':\n      return renderRoundedRect(x, y, width, height, fill, stroke, sw)\n    case 'stadium':\n      return renderStadium(x, y, width, height, fill, stroke, sw)\n    case 'circle':\n      return renderCircle(x, y, width, height, fill, stroke, sw)\n    case 'subroutine':\n      return renderSubroutine(x, y, width, height, fill, stroke, sw)\n    case 'doublecircle':\n      return renderDoubleCircle(x, y, width, height, fill, stroke, sw)\n    case 'hexagon':\n      return renderHexagon(x, y, width, height, fill, stroke, sw)\n    case 'cylinder':\n      return renderCylinder(x, y, width, height, fill, stroke, sw)\n    case 'asymmetric':\n      return renderAsymmetric(x, y, width, height, fill, stroke, sw)\n    case 'trapezoid':\n      return renderTrapezoid(x, y, width, height, fill, stroke, sw)\n    case 'trapezoid-alt':\n      return renderTrapezoidAlt(x, y, width, height, fill, stroke, sw)\n    case 'state-start':\n      return renderStateStart(x, y, width, height)\n    case 'state-end':\n      return renderStateEnd(x, y, width, height)\n    case 'rectangle':\n    default:\n      return renderRect(x, y, width, height, fill, stroke, sw)\n  }\n}\n\n// --- Basic shapes ---\n\nfunction renderRect(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  return (\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${w}\" height=\"${h}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\nfunction renderRoundedRect(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  return (\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${w}\" height=\"${h}\" ` +\n    `rx=\"6\" ry=\"6\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\nfunction renderStadium(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const r = h / 2\n  return (\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${w}\" height=\"${h}\" ` +\n    `rx=\"${r}\" ry=\"${r}\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\nfunction renderCircle(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const cx = x + w / 2\n  const cy = y + h / 2\n  const r = Math.min(w, h) / 2\n  return (\n    `<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${r}\" ` +\n    `fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\nfunction renderDiamond(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const cx = x + w / 2\n  const cy = y + h / 2\n  const hw = w / 2\n  const hh = h / 2\n  const points = [\n    `${cx},${cy - hh}`,   // top\n    `${cx + hw},${cy}`,   // right\n    `${cx},${cy + hh}`,   // bottom\n    `${cx - hw},${cy}`,   // left\n  ].join(' ')\n\n  return (\n    `<polygon points=\"${points}\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\n// --- Batch 1 shapes ---\n\n/** Subroutine: rectangle with double vertical borders on left and right */\nfunction renderSubroutine(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const inset = 8 // distance from edge to inner vertical line\n  return (\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${w}\" height=\"${h}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />` +\n    `\\n<line x1=\"${x + inset}\" y1=\"${y}\" x2=\"${x + inset}\" y2=\"${y + h}\" ` +\n    `stroke=\"${stroke}\" stroke-width=\"${sw}\" />` +\n    `\\n<line x1=\"${x + w - inset}\" y1=\"${y}\" x2=\"${x + w - inset}\" y2=\"${y + h}\" ` +\n    `stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\n/** Double circle: two concentric circles with a gap between them */\nfunction renderDoubleCircle(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const cx = x + w / 2\n  const cy = y + h / 2\n  const outerR = Math.min(w, h) / 2\n  const innerR = outerR - 5 // 5px gap between rings\n  return (\n    `<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${outerR}\" ` +\n    `fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />` +\n    `\\n<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${innerR}\" ` +\n    `fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\n/** Hexagon: 6-point polygon with flat top/bottom and angled sides */\nfunction renderHexagon(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const inset = h / 4 // horizontal inset for the angled sides\n  const points = [\n    `${x + inset},${y}`,           // top-left\n    `${x + w - inset},${y}`,       // top-right\n    `${x + w},${y + h / 2}`,       // mid-right\n    `${x + w - inset},${y + h}`,   // bottom-right\n    `${x + inset},${y + h}`,       // bottom-left\n    `${x},${y + h / 2}`,           // mid-left\n  ].join(' ')\n\n  return `<polygon points=\"${points}\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n}\n\n// --- Batch 2 shapes ---\n\n/** Cylinder / database: top ellipse cap + body rect + bottom ellipse */\nfunction renderCylinder(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const ry = 7 // ellipse vertical radius for the cap\n  const cx = x + w / 2\n  const bodyTop = y + ry\n  const bodyH = h - 2 * ry\n\n  return (\n    // Body rectangle (no top border  covered by top ellipse)\n    `<rect x=\"${x}\" y=\"${bodyTop}\" width=\"${w}\" height=\"${bodyH}\" ` +\n    `fill=\"${fill}\" stroke=\"none\" />` +\n    // Left and right body borders\n    `\\n<line x1=\"${x}\" y1=\"${bodyTop}\" x2=\"${x}\" y2=\"${bodyTop + bodyH}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />` +\n    `\\n<line x1=\"${x + w}\" y1=\"${bodyTop}\" x2=\"${x + w}\" y2=\"${bodyTop + bodyH}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />` +\n    // Bottom ellipse (half visible)\n    `\\n<ellipse cx=\"${cx}\" cy=\"${y + h - ry}\" rx=\"${w / 2}\" ry=\"${ry}\" ` +\n    `fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />` +\n    // Top ellipse (full, on top)\n    `\\n<ellipse cx=\"${cx}\" cy=\"${bodyTop}\" rx=\"${w / 2}\" ry=\"${ry}\" ` +\n    `fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n  )\n}\n\n/** Asymmetric / flag: rectangle with a pointed left edge */\nfunction renderAsymmetric(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const indent = 12 // how far the point indents\n  const points = [\n    `${x + indent},${y}`,       // top-left (indented)\n    `${x + w},${y}`,            // top-right\n    `${x + w},${y + h}`,        // bottom-right\n    `${x + indent},${y + h}`,   // bottom-left (indented)\n    `${x},${y + h / 2}`,        // left point\n  ].join(' ')\n\n  return `<polygon points=\"${points}\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n}\n\n/** Trapezoid [/text\\]: wider bottom, narrower top */\nfunction renderTrapezoid(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const inset = w * 0.15 // top edge is narrower by this amount on each side\n  const points = [\n    `${x + inset},${y}`,         // top-left (indented)\n    `${x + w - inset},${y}`,     // top-right (indented)\n    `${x + w},${y + h}`,         // bottom-right (full width)\n    `${x},${y + h}`,             // bottom-left (full width)\n  ].join(' ')\n\n  return `<polygon points=\"${points}\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n}\n\n/** Trapezoid-alt [\\text/]: wider top, narrower bottom */\nfunction renderTrapezoidAlt(x: number, y: number, w: number, h: number, fill: string, stroke: string, sw: string): string {\n  const inset = w * 0.15 // bottom edge is narrower\n  const points = [\n    `${x},${y}`,                     // top-left (full width)\n    `${x + w},${y}`,                 // top-right (full width)\n    `${x + w - inset},${y + h}`,     // bottom-right (indented)\n    `${x + inset},${y + h}`,         // bottom-left (indented)\n  ].join(' ')\n\n  return `<polygon points=\"${points}\" fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${sw}\" />`\n}\n\n// --- Batch 3: State diagram pseudostates ---\n\n/** State start: small filled circle using primary text color */\nfunction renderStateStart(x: number, y: number, w: number, h: number): string {\n  const cx = x + w / 2\n  const cy = y + h / 2\n  const r = Math.min(w, h) / 2 - 2\n  return `<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${r}\" fill=\"var(--_text)\" stroke=\"none\" />`\n}\n\n/** State end: bullseye  outer ring + inner filled circle using primary text color */\nfunction renderStateEnd(x: number, y: number, w: number, h: number): string {\n  const cx = x + w / 2\n  const cy = y + h / 2\n  const outerR = Math.min(w, h) / 2 - 2\n  const innerR = outerR - 4\n  return (\n    `<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${outerR}\" ` +\n    `fill=\"none\" stroke=\"var(--_text)\" stroke-width=\"${STROKE_WIDTHS.innerBox * 2}\" />` +\n    `\\n<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${innerR}\" fill=\"var(--_text)\" stroke=\"none\" />`\n  )\n}\n\n// ============================================================================\n// Node label rendering\n// ============================================================================\n\nfunction renderNodeLabel(node: PositionedNode, font: string): string {\n  // State pseudostates have no label\n  if (node.shape === 'state-start' || node.shape === 'state-end') {\n    if (!node.label) return ''\n  }\n\n  const cx = node.x + node.width / 2\n  const cy = node.y + node.height / 2\n\n  // Resolve text color  inline styles can override the CSS variable default\n  const textColor = escapeXml(node.inlineStyle?.color ?? 'var(--_text)')\n\n  return (\n    `<text x=\"${cx}\" y=\"${cy}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.nodeLabel}\" font-weight=\"${FONT_WEIGHTS.nodeLabel}\" ` +\n    `fill=\"${textColor}\">${escapeXml(node.label)}</text>`\n  )\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\n/** Escape special XML characters in text content */\nfunction escapeXml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}\n","import type { SequenceDiagram, PositionedSequenceDiagram, PositionedActor, Lifeline, PositionedMessage, Activation, PositionedBlock, PositionedNote } from './types.ts'\nimport type { RenderOptions } from '../types.ts'\nimport { estimateTextWidth, FONT_SIZES, FONT_WEIGHTS } from '../styles.ts'\n\n// ============================================================================\n// Sequence diagram layout engine\n//\n// Custom timeline-based layout (no dagre  sequence diagrams aren't graphs).\n//\n// Layout strategy:\n//   1. Space actors horizontally based on label widths + min gap\n//   2. Stack messages vertically in chronological order\n//   3. Track activation boxes via a stack\n//   4. Position blocks (loop/alt/opt) as background rectangles\n//   5. Position notes next to their target actors\n// ============================================================================\n\n/** Layout constants specific to sequence diagrams */\nconst SEQ = {\n  /** Padding around the entire diagram */\n  padding: 30,\n  /** Minimum gap between actor centers */\n  actorGap: 140,\n  /** Actor box height */\n  actorHeight: 40,\n  /** Horizontal padding inside actor boxes */\n  actorPadX: 16,\n  /** Vertical space between actor boxes and first message */\n  headerGap: 20,\n  /** Vertical space per message row */\n  messageRowHeight: 40,\n  /** Extra vertical space for self-messages (they loop back) */\n  selfMessageHeight: 30,\n  /** Activation box width (narrow rectangle on lifeline) */\n  activationWidth: 10,\n  /** Block padding (loop/alt borders) */\n  blockPadX: 10,\n  blockPadTop: 40,\n  blockPadBottom: 8,\n  /** Extra vertical space before the first message in a block (room for the header label) */\n  blockHeaderExtra: 28,\n  /** Extra vertical space before a message at a divider boundary (room for else/and label) */\n  dividerExtra: 24,\n  /** Note dimensions */\n  noteWidth: 120,\n  notePadding: 8,\n  noteGap: 10,\n} as const\n\n/**\n * Lay out a parsed sequence diagram.\n * Returns a fully positioned diagram ready for SVG rendering.\n */\nexport function layoutSequenceDiagram(\n  diagram: SequenceDiagram,\n  _options: RenderOptions = {}\n): PositionedSequenceDiagram {\n  if (diagram.actors.length === 0) {\n    return { width: 0, height: 0, actors: [], lifelines: [], messages: [], activations: [], blocks: [], notes: [] }\n  }\n\n  // 1. Calculate actor widths and assign horizontal positions (center X)\n  const actorWidths = diagram.actors.map(a => {\n    const textW = estimateTextWidth(a.label, FONT_SIZES.nodeLabel, FONT_WEIGHTS.nodeLabel)\n    return Math.max(textW + SEQ.actorPadX * 2, 80)\n  })\n\n  // Build actor center X positions with minimum gap\n  const actorCenterX: number[] = []\n  let currentX = SEQ.padding + actorWidths[0]! / 2\n  for (let i = 0; i < diagram.actors.length; i++) {\n    if (i > 0) {\n      const minGap = Math.max(SEQ.actorGap, (actorWidths[i - 1]! + actorWidths[i]!) / 2 + 40)\n      currentX += minGap\n    }\n    actorCenterX.push(currentX)\n  }\n\n  // Build actor ID  index lookup\n  const actorIndex = new Map<string, number>()\n  for (let i = 0; i < diagram.actors.length; i++) {\n    actorIndex.set(diagram.actors[i]!.id, i)\n  }\n\n  // 2. Position actors at the top\n  const actorY = SEQ.padding\n  const actors: PositionedActor[] = diagram.actors.map((a, i) => ({\n    id: a.id,\n    label: a.label,\n    type: a.type,\n    x: actorCenterX[i]!,\n    y: actorY,\n    width: actorWidths[i]!,\n    height: SEQ.actorHeight,\n  }))\n\n  // 3. Stack messages vertically\n  let messageY = actorY + SEQ.actorHeight + SEQ.headerGap\n  const messages: PositionedMessage[] = []\n\n  // Pre-scan blocks to determine which message indices need extra vertical\n  // space for block headers (e.g. \"alt [Valid credentials]\") or divider\n  // labels (e.g. \"[else Invalid]\"). Without this, messages inside blocks\n  // overlap with the header/divider text that sits above them.\n  const extraSpaceBefore = new Map<number, number>()\n  for (const block of diagram.blocks) {\n    // First message in the block needs room for the block header label\n    const prev = extraSpaceBefore.get(block.startIndex) ?? 0\n    extraSpaceBefore.set(block.startIndex, Math.max(prev, SEQ.blockHeaderExtra))\n\n    // Each divider (else/and) needs room for the divider label\n    for (const div of block.dividers) {\n      const prevDiv = extraSpaceBefore.get(div.index) ?? 0\n      extraSpaceBefore.set(div.index, Math.max(prevDiv, SEQ.dividerExtra))\n    }\n  }\n\n  // Track activation stack per actor: array of start-Y positions\n  const activationStacks = new Map<string, number[]>()\n  const activations: Activation[] = []\n\n  for (let msgIdx = 0; msgIdx < diagram.messages.length; msgIdx++) {\n    const msg = diagram.messages[msgIdx]!\n    const fromIdx = actorIndex.get(msg.from) ?? 0\n    const toIdx = actorIndex.get(msg.to) ?? 0\n    const isSelf = msg.from === msg.to\n\n    // Add extra vertical space if this message sits below a block header or divider\n    const extra = extraSpaceBefore.get(msgIdx) ?? 0\n    if (extra > 0) messageY += extra\n\n    const x1 = actorCenterX[fromIdx]!\n    const x2 = actorCenterX[toIdx]!\n\n    messages.push({\n      from: msg.from,\n      to: msg.to,\n      label: msg.label,\n      lineStyle: msg.lineStyle,\n      arrowHead: msg.arrowHead,\n      x1, x2,\n      y: messageY,\n      isSelf,\n    })\n\n    // Handle activation\n    if (msg.activate) {\n      if (!activationStacks.has(msg.to)) {\n        activationStacks.set(msg.to, [])\n      }\n      activationStacks.get(msg.to)!.push(messageY)\n    }\n\n    if (msg.deactivate) {\n      const stack = activationStacks.get(msg.from)\n      if (stack && stack.length > 0) {\n        const startY = stack.pop()!\n        const idx = actorIndex.get(msg.from) ?? 0\n        activations.push({\n          actorId: msg.from,\n          x: actorCenterX[idx]! - SEQ.activationWidth / 2,\n          topY: startY,\n          bottomY: messageY,\n          width: SEQ.activationWidth,\n        })\n      }\n    }\n\n    messageY += isSelf ? SEQ.selfMessageHeight + SEQ.messageRowHeight : SEQ.messageRowHeight\n  }\n\n  // Close any unclosed activations\n  for (const [actorId, stack] of activationStacks) {\n    for (const startY of stack) {\n      const idx = actorIndex.get(actorId) ?? 0\n      activations.push({\n        actorId,\n        x: actorCenterX[idx]! - SEQ.activationWidth / 2,\n        topY: startY,\n        bottomY: messageY - SEQ.messageRowHeight / 2,\n        width: SEQ.activationWidth,\n      })\n    }\n  }\n\n  // 4. Position blocks (loop/alt/opt)\n  const blocks: PositionedBlock[] = diagram.blocks.map(block => {\n    // Block spans from the Y of startIndex to endIndex messages\n    const startMsg = messages[block.startIndex]\n    const endMsg = messages[block.endIndex]\n    const blockTop = (startMsg?.y ?? messageY) - SEQ.blockPadTop\n    const blockBottom = (endMsg?.y ?? messageY) + SEQ.blockPadBottom + 12\n\n    // Block width spans all actors involved in its messages\n    const involvedActors = new Set<number>()\n    for (let mi = block.startIndex; mi <= block.endIndex; mi++) {\n      const m = diagram.messages[mi]\n      if (m) {\n        involvedActors.add(actorIndex.get(m.from) ?? 0)\n        involvedActors.add(actorIndex.get(m.to) ?? 0)\n      }\n    }\n    // Fallback: span all actors if none involved\n    if (involvedActors.size === 0) {\n      for (let ai = 0; ai < diagram.actors.length; ai++) involvedActors.add(ai)\n    }\n    const minIdx = Math.min(...involvedActors)\n    const maxIdx = Math.max(...involvedActors)\n    const blockLeft = actorCenterX[minIdx]! - actorWidths[minIdx]! / 2 - SEQ.blockPadX\n    const blockRight = actorCenterX[maxIdx]! + actorWidths[maxIdx]! / 2 + SEQ.blockPadX\n\n    // Position dividers  offset from message Y so the divider label text\n    // (rendered at divider.y + 14 in the renderer) clears the message label\n    // (rendered at msg.y - 6).\n    //\n    // Default offset 28 gives ~8px baseline clearance, which is sufficient\n    // when the divider label (left-aligned at block edge) and message label\n    // (centered between actors) don't share horizontal space. When they DO\n    // overlap horizontally (e.g. long divider labels like \"[Account locked]\"\n    // next to centered message labels like \"403 Forbidden\"), we increase the\n    // offset to 36 so text bounding boxes have ~5px visual clearance.\n    const dividers = block.dividers.map(d => {\n      const msg = messages[d.index]\n      const msgY = msg?.y ?? messageY\n      let offset = 28\n\n      // Dynamic overlap detection: increase offset when the divider label\n      // and message label occupy the same horizontal region, which would\n      // cause vertical text overlap at the default 8px baseline gap.\n      if (d.label && msg?.label) {\n        const divLabelText = `[${d.label}]`\n        const divLabelW = estimateTextWidth(divLabelText, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel)\n        const divLabelLeft = blockLeft + 8\n        const divLabelRight = divLabelLeft + divLabelW\n\n        const msgLabelW = estimateTextWidth(msg.label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel)\n        // Self-messages render labels at x1 + 36 (left-aligned); normal\n        // messages center the label between the two actor lifelines.\n        const msgLabelLeft = msg.isSelf\n          ? msg.x1 + 36\n          : (msg.x1 + msg.x2) / 2 - msgLabelW / 2\n        const msgLabelRight = msgLabelLeft + msgLabelW\n\n        if (divLabelRight > msgLabelLeft && divLabelLeft < msgLabelRight) {\n          offset = 36\n        }\n      }\n\n      return { y: msgY - offset, label: d.label }\n    })\n\n    return {\n      type: block.type,\n      label: block.label,\n      x: blockLeft,\n      y: blockTop,\n      width: blockRight - blockLeft,\n      height: blockBottom - blockTop,\n      dividers,\n    }\n  })\n\n  // 5. Position notes\n  const notes: PositionedNote[] = diagram.notes.map(note => {\n    const noteW = Math.max(\n      SEQ.noteWidth,\n      estimateTextWidth(note.text, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel) + SEQ.notePadding * 2\n    )\n    const noteH = FONT_SIZES.edgeLabel + SEQ.notePadding * 2\n\n    // Position based on the message after which it appears\n    const refMsg = messages[note.afterIndex]\n    const noteY = (refMsg?.y ?? actorY + SEQ.actorHeight) + 4\n\n    // X based on actor position and note type\n    const firstActorIdx = actorIndex.get(note.actorIds[0] ?? '') ?? 0\n    let noteX: number\n    if (note.position === 'left') {\n      noteX = actorCenterX[firstActorIdx]! - actorWidths[firstActorIdx]! / 2 - noteW - SEQ.noteGap\n    } else if (note.position === 'right') {\n      noteX = actorCenterX[firstActorIdx]! + actorWidths[firstActorIdx]! / 2 + SEQ.noteGap\n    } else {\n      // over  center between first and last actor\n      if (note.actorIds.length > 1) {\n        const lastActorIdx = actorIndex.get(note.actorIds[note.actorIds.length - 1] ?? '') ?? firstActorIdx\n        noteX = (actorCenterX[firstActorIdx]! + actorCenterX[lastActorIdx]!) / 2 - noteW / 2\n      } else {\n        noteX = actorCenterX[firstActorIdx]! - noteW / 2\n      }\n    }\n\n    return { text: note.text, x: noteX, y: noteY, width: noteW, height: noteH }\n  })\n\n  // 6. Bounding-box post-processing\n  //\n  // Notes positioned \"left of\" the first actor or \"right of\" the last actor\n  // can extend beyond the actor-based viewport. Compute the true bounding box\n  // across all positioned elements, then shift everything right if anything\n  // extends left of the desired padding margin and expand the width to fit.\n  const diagramBottom = messageY + SEQ.padding\n\n  // Find global X extents across actors, blocks, and notes\n  let globalMinX = SEQ.padding // actors already start at SEQ.padding\n  let globalMaxX = 0\n  for (const a of actors) {\n    globalMinX = Math.min(globalMinX, a.x - a.width / 2)\n    globalMaxX = Math.max(globalMaxX, a.x + a.width / 2)\n  }\n  for (const b of blocks) {\n    globalMinX = Math.min(globalMinX, b.x)\n    globalMaxX = Math.max(globalMaxX, b.x + b.width)\n  }\n  for (const n of notes) {\n    globalMinX = Math.min(globalMinX, n.x)\n    globalMaxX = Math.max(globalMaxX, n.x + n.width)\n  }\n\n  // If elements extend left of the desired padding, shift everything right\n  const shiftX = globalMinX < SEQ.padding ? SEQ.padding - globalMinX : 0\n  if (shiftX > 0) {\n    for (const a of actors) a.x += shiftX\n    for (const m of messages) { m.x1 += shiftX; m.x2 += shiftX }\n    for (const act of activations) act.x += shiftX\n    for (const b of blocks) { b.x += shiftX; }\n    for (const n of notes) n.x += shiftX\n    // Also shift actor center X array (used for lifelines below)\n    for (let i = 0; i < actorCenterX.length; i++) actorCenterX[i]! += shiftX\n  }\n\n  // 7. Calculate final lifelines (after shift so X positions are correct)\n  const lifelines: Lifeline[] = diagram.actors.map((a, i) => ({\n    actorId: a.id,\n    x: actorCenterX[i]!,\n    topY: actorY + SEQ.actorHeight,\n    bottomY: diagramBottom - SEQ.padding,\n  }))\n\n  // 8. Calculate diagram dimensions from the bounding box\n  const diagramWidth = globalMaxX + shiftX + SEQ.padding\n  const diagramHeight = diagramBottom\n\n  return {\n    width: Math.max(diagramWidth, 200),\n    height: Math.max(diagramHeight, 100),\n    actors,\n    lifelines,\n    messages,\n    activations,\n    blocks,\n    notes,\n  }\n}\n","import type { PositionedSequenceDiagram, PositionedActor, Lifeline, PositionedMessage, Activation, PositionedBlock, PositionedNote } from './types.ts'\nimport type { DiagramColors } from '../theme.ts'\nimport { svgOpenTag, buildStyleBlock } from '../theme.ts'\nimport { FONT_SIZES, FONT_WEIGHTS, STROKE_WIDTHS, ARROW_HEAD, estimateTextWidth, TEXT_BASELINE_SHIFT } from '../styles.ts'\n\n// ============================================================================\n// Sequence diagram SVG renderer\n//\n// Renders a positioned sequence diagram to SVG string.\n// All colors use CSS custom properties (var(--_xxx)) from the theme system.\n//\n// Render order (back to front):\n//   1. Block backgrounds (loop/alt/opt)\n//   2. Lifelines (dashed vertical lines)\n//   3. Activation boxes\n//   4. Messages (arrows with labels)\n//   5. Notes\n//   6. Actor boxes (at top)\n// ============================================================================\n\n/**\n * Render a positioned sequence diagram as an SVG string.\n *\n * @param colors - DiagramColors with bg/fg and optional enrichment variables.\n * @param transparent - If true, renders with transparent background.\n */\nexport function renderSequenceSvg(\n  diagram: PositionedSequenceDiagram,\n  colors: DiagramColors,\n  font: string = 'Inter',\n  transparent: boolean = false\n): string {\n  const parts: string[] = []\n\n  // SVG root with CSS variables + style block + defs\n  parts.push(svgOpenTag(diagram.width, diagram.height, colors, transparent))\n  parts.push(buildStyleBlock(font, false))\n  parts.push('<defs>')\n\n  // Arrow marker definitions\n  parts.push(arrowMarkerDefs())\n  parts.push('</defs>')\n\n  // 1. Block backgrounds (loop/alt/opt rectangles)\n  for (const block of diagram.blocks) {\n    parts.push(renderBlock(block))\n  }\n\n  // 2. Lifelines (dashed vertical lines from actor to bottom)\n  for (const lifeline of diagram.lifelines) {\n    parts.push(renderLifeline(lifeline))\n  }\n\n  // 3. Activation boxes\n  for (const activation of diagram.activations) {\n    parts.push(renderActivation(activation))\n  }\n\n  // 4. Messages (horizontal arrows with labels)\n  for (const message of diagram.messages) {\n    parts.push(renderMessage(message))\n  }\n\n  // 5. Notes\n  for (const note of diagram.notes) {\n    parts.push(renderNote(note))\n  }\n\n  // 6. Actor boxes at top (rendered last so they're on top)\n  for (const actor of diagram.actors) {\n    parts.push(renderActor(actor))\n  }\n\n  parts.push('</svg>')\n  return parts.join('\\n')\n}\n\n// ============================================================================\n// Arrow marker definitions\n// ============================================================================\n\nfunction arrowMarkerDefs(): string {\n  const w = ARROW_HEAD.width\n  const h = ARROW_HEAD.height\n  return (\n    `  <marker id=\"seq-arrow\" markerWidth=\"${w}\" markerHeight=\"${h}\" refX=\"${w}\" refY=\"${h / 2}\" orient=\"auto-start-reverse\">` +\n    `\\n    <polygon points=\"0 0, ${w} ${h / 2}, 0 ${h}\" fill=\"var(--_arrow)\" />` +\n    `\\n  </marker>` +\n    // Open arrow head (just lines, no fill)\n    `\\n  <marker id=\"seq-arrow-open\" markerWidth=\"${w}\" markerHeight=\"${h}\" refX=\"${w}\" refY=\"${h / 2}\" orient=\"auto-start-reverse\">` +\n    `\\n    <polyline points=\"0 0, ${w} ${h / 2}, 0 ${h}\" fill=\"none\" stroke=\"var(--_arrow)\" stroke-width=\"1\" />` +\n    `\\n  </marker>`\n  )\n}\n\n// ============================================================================\n// Component renderers\n// ============================================================================\n\n/** Render an actor box (participant = rectangle, actor = stick figure) */\nfunction renderActor(actor: PositionedActor): string {\n  const { x, y, width, height, label, type } = actor\n\n  if (type === 'actor') {\n    // Circle-person icon: outer circle + head circle + shoulders arc.\n    // Defined in a 2424 coordinate space, scaled to 90% of the actor box height\n    // and centered both horizontally and vertically within the box.\n    // Stroke width is inverse-scaled so the visual thickness matches STROKE_WIDTHS.outerBox.\n    const s = (height / 24) * 0.9\n    const tx = x - 12 * s            // center icon horizontally on actor.x\n    const ty = y + (height - 24 * s) / 2  // center icon vertically in actor box\n    const sw = STROKE_WIDTHS.outerBox / s  // compensate for scale transform\n    const iconStroke = 'var(--_line)'      // use line color for actor icon strokes\n\n    return (\n      `<g transform=\"translate(${tx},${ty}) scale(${s})\">` +\n      // Outer circle\n      `\\n  <path d=\"M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z\" fill=\"none\" stroke=\"${iconStroke}\" stroke-width=\"${sw}\" />` +\n      // Head\n      `\\n  <path d=\"M15 10C15 11.6569 13.6569 13 12 13C10.3431 13 9 11.6569 9 10C9 8.34315 10.3431 7 12 7C13.6569 7 15 8.34315 15 10Z\" fill=\"none\" stroke=\"${iconStroke}\" stroke-width=\"${sw}\" />` +\n      // Shoulders\n      `\\n  <path d=\"M5.62842 18.3563C7.08963 17.0398 9.39997 16 12 16C14.6 16 16.9104 17.0398 18.3716 18.3563\" fill=\"none\" stroke=\"${iconStroke}\" stroke-width=\"${sw}\" />` +\n      `\\n</g>` +\n      // Label below the icon\n      `\\n<text x=\"${x}\" y=\"${y + height + 14}\" text-anchor=\"middle\" font-size=\"${FONT_SIZES.nodeLabel}\" font-weight=\"${FONT_WEIGHTS.nodeLabel}\" fill=\"var(--_text)\">${escapeXml(label)}</text>`\n    )\n  }\n\n  // Participant: rectangle box with label\n  const boxX = x - width / 2\n  return (\n    `<rect x=\"${boxX}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" rx=\"4\" ry=\"4\" ` +\n    `fill=\"var(--_node-fill)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />` +\n    `\\n<text x=\"${x}\" y=\"${y + height / 2}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.nodeLabel}\" font-weight=\"${FONT_WEIGHTS.nodeLabel}\" fill=\"var(--_text)\">${escapeXml(label)}</text>`\n  )\n}\n\n/** Render a lifeline (dashed vertical line from actor to bottom) */\nfunction renderLifeline(lifeline: Lifeline): string {\n  return (\n    `<line x1=\"${lifeline.x}\" y1=\"${lifeline.topY}\" x2=\"${lifeline.x}\" y2=\"${lifeline.bottomY}\" ` +\n    `stroke=\"var(--_line)\" stroke-width=\"0.75\" stroke-dasharray=\"6 4\" />`\n  )\n}\n\n/** Render an activation box (narrow filled rectangle on lifeline) */\nfunction renderActivation(activation: Activation): string {\n  return (\n    `<rect x=\"${activation.x}\" y=\"${activation.topY}\" width=\"${activation.width}\" height=\"${activation.bottomY - activation.topY}\" ` +\n    `fill=\"var(--_node-fill)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.innerBox}\" />`\n  )\n}\n\n/** Render a message arrow with label */\nfunction renderMessage(msg: PositionedMessage): string {\n  const parts: string[] = []\n  const dashArray = msg.lineStyle === 'dashed' ? ' stroke-dasharray=\"6 4\"' : ''\n  const markerId = msg.arrowHead === 'filled' ? 'seq-arrow' : 'seq-arrow-open'\n\n  if (msg.isSelf) {\n    // Self-message: curved loop going right and back\n    const loopW = 30\n    const loopH = 20\n    parts.push(\n      `<polyline points=\"${msg.x1},${msg.y} ${msg.x1 + loopW},${msg.y} ${msg.x1 + loopW},${msg.y + loopH} ${msg.x2},${msg.y + loopH}\" ` +\n      `fill=\"none\" stroke=\"var(--_line)\" stroke-width=\"${STROKE_WIDTHS.connector}\"${dashArray} marker-end=\"url(#${markerId})\" />`\n    )\n    // Label to the right of the loop\n    parts.push(\n      `<text x=\"${msg.x1 + loopW + 6}\" y=\"${msg.y + loopH / 2}\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n      `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" fill=\"var(--_text-muted)\">${escapeXml(msg.label)}</text>`\n    )\n  } else {\n    // Normal message: horizontal arrow\n    parts.push(\n      `<line x1=\"${msg.x1}\" y1=\"${msg.y}\" x2=\"${msg.x2}\" y2=\"${msg.y}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"${STROKE_WIDTHS.connector}\"${dashArray} marker-end=\"url(#${markerId})\" />`\n    )\n    // Label above the arrow, centered\n    const midX = (msg.x1 + msg.x2) / 2\n    parts.push(\n      `<text x=\"${midX}\" y=\"${msg.y - 6}\" text-anchor=\"middle\" ` +\n      `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" fill=\"var(--_text-muted)\">${escapeXml(msg.label)}</text>`\n    )\n  }\n\n  return parts.join('\\n')\n}\n\n/** Render a block background (loop/alt/opt) */\nfunction renderBlock(block: PositionedBlock): string {\n  const parts: string[] = []\n\n  // Outer rectangle\n  parts.push(\n    `<rect x=\"${block.x}\" y=\"${block.y}\" width=\"${block.width}\" height=\"${block.height}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"none\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Type label tab (top-left corner)\n  const labelText = `${block.type}${block.label ? ` [${block.label}]` : ''}`\n  const tabWidth = estimateTextWidth(labelText, FONT_SIZES.edgeLabel, FONT_WEIGHTS.groupHeader) + 16\n  const tabHeight = 18\n\n  parts.push(\n    `<rect x=\"${block.x}\" y=\"${block.y}\" width=\"${tabWidth}\" height=\"${tabHeight}\" ` +\n    `fill=\"var(--_group-hdr)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n  parts.push(\n    `<text x=\"${block.x + 6}\" y=\"${block.y + tabHeight / 2}\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.groupHeader}\" fill=\"var(--_text-sec)\">${escapeXml(labelText)}</text>`\n  )\n\n  // Divider lines (for alt/else, par/and)\n  for (const divider of block.dividers) {\n    parts.push(\n      `<line x1=\"${block.x}\" y1=\"${divider.y}\" x2=\"${block.x + block.width}\" y2=\"${divider.y}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"0.75\" stroke-dasharray=\"6 4\" />`\n    )\n    if (divider.label) {\n      parts.push(\n        `<text x=\"${block.x + 8}\" y=\"${divider.y + 14}\" font-size=\"${FONT_SIZES.edgeLabel}\" ` +\n        `font-weight=\"${FONT_WEIGHTS.edgeLabel}\" fill=\"var(--_text-muted)\">[${escapeXml(divider.label)}]</text>`\n      )\n    }\n  }\n\n  return parts.join('\\n')\n}\n\n/** Render a note box */\nfunction renderNote(note: PositionedNote): string {\n  // Folded corner effect: note rectangle + small triangle in top-right\n  const foldSize = 6\n  return (\n    `<rect x=\"${note.x}\" y=\"${note.y}\" width=\"${note.width}\" height=\"${note.height}\" ` +\n    `fill=\"var(--_group-hdr)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.innerBox}\" />` +\n    // Fold triangle\n    `\\n<polygon points=\"${note.x + note.width - foldSize},${note.y} ${note.x + note.width},${note.y + foldSize} ${note.x + note.width - foldSize},${note.y + foldSize}\" ` +\n    `fill=\"var(--_inner-stroke)\" />` +\n    // Note text\n    `\\n<text x=\"${note.x + note.width / 2}\" y=\"${note.y + note.height / 2}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" fill=\"var(--_text-muted)\">${escapeXml(note.text)}</text>`\n  )\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\nfunction escapeXml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}\n","// @ts-expect-error  dagre types are declared for the package root, not the dist path;\n// importing the pre-built browser bundle avoids Bun.build hanging on 30+ CJS file resolution\nimport dagre from '@dagrejs/dagre/dist/dagre.js'\nimport type { ClassDiagram, ClassNode, ClassMember, PositionedClassDiagram, PositionedClassNode, PositionedClassRelationship } from './types.ts'\nimport type { RenderOptions } from '../types.ts'\nimport { estimateTextWidth, estimateMonoTextWidth, FONT_SIZES, FONT_WEIGHTS } from '../styles.ts'\nimport { centerToTopLeft, snapToOrthogonal, clipEndpointsToNodes } from '../dagre-adapter.ts'\n\n// ============================================================================\n// Class diagram layout engine\n//\n// Uses dagre for positioning class boxes, then sizes each box based on\n// the number of attributes and methods it contains.\n//\n// Each class box has 3 compartments:\n//   1. Header (class name + optional annotation)\n//   2. Attributes section\n//   3. Methods section\n// ============================================================================\n\n/** Layout constants for class diagrams */\nexport const CLS = {\n  /** Padding around the diagram */\n  padding: 40,\n  /** Horizontal padding inside class boxes  used by both layout and renderer */\n  boxPadX: 8,\n  /** Header height (class name + annotation) */\n  headerBaseHeight: 32,\n  /** Extra height when annotation is present */\n  annotationHeight: 16,\n  /** Height per member row (attribute or method) */\n  memberRowHeight: 20,\n  /** Vertical padding around member sections (4px top + 4px bottom) */\n  sectionPadY: 8,\n  /** Minimum empty section height (when no attrs or no methods) */\n  emptySectionHeight: 8,\n  /** Minimum box width */\n  minWidth: 120,\n  /** Font size for member text */\n  memberFontSize: 11,\n  /** Font weight for member text */\n  memberFontWeight: 400,\n  /** Spacing between class nodes */\n  nodeSpacing: 40,\n  /** Spacing between layers */\n  layerSpacing: 60,\n} as const\n\n/**\n * Lay out a parsed class diagram using dagre.\n * Returns positioned class nodes and relationship paths.\n *\n * Kept async for API compatibility  dagre itself is synchronous.\n */\nexport async function layoutClassDiagram(\n  diagram: ClassDiagram,\n  _options: RenderOptions = {}\n): Promise<PositionedClassDiagram> {\n  if (diagram.classes.length === 0) {\n    return { width: 0, height: 0, classes: [], relationships: [] }\n  }\n\n  // 1. Calculate box dimensions for each class\n  const classSizes = new Map<string, { width: number; height: number; headerHeight: number; attrHeight: number; methodHeight: number }>()\n\n  for (const cls of diagram.classes) {\n    const headerHeight = cls.annotation\n      ? CLS.headerBaseHeight + CLS.annotationHeight\n      : CLS.headerBaseHeight\n\n    const attrHeight = cls.attributes.length > 0\n      ? cls.attributes.length * CLS.memberRowHeight + CLS.sectionPadY\n      : CLS.emptySectionHeight\n\n    const methodHeight = cls.methods.length > 0\n      ? cls.methods.length * CLS.memberRowHeight + CLS.sectionPadY\n      : CLS.emptySectionHeight\n\n    // Width: max of header text, widest attribute, widest method\n    const headerTextW = estimateTextWidth(cls.label, FONT_SIZES.nodeLabel, FONT_WEIGHTS.nodeLabel)\n    const maxAttrW = maxMemberWidth(cls.attributes)\n    const maxMethodW = maxMemberWidth(cls.methods)\n    const width = Math.max(CLS.minWidth, headerTextW + CLS.boxPadX * 2, maxAttrW + CLS.boxPadX * 2, maxMethodW + CLS.boxPadX * 2)\n\n    const height = headerHeight + attrHeight + methodHeight\n\n    classSizes.set(cls.id, { width, height, headerHeight, attrHeight, methodHeight })\n  }\n\n  // 2. Build dagre graph\n  const g = new dagre.graphlib.Graph({ directed: true })\n  g.setGraph({\n    rankdir: 'TB',\n    acyclicer: 'greedy', // break cycles before ranking to prevent infinite loop on bidirectional edges\n    nodesep: CLS.nodeSpacing,\n    ranksep: CLS.layerSpacing,\n    marginx: CLS.padding,\n    marginy: CLS.padding,\n  })\n  g.setDefaultEdgeLabel(() => ({}))\n\n  for (const cls of diagram.classes) {\n    const size = classSizes.get(cls.id)!\n    g.setNode(cls.id, { width: size.width, height: size.height })\n  }\n\n  // Add edges with label dimensions for collision-free label placement\n  for (let i = 0; i < diagram.relationships.length; i++) {\n    const rel = diagram.relationships[i]!\n    const edgeLabel: Record<string, unknown> = { _index: i }\n    if (rel.label) {\n      edgeLabel.label = rel.label\n      edgeLabel.width = estimateTextWidth(rel.label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel) + 8\n      edgeLabel.height = FONT_SIZES.edgeLabel + 6\n      edgeLabel.labelpos = 'c'\n    }\n    g.setEdge(rel.from, rel.to, edgeLabel)\n  }\n\n  // 3. Run dagre layout (synchronous).\n  // Wrapped in try-catch to surface clear errors on malformed class diagrams.\n  try {\n    dagre.layout(g)\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err)\n    throw new Error(`Dagre layout failed (class diagram): ${message}`)\n  }\n\n  // 4. Extract positioned classes\n  const classLookup = new Map<string, ClassNode>()\n  for (const cls of diagram.classes) classLookup.set(cls.id, cls)\n\n  const positionedClasses: PositionedClassNode[] = diagram.classes.map(cls => {\n    const dagreNode = g.node(cls.id)\n    const size = classSizes.get(cls.id)!\n    const topLeft = centerToTopLeft(dagreNode.x, dagreNode.y, dagreNode.width, dagreNode.height)\n    return {\n      id: cls.id,\n      label: cls.label,\n      annotation: cls.annotation,\n      attributes: cls.attributes,\n      methods: cls.methods,\n      x: topLeft.x,\n      y: topLeft.y,\n      width: dagreNode.width ?? size.width,\n      height: dagreNode.height ?? size.height,\n      headerHeight: size.headerHeight,\n      attrHeight: size.attrHeight,\n      methodHeight: size.methodHeight,\n    }\n  })\n\n  // 5. Extract relationship paths and label positions\n  const relationships: PositionedClassRelationship[] = g.edges().map(edgeObj => {\n    const dagreEdge = g.edge(edgeObj)\n    const rel = diagram.relationships[dagreEdge._index as number]!\n    const rawPoints = dagreEdge.points ?? []\n    // TB layout  vertical-first bends\n    const orthoPoints = snapToOrthogonal(rawPoints, true)\n\n    // Clip endpoints to the correct side of source/target class boxes.\n    // After orthogonalization the approach direction may differ from dagre's\n    // original boundary intersection  e.g. a horizontal last segment should\n    // connect to the side of the target at its vertical center, not the top.\n    const srcNode = g.node(edgeObj.v)\n    const tgtNode = g.node(edgeObj.w)\n    const points = clipEndpointsToNodes(\n      orthoPoints,\n      srcNode ? { cx: srcNode.x, cy: srcNode.y, hw: srcNode.width / 2, hh: srcNode.height / 2 } : null,\n      tgtNode ? { cx: tgtNode.x, cy: tgtNode.y, hw: tgtNode.width / 2, hh: tgtNode.height / 2 } : null,\n    )\n\n    // Dagre returns edge label center position directly as edge.x, edge.y\n    let labelPosition: { x: number; y: number } | undefined\n    if (rel.label && dagreEdge.x != null && dagreEdge.y != null) {\n      labelPosition = { x: dagreEdge.x, y: dagreEdge.y }\n    }\n\n    return {\n      from: rel.from,\n      to: rel.to,\n      type: rel.type,\n      markerAt: rel.markerAt,\n      label: rel.label,\n      fromCardinality: rel.fromCardinality,\n      toCardinality: rel.toCardinality,\n      points,\n      labelPosition,\n    }\n  })\n\n  return {\n    width: g.graph().width ?? 600,\n    height: g.graph().height ?? 400,\n    classes: positionedClasses,\n    relationships,\n  }\n}\n\n/** Calculate the max width of a list of class members (uses mono metrics) */\nfunction maxMemberWidth(members: ClassMember[]): number {\n  if (members.length === 0) return 0\n  let maxW = 0\n  for (const m of members) {\n    const text = memberToString(m)\n    // Members render in monospace  use mono width estimation for accurate box sizing\n    const w = estimateMonoTextWidth(text, CLS.memberFontSize)\n    if (w > maxW) maxW = w\n  }\n  return maxW\n}\n\n/** Convert a class member to its display string */\nexport function memberToString(m: ClassMember): string {\n  const vis = m.visibility ? `${m.visibility} ` : ''\n  const type = m.type ? `: ${m.type}` : ''\n  return `${vis}${m.name}${type}`\n}\n","import type { PositionedClassDiagram, PositionedClassNode, PositionedClassRelationship, ClassMember, RelationshipType } from './types.ts'\nimport type { DiagramColors } from '../theme.ts'\nimport { svgOpenTag, buildStyleBlock } from '../theme.ts'\nimport { FONT_SIZES, FONT_WEIGHTS, STROKE_WIDTHS, estimateTextWidth, TEXT_BASELINE_SHIFT } from '../styles.ts'\nimport { CLS } from './layout.ts'\n\n// ============================================================================\n// Class diagram SVG renderer\n//\n// Renders positioned class diagrams to SVG.\n// All colors use CSS custom properties (var(--_xxx)) from the theme system.\n//\n// Render order:\n//   1. Relationship lines (behind boxes)\n//   2. Class boxes (header + attributes + methods compartments)\n//   3. Relationship endpoint markers (diamonds, triangles)\n//   4. Labels and cardinality\n// ============================================================================\n\n/** Font sizes specific to class diagrams */\nconst CLS_FONT = {\n  memberSize: 11,\n  memberWeight: 400,\n  annotationSize: 10,\n  annotationWeight: 500,\n} as const\n\n/**\n * Render a positioned class diagram as an SVG string.\n *\n * @param colors - DiagramColors with bg/fg and optional enrichment variables.\n * @param transparent - If true, renders with transparent background.\n */\nexport function renderClassSvg(\n  diagram: PositionedClassDiagram,\n  colors: DiagramColors,\n  font: string = 'Inter',\n  transparent: boolean = false\n): string {\n  const parts: string[] = []\n\n  // SVG root with CSS variables + style block (with mono font) + defs\n  parts.push(svgOpenTag(diagram.width, diagram.height, colors, transparent))\n  parts.push(buildStyleBlock(font, true))\n  parts.push('<defs>')\n  parts.push(relationshipMarkerDefs())\n  parts.push('</defs>')\n\n  // 1. Relationship lines (rendered behind boxes)\n  for (const rel of diagram.relationships) {\n    parts.push(renderRelationship(rel))\n  }\n\n  // 2. Class boxes\n  for (const cls of diagram.classes) {\n    parts.push(renderClassBox(cls))\n  }\n\n  // 3. Relationship labels and cardinality\n  for (const rel of diagram.relationships) {\n    parts.push(renderRelationshipLabels(rel))\n  }\n\n  parts.push('</svg>')\n  return parts.join('\\n')\n}\n\n// ============================================================================\n// Marker definitions\n// ============================================================================\n\n/**\n * Marker definitions for class relationship endpoints.\n * Each relationship type has a distinct marker:\n *   - inheritance: hollow triangle\n *   - composition: filled diamond\n *   - aggregation: hollow diamond\n *   - association: open arrow (simple >)\n *   - dependency: open arrow (simple >)\n *   - realization: hollow triangle (same as inheritance)\n *\n * Uses var(--_arrow) for fill/stroke and var(--bg) for hollow marker fills.\n */\nfunction relationshipMarkerDefs(): string {\n  return (\n    // Hollow triangle (inheritance, realization)  points at target\n    `  <marker id=\"cls-inherit\" markerWidth=\"12\" markerHeight=\"10\" refX=\"12\" refY=\"5\" orient=\"auto-start-reverse\">` +\n    `\\n    <polygon points=\"0 0, 12 5, 0 10\" fill=\"var(--bg)\" stroke=\"var(--_arrow)\" stroke-width=\"1.5\" />` +\n    `\\n  </marker>` +\n    // Filled diamond (composition)  points at source\n    `\\n  <marker id=\"cls-composition\" markerWidth=\"12\" markerHeight=\"10\" refX=\"0\" refY=\"5\" orient=\"auto-start-reverse\">` +\n    `\\n    <polygon points=\"6 0, 12 5, 6 10, 0 5\" fill=\"var(--_arrow)\" stroke=\"var(--_arrow)\" stroke-width=\"1\" />` +\n    `\\n  </marker>` +\n    // Hollow diamond (aggregation)  points at source\n    `\\n  <marker id=\"cls-aggregation\" markerWidth=\"12\" markerHeight=\"10\" refX=\"0\" refY=\"5\" orient=\"auto-start-reverse\">` +\n    `\\n    <polygon points=\"6 0, 12 5, 6 10, 0 5\" fill=\"var(--bg)\" stroke=\"var(--_arrow)\" stroke-width=\"1.5\" />` +\n    `\\n  </marker>` +\n    // Open arrow (association, dependency)\n    `\\n  <marker id=\"cls-arrow\" markerWidth=\"8\" markerHeight=\"6\" refX=\"8\" refY=\"3\" orient=\"auto-start-reverse\">` +\n    `\\n    <polyline points=\"0 0, 8 3, 0 6\" fill=\"none\" stroke=\"var(--_arrow)\" stroke-width=\"1.5\" />` +\n    `\\n  </marker>`\n  )\n}\n\n// ============================================================================\n// Class box rendering\n// ============================================================================\n\n/** Render a class box with 3 compartments: header, attributes, methods */\nfunction renderClassBox(cls: PositionedClassNode): string {\n  const { x, y, width, height, headerHeight, attrHeight, methodHeight } = cls\n  const parts: string[] = []\n\n  // Outer rectangle (full box)\n  parts.push(\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"var(--_node-fill)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Header background\n  parts.push(\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${headerHeight}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"var(--_group-hdr)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Annotation (<<interface>>, <<abstract>>, etc.)\n  let nameY = y + headerHeight / 2\n  if (cls.annotation) {\n    const annotY = y + 12\n    parts.push(\n      `<text x=\"${x + width / 2}\" y=\"${annotY}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n      `font-size=\"${CLS_FONT.annotationSize}\" font-weight=\"${CLS_FONT.annotationWeight}\" ` +\n      `font-style=\"italic\" fill=\"var(--_text-muted)\">&lt;&lt;${escapeXml(cls.annotation)}&gt;&gt;</text>`\n    )\n    nameY = y + headerHeight / 2 + 6\n  }\n\n  // Class name\n  parts.push(\n    `<text x=\"${x + width / 2}\" y=\"${nameY}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.nodeLabel}\" font-weight=\"700\" fill=\"var(--_text)\">${escapeXml(cls.label)}</text>`\n  )\n\n  // Divider line between header and attributes\n  const attrTop = y + headerHeight\n  parts.push(\n    `<line x1=\"${x}\" y1=\"${attrTop}\" x2=\"${x + width}\" y2=\"${attrTop}\" ` +\n    `stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.innerBox}\" />`\n  )\n\n  // Attributes\n  const memberRowH = 20\n  for (let i = 0; i < cls.attributes.length; i++) {\n    const member = cls.attributes[i]!\n    const memberY = attrTop + 4 + i * memberRowH + memberRowH / 2\n    parts.push(renderMember(member, x + CLS.boxPadX, memberY))\n  }\n\n  // Divider line between attributes and methods\n  const methodTop = attrTop + attrHeight\n  parts.push(\n    `<line x1=\"${x}\" y1=\"${methodTop}\" x2=\"${x + width}\" y2=\"${methodTop}\" ` +\n    `stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.innerBox}\" />`\n  )\n\n  // Methods\n  for (let i = 0; i < cls.methods.length; i++) {\n    const member = cls.methods[i]!\n    const memberY = methodTop + 4 + i * memberRowH + memberRowH / 2\n    parts.push(renderMember(member, x + CLS.boxPadX, memberY))\n  }\n\n  return parts.join('\\n')\n}\n\n/**\n * Render a single class member with syntax highlighting.\n * Uses <tspan> elements to color each part of the member differently:\n *   - visibility symbol (+/-/#/~)  textFaint\n *   - member name (incl. parens for methods)  textSecondary\n *   - colon separator  textFaint\n *   - type annotation  textMuted\n */\nfunction renderMember(member: ClassMember, x: number, y: number): string {\n  const fontStyle = member.isAbstract ? ' font-style=\"italic\"' : ''\n  const decoration = member.isStatic ? ' text-decoration=\"underline\"' : ''\n\n  // Build tspan parts for syntax-highlighted member text\n  const spans: string[] = []\n\n  if (member.visibility) {\n    spans.push(`<tspan fill=\"var(--_text-faint)\">${escapeXml(member.visibility)} </tspan>`)\n  }\n\n  spans.push(`<tspan fill=\"var(--_text-sec)\">${escapeXml(member.name)}</tspan>`)\n\n  if (member.type) {\n    spans.push(`<tspan fill=\"var(--_text-faint)\">: </tspan>`)\n    spans.push(`<tspan fill=\"var(--_text-muted)\">${escapeXml(member.type)}</tspan>`)\n  }\n\n  return (\n    `<text x=\"${x}\" y=\"${y}\" class=\"mono\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${CLS_FONT.memberSize}\" font-weight=\"${CLS_FONT.memberWeight}\"${fontStyle}${decoration}>` +\n    `${spans.join('')}</text>`\n  )\n}\n\n// ============================================================================\n// Relationship rendering\n// ============================================================================\n\n/** Render a relationship line with appropriate markers */\nfunction renderRelationship(rel: PositionedClassRelationship): string {\n  if (rel.points.length < 2) return ''\n\n  const pathData = rel.points.map(p => `${p.x},${p.y}`).join(' ')\n  const isDashed = rel.type === 'dependency' || rel.type === 'realization'\n  const dashArray = isDashed ? ' stroke-dasharray=\"6 4\"' : ''\n\n  // Determine markers based on relationship type and which end has the marker\n  const markers = getRelationshipMarkers(rel.type, rel.markerAt)\n\n  return (\n    `<polyline points=\"${pathData}\" fill=\"none\" stroke=\"var(--_line)\" ` +\n    `stroke-width=\"${STROKE_WIDTHS.connector}\"${dashArray}${markers} />`\n  )\n}\n\n/**\n * Get marker-start/marker-end attributes for a relationship type.\n * Uses `markerAt` from the parser to place the marker on the correct end:\n *   - 'from'  marker-start (prefix arrows like `<|--`, `*--`, `o--`)\n *   - 'to'    marker-end   (suffix arrows like `..|>`, `-->`, `--*`)\n */\nfunction getRelationshipMarkers(type: RelationshipType, markerAt: 'from' | 'to'): string {\n  const markerId = getMarkerDefId(type)\n  if (!markerId) return ''\n\n  if (markerAt === 'from') {\n    return ` marker-start=\"url(#${markerId})\"`\n  } else {\n    return ` marker-end=\"url(#${markerId})\"`\n  }\n}\n\n/** Map relationship type to its SVG marker definition ID */\nfunction getMarkerDefId(type: RelationshipType): string | null {\n  switch (type) {\n    case 'inheritance':\n    case 'realization':\n      return 'cls-inherit'\n    case 'composition':\n      return 'cls-composition'\n    case 'aggregation':\n      return 'cls-aggregation'\n    case 'association':\n    case 'dependency':\n      return 'cls-arrow'\n    default:\n      return null\n  }\n}\n\n/** Render relationship labels and cardinality text */\nfunction renderRelationshipLabels(rel: PositionedClassRelationship): string {\n  if (!rel.label && !rel.fromCardinality && !rel.toCardinality) return ''\n  if (rel.points.length < 2) return ''\n\n  const parts: string[] = []\n\n  // Label  prefer dagre-computed position (collision-aware), fall back to midpoint\n  if (rel.label) {\n    const pos = rel.labelPosition ?? midpoint(rel.points)\n    parts.push(\n      `<text x=\"${pos.x}\" y=\"${pos.y - 8}\" text-anchor=\"middle\" ` +\n      `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" ` +\n      `fill=\"var(--_text-muted)\">${escapeXml(rel.label)}</text>`\n    )\n  }\n\n  // From cardinality (near start)\n  if (rel.fromCardinality) {\n    const p = rel.points[0]!\n    const next = rel.points[1]!\n    const offset = cardinalityOffset(p, next)\n    parts.push(\n      `<text x=\"${p.x + offset.x}\" y=\"${p.y + offset.y}\" text-anchor=\"middle\" ` +\n      `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" ` +\n      `fill=\"var(--_text-muted)\">${escapeXml(rel.fromCardinality)}</text>`\n    )\n  }\n\n  // To cardinality (near end)\n  if (rel.toCardinality) {\n    const p = rel.points[rel.points.length - 1]!\n    const prev = rel.points[rel.points.length - 2]!\n    const offset = cardinalityOffset(p, prev)\n    parts.push(\n      `<text x=\"${p.x + offset.x}\" y=\"${p.y + offset.y}\" text-anchor=\"middle\" ` +\n      `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" ` +\n      `fill=\"var(--_text-muted)\">${escapeXml(rel.toCardinality)}</text>`\n    )\n  }\n\n  return parts.join('\\n')\n}\n\n/** Get the midpoint of a point array */\nfunction midpoint(points: Array<{ x: number; y: number }>): { x: number; y: number } {\n  if (points.length === 0) return { x: 0, y: 0 }\n  const mid = Math.floor(points.length / 2)\n  return points[mid]!\n}\n\n/** Calculate offset for cardinality label perpendicular to edge direction */\nfunction cardinalityOffset(\n  from: { x: number; y: number },\n  to: { x: number; y: number }\n): { x: number; y: number } {\n  const dx = to.x - from.x\n  const dy = to.y - from.y\n  // Place label perpendicular to the edge, 14px away\n  if (Math.abs(dx) > Math.abs(dy)) {\n    // Mostly horizontal  offset vertically\n    return { x: dx > 0 ? 14 : -14, y: -10 }\n  }\n  // Mostly vertical  offset horizontally\n  return { x: -14, y: dy > 0 ? 14 : -14 }\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\nfunction escapeXml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}\n","// @ts-expect-error  dagre types are declared for the package root, not the dist path;\n// importing the pre-built browser bundle avoids Bun.build hanging on 30+ CJS file resolution\nimport dagre from '@dagrejs/dagre/dist/dagre.js'\nimport type { ErDiagram, ErEntity, PositionedErDiagram, PositionedErEntity, PositionedErRelationship } from './types.ts'\nimport type { RenderOptions } from '../types.ts'\nimport { estimateTextWidth, estimateMonoTextWidth, FONT_SIZES, FONT_WEIGHTS } from '../styles.ts'\nimport { centerToTopLeft, snapToOrthogonal, clipEndpointsToNodes } from '../dagre-adapter.ts'\n\n// ============================================================================\n// ER diagram layout engine\n//\n// Uses dagre for positioning entity boxes, then sizes each box based on\n// the entity name and number of attributes.\n//\n// Each entity box has:\n//   1. Header (entity name)\n//   2. Attribute rows (type, name, keys)\n// ============================================================================\n\n/** Layout constants for ER diagrams */\nconst ER = {\n  padding: 40,\n  boxPadX: 12,\n  headerHeight: 32,\n  rowHeight: 22,\n  minWidth: 140,\n  attrFontSize: 11,\n  attrFontWeight: 400,\n  nodeSpacing: 50,\n  layerSpacing: 70,\n} as const\n\n/**\n * Lay out a parsed ER diagram using dagre.\n * Returns positioned entity boxes and relationship paths.\n *\n * Kept async for API compatibility  dagre itself is synchronous.\n */\nexport async function layoutErDiagram(\n  diagram: ErDiagram,\n  _options: RenderOptions = {}\n): Promise<PositionedErDiagram> {\n  if (diagram.entities.length === 0) {\n    return { width: 0, height: 0, entities: [], relationships: [] }\n  }\n\n  // 1. Calculate box dimensions for each entity\n  const entitySizes = new Map<string, { width: number; height: number }>()\n\n  for (const entity of diagram.entities) {\n    // Header width from entity label\n    const headerTextW = estimateTextWidth(entity.label, FONT_SIZES.nodeLabel, FONT_WEIGHTS.nodeLabel)\n\n    // Max attribute row width: \"type  name  PK FK\"\n    // Attribute text renders in monospace  use mono width estimation for accurate box sizing\n    let maxAttrW = 0\n    for (const attr of entity.attributes) {\n      const attrText = `${attr.type}  ${attr.name}${attr.keys.length > 0 ? '  ' + attr.keys.join(',') : ''}`\n      const w = estimateMonoTextWidth(attrText, ER.attrFontSize)\n      if (w > maxAttrW) maxAttrW = w\n    }\n\n    const width = Math.max(ER.minWidth, headerTextW + ER.boxPadX * 2, maxAttrW + ER.boxPadX * 2)\n    const height = ER.headerHeight + Math.max(entity.attributes.length, 1) * ER.rowHeight\n\n    entitySizes.set(entity.id, { width, height })\n  }\n\n  // 2. Build dagre graph\n  const g = new dagre.graphlib.Graph({ directed: true })\n  g.setGraph({\n    rankdir: 'LR',\n    acyclicer: 'greedy', // break cycles before ranking to prevent infinite loop on bidirectional edges\n    nodesep: ER.nodeSpacing,\n    ranksep: ER.layerSpacing,\n    marginx: ER.padding,\n    marginy: ER.padding,\n  })\n  g.setDefaultEdgeLabel(() => ({}))\n\n  for (const entity of diagram.entities) {\n    const size = entitySizes.get(entity.id)!\n    g.setNode(entity.id, { width: size.width, height: size.height })\n  }\n\n  for (let i = 0; i < diagram.relationships.length; i++) {\n    const rel = diagram.relationships[i]!\n    g.setEdge(rel.entity1, rel.entity2, {\n      _index: i,\n      label: rel.label,\n      width: estimateTextWidth(rel.label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel) + 8,\n      height: FONT_SIZES.edgeLabel + 6,\n      labelpos: 'c',\n    })\n  }\n\n  // 3. Run dagre layout (synchronous).\n  // Wrapped in try-catch to surface clear errors on malformed ER diagrams.\n  try {\n    dagre.layout(g)\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err)\n    throw new Error(`Dagre layout failed (ER diagram): ${message}`)\n  }\n\n  // 4. Extract positioned entities\n  const entityLookup = new Map<string, ErEntity>()\n  for (const entity of diagram.entities) entityLookup.set(entity.id, entity)\n\n  const positionedEntities: PositionedErEntity[] = diagram.entities.map(entity => {\n    const dagreNode = g.node(entity.id)\n    const topLeft = centerToTopLeft(dagreNode.x, dagreNode.y, dagreNode.width, dagreNode.height)\n    return {\n      id: entity.id,\n      label: entity.label,\n      attributes: entity.attributes,\n      x: topLeft.x,\n      y: topLeft.y,\n      width: dagreNode.width ?? entitySizes.get(entity.id)!.width,\n      height: dagreNode.height ?? entitySizes.get(entity.id)!.height,\n      headerHeight: ER.headerHeight,\n      rowHeight: ER.rowHeight,\n    }\n  })\n\n  // 5. Extract relationship paths\n  const relationships: PositionedErRelationship[] = g.edges().map(edgeObj => {\n    const dagreEdge = g.edge(edgeObj)\n    const rel = diagram.relationships[dagreEdge._index as number]!\n    const rawPoints = dagreEdge.points ?? []\n    // LR layout  horizontal-first bends\n    const orthoPoints = snapToOrthogonal(rawPoints, false)\n\n    // Clip endpoints to the correct side of source/target entity boxes.\n    // After orthogonalization the approach direction may differ from dagre's\n    // original boundary intersection  e.g. a vertical last segment should\n    // connect to the top/bottom of the target at its horizontal center.\n    const srcNode = g.node(edgeObj.v)\n    const tgtNode = g.node(edgeObj.w)\n    const points = clipEndpointsToNodes(\n      orthoPoints,\n      srcNode ? { cx: srcNode.x, cy: srcNode.y, hw: srcNode.width / 2, hh: srcNode.height / 2 } : null,\n      tgtNode ? { cx: tgtNode.x, cy: tgtNode.y, hw: tgtNode.width / 2, hh: tgtNode.height / 2 } : null,\n    )\n\n    return {\n      entity1: rel.entity1,\n      entity2: rel.entity2,\n      cardinality1: rel.cardinality1,\n      cardinality2: rel.cardinality2,\n      label: rel.label,\n      identifying: rel.identifying,\n      points,\n    }\n  })\n\n  return {\n    width: g.graph().width ?? 600,\n    height: g.graph().height ?? 400,\n    entities: positionedEntities,\n    relationships,\n  }\n}\n","import type { PositionedErDiagram, PositionedErEntity, PositionedErRelationship, ErAttribute, Cardinality } from './types.ts'\nimport type { DiagramColors } from '../theme.ts'\nimport { svgOpenTag, buildStyleBlock } from '../theme.ts'\nimport { FONT_SIZES, FONT_WEIGHTS, STROKE_WIDTHS, estimateTextWidth, TEXT_BASELINE_SHIFT } from '../styles.ts'\n\n// ============================================================================\n// ER diagram SVG renderer\n//\n// Renders positioned ER diagrams to SVG.\n// All colors use CSS custom properties (var(--_xxx)) from the theme system.\n//\n// Render order:\n//   1. Relationship lines (behind boxes)\n//   2. Entity boxes (header + attribute rows)\n//   3. Cardinality markers (crow's foot notation)\n//   4. Relationship labels\n// ============================================================================\n\n/** Font sizes specific to ER diagrams */\nconst ER_FONT = {\n  attrSize: 11,\n  attrWeight: 400,\n  keySize: 9,\n  keyWeight: 600,\n} as const\n\n/**\n * Render a positioned ER diagram as an SVG string.\n *\n * @param colors - DiagramColors with bg/fg and optional enrichment variables.\n * @param transparent - If true, renders with transparent background.\n */\nexport function renderErSvg(\n  diagram: PositionedErDiagram,\n  colors: DiagramColors,\n  font: string = 'Inter',\n  transparent: boolean = false\n): string {\n  const parts: string[] = []\n\n  // SVG root with CSS variables + style block (with mono font) + defs\n  parts.push(svgOpenTag(diagram.width, diagram.height, colors, transparent))\n  parts.push(buildStyleBlock(font, true))\n  parts.push('<defs>')\n  parts.push('</defs>') // No marker defs  we draw crow's foot inline\n\n  // 1. Relationship lines\n  for (const rel of diagram.relationships) {\n    parts.push(renderRelationshipLine(rel))\n  }\n\n  // 2. Entity boxes\n  for (const entity of diagram.entities) {\n    parts.push(renderEntityBox(entity))\n  }\n\n  // 3. Cardinality markers at relationship endpoints\n  for (const rel of diagram.relationships) {\n    parts.push(renderCardinality(rel))\n  }\n\n  // 4. Relationship labels\n  for (const rel of diagram.relationships) {\n    parts.push(renderRelationshipLabel(rel))\n  }\n\n  parts.push('</svg>')\n  return parts.join('\\n')\n}\n\n// ============================================================================\n// Entity box rendering\n// ============================================================================\n\n/** Render an entity box with header and attribute rows */\nfunction renderEntityBox(entity: PositionedErEntity): string {\n  const { x, y, width, height, headerHeight, rowHeight, label, attributes } = entity\n  const parts: string[] = []\n\n  // Outer rectangle\n  parts.push(\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"var(--_node-fill)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Header background\n  parts.push(\n    `<rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${headerHeight}\" ` +\n    `rx=\"0\" ry=\"0\" fill=\"var(--_group-hdr)\" stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.outerBox}\" />`\n  )\n\n  // Entity name\n  parts.push(\n    `<text x=\"${x + width / 2}\" y=\"${y + headerHeight / 2}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.nodeLabel}\" font-weight=\"700\" fill=\"var(--_text)\">${escapeXml(label)}</text>`\n  )\n\n  // Divider\n  const attrTop = y + headerHeight\n  parts.push(\n    `<line x1=\"${x}\" y1=\"${attrTop}\" x2=\"${x + width}\" y2=\"${attrTop}\" ` +\n    `stroke=\"var(--_node-stroke)\" stroke-width=\"${STROKE_WIDTHS.innerBox}\" />`\n  )\n\n  // Attribute rows\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i]!\n    const rowY = attrTop + i * rowHeight + rowHeight / 2\n    parts.push(renderAttribute(attr, x, rowY, width))\n  }\n\n  // Empty row placeholder when no attributes\n  if (attributes.length === 0) {\n    parts.push(\n      `<text x=\"${x + width / 2}\" y=\"${attrTop + rowHeight / 2}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n      `font-size=\"${ER_FONT.attrSize}\" fill=\"var(--_text-faint)\" font-style=\"italic\">(no attributes)</text>`\n    )\n  }\n\n  return parts.join('\\n')\n}\n\n/**\n * Render a single attribute row with monospace syntax highlighting.\n * Layout: [PK badge]  type  name  (left-aligned in mono, name right-aligned)\n * Uses <tspan> elements for per-part coloring, matching the class diagram style.\n *\n * Key badge uses var(--_key-badge) for background tint.\n */\nfunction renderAttribute(attr: ErAttribute, boxX: number, y: number, boxWidth: number): string {\n  const parts: string[] = []\n\n  // Key badges on the left (keep proportional font  they're visual tags, not code)\n  let keyWidth = 0\n  if (attr.keys.length > 0) {\n    const keyText = attr.keys.join(',')\n    keyWidth = estimateTextWidth(keyText, ER_FONT.keySize, ER_FONT.keyWeight) + 8\n    parts.push(\n      `<rect x=\"${boxX + 6}\" y=\"${y - 7}\" width=\"${keyWidth}\" height=\"14\" rx=\"2\" ry=\"2\" ` +\n      `fill=\"var(--_key-badge)\" />`\n    )\n    parts.push(\n      `<text x=\"${boxX + 6 + keyWidth / 2}\" y=\"${y}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n      `font-size=\"${ER_FONT.keySize}\" font-weight=\"${ER_FONT.keyWeight}\" fill=\"var(--_text-sec)\">${attr.keys.join(',')}</text>`\n    )\n  }\n\n  // Type (left-aligned after keys, monospace with syntax highlighting)\n  const typeX = boxX + 8 + (keyWidth > 0 ? keyWidth + 6 : 0)\n  parts.push(\n    `<text x=\"${typeX}\" y=\"${y}\" class=\"mono\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${ER_FONT.attrSize}\" font-weight=\"${ER_FONT.attrWeight}\">` +\n    `<tspan fill=\"var(--_text-muted)\">${escapeXml(attr.type)}</tspan></text>`\n  )\n\n  // Name (right-aligned, monospace with syntax highlighting)\n  const nameX = boxX + boxWidth - 8\n  parts.push(\n    `<text x=\"${nameX}\" y=\"${y}\" class=\"mono\" text-anchor=\"end\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${ER_FONT.attrSize}\" font-weight=\"${ER_FONT.attrWeight}\">` +\n    `<tspan fill=\"var(--_text-sec)\">${escapeXml(attr.name)}</tspan></text>`\n  )\n\n  return parts.join('\\n')\n}\n\n// ============================================================================\n// Relationship rendering\n// ============================================================================\n\n/** Render a relationship line */\nfunction renderRelationshipLine(rel: PositionedErRelationship): string {\n  if (rel.points.length < 2) return ''\n\n  const pathData = rel.points.map(p => `${p.x},${p.y}`).join(' ')\n  const dashArray = !rel.identifying ? ' stroke-dasharray=\"6 4\"' : ''\n\n  return (\n    `<polyline points=\"${pathData}\" fill=\"none\" stroke=\"var(--_line)\" ` +\n    `stroke-width=\"${STROKE_WIDTHS.connector}\"${dashArray} />`\n  )\n}\n\n/** Render a relationship label at the midpoint */\nfunction renderRelationshipLabel(rel: PositionedErRelationship): string {\n  if (!rel.label || rel.points.length < 2) return ''\n\n  const mid = midpoint(rel.points)\n  const textWidth = estimateTextWidth(rel.label, FONT_SIZES.edgeLabel, FONT_WEIGHTS.edgeLabel)\n\n  // Background pill for readability\n  const bgW = textWidth + 8\n  const bgH = FONT_SIZES.edgeLabel + 6\n\n  return (\n    `<rect x=\"${mid.x - bgW / 2}\" y=\"${mid.y - bgH / 2}\" width=\"${bgW}\" height=\"${bgH}\" rx=\"2\" ry=\"2\" ` +\n    `fill=\"var(--bg)\" stroke=\"var(--_inner-stroke)\" stroke-width=\"0.5\" />` +\n    `\\n<text x=\"${mid.x}\" y=\"${mid.y}\" text-anchor=\"middle\" dy=\"${TEXT_BASELINE_SHIFT}\" ` +\n    `font-size=\"${FONT_SIZES.edgeLabel}\" font-weight=\"${FONT_WEIGHTS.edgeLabel}\" fill=\"var(--_text-muted)\">${escapeXml(rel.label)}</text>`\n  )\n}\n\n/**\n * Render crow's foot cardinality markers at both endpoints of a relationship.\n *\n * Crow's foot notation:\n *   'one':          (single vertical line)\n *   'zero-one':  o  (circle + single line)\n *   'many':         (crow's foot + single line)\n *   'zero-many': o  (circle + crow's foot)\n */\nfunction renderCardinality(rel: PositionedErRelationship): string {\n  if (rel.points.length < 2) return ''\n  const parts: string[] = []\n\n  // Entity1 side (first point, direction toward second point)\n  const p1 = rel.points[0]!\n  const p2 = rel.points[1]!\n  parts.push(renderCrowsFoot(p1, p2, rel.cardinality1))\n\n  // Entity2 side (last point, direction toward second-to-last point)\n  const pN = rel.points[rel.points.length - 1]!\n  const pN1 = rel.points[rel.points.length - 2]!\n  parts.push(renderCrowsFoot(pN, pN1, rel.cardinality2))\n\n  return parts.join('\\n')\n}\n\n/**\n * Render a crow's foot marker at a given endpoint.\n * `point` is the endpoint, `toward` gives the direction the line comes from.\n */\nfunction renderCrowsFoot(\n  point: { x: number; y: number },\n  toward: { x: number; y: number },\n  cardinality: Cardinality\n): string {\n  const parts: string[] = []\n  const sw = STROKE_WIDTHS.connector + 0.25\n\n  // Calculate direction from toward  point (unit vector)\n  const dx = point.x - toward.x\n  const dy = point.y - toward.y\n  const len = Math.sqrt(dx * dx + dy * dy)\n  if (len === 0) return ''\n  const ux = dx / len\n  const uy = dy / len\n\n  // Perpendicular direction\n  const px = -uy\n  const py = ux\n\n  // Marker sits 4px from the endpoint, extending 12px back along the edge\n  const tipX = point.x - ux * 4\n  const tipY = point.y - uy * 4\n  const backX = point.x - ux * 16\n  const backY = point.y - uy * 16\n\n  // Single line: always present for 'one' and part of others\n  const hasOneLine = cardinality === 'one' || cardinality === 'zero-one'\n  const hasCrowsFoot = cardinality === 'many' || cardinality === 'zero-many'\n  const hasCircle = cardinality === 'zero-one' || cardinality === 'zero-many'\n\n  // Draw single vertical line (perpendicular to edge) at the tip\n  if (hasOneLine) {\n    const halfW = 6\n    parts.push(\n      `<line x1=\"${tipX + px * halfW}\" y1=\"${tipY + py * halfW}\" ` +\n      `x2=\"${tipX - px * halfW}\" y2=\"${tipY - py * halfW}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"${sw}\" />`\n    )\n    // Second line slightly back for \"exactly one\" emphasis\n    const line2X = tipX - ux * 4\n    const line2Y = tipY - uy * 4\n    parts.push(\n      `<line x1=\"${line2X + px * halfW}\" y1=\"${line2Y + py * halfW}\" ` +\n      `x2=\"${line2X - px * halfW}\" y2=\"${line2Y - py * halfW}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"${sw}\" />`\n    )\n  }\n\n  // Crow's foot (three lines fanning out from tip)\n  if (hasCrowsFoot) {\n    const fanW = 7\n    // Center line\n    const cfTipX = tipX\n    const cfTipY = tipY\n    // Three lines from tip to back, fanning out\n    parts.push(\n      // Top fan line\n      `<line x1=\"${cfTipX + px * fanW}\" y1=\"${cfTipY + py * fanW}\" ` +\n      `x2=\"${backX}\" y2=\"${backY}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"${sw}\" />`\n    )\n    parts.push(\n      // Center line\n      `<line x1=\"${cfTipX}\" y1=\"${cfTipY}\" ` +\n      `x2=\"${backX}\" y2=\"${backY}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"${sw}\" />`\n    )\n    parts.push(\n      // Bottom fan line\n      `<line x1=\"${cfTipX - px * fanW}\" y1=\"${cfTipY - py * fanW}\" ` +\n      `x2=\"${backX}\" y2=\"${backY}\" ` +\n      `stroke=\"var(--_line)\" stroke-width=\"${sw}\" />`\n    )\n  }\n\n  // Circle (for zero variants)\n  if (hasCircle) {\n    const circleOffset = hasCrowsFoot ? 20 : 12\n    const circleX = point.x - ux * circleOffset\n    const circleY = point.y - uy * circleOffset\n    parts.push(\n      `<circle cx=\"${circleX}\" cy=\"${circleY}\" r=\"4\" ` +\n      `fill=\"var(--bg)\" stroke=\"var(--_line)\" stroke-width=\"${sw}\" />`\n    )\n  }\n\n  return parts.join('\\n')\n}\n\n/** Compute the arc-length midpoint of a polyline path.\n *  Walks along each segment, finds the point at exactly 50% of total path length.\n *  This ensures the label sits ON the path even for orthogonal routes with bends,\n *  unlike the naive first/last geometric center which floats in space for L/Z shapes. */\nfunction midpoint(points: Array<{ x: number; y: number }>): { x: number; y: number } {\n  if (points.length === 0) return { x: 0, y: 0 }\n  if (points.length === 1) return points[0]!\n\n  // Compute total path length\n  let totalLen = 0\n  for (let i = 1; i < points.length; i++) {\n    const dx = points[i]!.x - points[i - 1]!.x\n    const dy = points[i]!.y - points[i - 1]!.y\n    totalLen += Math.sqrt(dx * dx + dy * dy)\n  }\n\n  if (totalLen === 0) return points[0]!\n\n  // Walk to 50% of total length, interpolating within the segment that crosses the halfway mark\n  const halfLen = totalLen / 2\n  let walked = 0\n  for (let i = 1; i < points.length; i++) {\n    const dx = points[i]!.x - points[i - 1]!.x\n    const dy = points[i]!.y - points[i - 1]!.y\n    const segLen = Math.sqrt(dx * dx + dy * dy)\n    if (walked + segLen >= halfLen) {\n      const t = segLen > 0 ? (halfLen - walked) / segLen : 0\n      return {\n        x: points[i - 1]!.x + dx * t,\n        y: points[i - 1]!.y + dy * t,\n      }\n    }\n    walked += segLen\n  }\n\n  return points[points.length - 1]!\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\nfunction escapeXml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}\n","// ============================================================================\n// beautiful-mermaid  public API\n//\n// Renders Mermaid diagrams to styled SVG strings.\n// Framework-agnostic, no DOM required. Pure TypeScript.\n//\n// Supported diagram types:\n//   - Flowcharts (graph TD / flowchart LR)\n//   - State diagrams (stateDiagram-v2)\n//   - Sequence diagrams (sequenceDiagram)\n//   - Class diagrams (classDiagram)\n//   - ER diagrams (erDiagram)\n//\n// Theming uses CSS custom properties (--bg, --fg, + optional enrichment).\n// See src/theme.ts for the full variable system.\n//\n// Usage:\n//   import { renderMermaid } from 'beautiful-mermaid'\n//   const svg = await renderMermaid('graph TD\\n  A --> B')\n//   const svg = await renderMermaid('graph TD\\n  A --> B', { bg: '#1a1b26', fg: '#a9b1d6' })\n// ============================================================================\n\nexport type { RenderOptions, MermaidGraph, PositionedGraph } from './types.ts'\nexport type { DiagramColors, ThemeName } from './theme.ts'\nexport { fromShikiTheme, THEMES, DEFAULTS } from './theme.ts'\nexport { parseMermaid } from './parser.ts'\nexport { renderMermaidAscii } from './ascii/index.ts'\nexport type { AsciiRenderOptions } from './ascii/index.ts'\n\nimport { parseMermaid } from './parser.ts'\nimport { layoutGraph } from './layout.ts'\nimport { renderSvg } from './renderer.ts'\nimport type { RenderOptions } from './types.ts'\nimport type { DiagramColors } from './theme.ts'\nimport { DEFAULTS } from './theme.ts'\n\n// New diagram type imports\nimport { parseSequenceDiagram } from './sequence/parser.ts'\nimport { layoutSequenceDiagram } from './sequence/layout.ts'\nimport { renderSequenceSvg } from './sequence/renderer.ts'\nimport { parseClassDiagram } from './class/parser.ts'\nimport { layoutClassDiagram } from './class/layout.ts'\nimport { renderClassSvg } from './class/renderer.ts'\nimport { parseErDiagram } from './er/parser.ts'\nimport { layoutErDiagram } from './er/layout.ts'\nimport { renderErSvg } from './er/renderer.ts'\n\n/**\n * Detect the diagram type from the mermaid source text.\n * Returns the type keyword used for routing to the correct pipeline.\n */\nfunction detectDiagramType(text: string): 'flowchart' | 'sequence' | 'class' | 'er' {\n  const firstLine = text.trim().split('\\n')[0]?.trim().toLowerCase() ?? ''\n\n  if (/^sequencediagram\\s*$/.test(firstLine)) return 'sequence'\n  if (/^classdiagram\\s*$/.test(firstLine)) return 'class'\n  if (/^erdiagram\\s*$/.test(firstLine)) return 'er'\n\n  // Default: flowchart/state (handled by parseMermaid internally)\n  return 'flowchart'\n}\n\n/**\n * Build a DiagramColors object from render options.\n * Uses DEFAULTS for bg/fg when not provided, and passes through\n * optional enrichment colors (line, accent, muted, surface, border).\n */\nfunction buildColors(options: RenderOptions): DiagramColors {\n  return {\n    bg: options.bg ?? DEFAULTS.bg,\n    fg: options.fg ?? DEFAULTS.fg,\n    line: options.line,\n    accent: options.accent,\n    muted: options.muted,\n    surface: options.surface,\n    border: options.border,\n  }\n}\n\n/**\n * Render Mermaid diagram text to an SVG string.\n *\n * Async because layout engines run asynchronously.\n * Auto-detects diagram type from the header line.\n *\n * Colors are set via CSS custom properties on the <svg> tag:\n *   - bg/fg: Required base colors (default: white/#27272A)\n *   - line/accent/muted/surface/border: Optional enrichment colors\n *     (fall back to color-mix() derivations from bg+fg)\n *\n * @param text - Mermaid source text\n * @param options - Rendering options (colors, font, spacing)\n * @returns A self-contained SVG string\n *\n * @example\n * ```ts\n * // Mono  just defaults, everything derived from bg+fg\n * const svg = await renderMermaid('graph TD\\n  A --> B')\n *\n * // Custom colors\n * const svg = await renderMermaid('graph TD\\n  A --> B', {\n *   bg: '#1a1b26', fg: '#a9b1d6'\n * })\n *\n * // Enriched  Tokyo Night with accent + line colors\n * const svg = await renderMermaid('graph TD\\n  A --> B', {\n *   bg: '#1a1b26', fg: '#a9b1d6',\n *   line: '#3d59a1', accent: '#7aa2f7', muted: '#565f89',\n * })\n * ```\n */\nexport async function renderMermaid(\n  text: string,\n  options: RenderOptions = {}\n): Promise<string> {\n  const colors = buildColors(options)\n  const font = options.font ?? 'Inter'\n  const transparent = options.transparent ?? false\n  const diagramType = detectDiagramType(text)\n\n  // Preprocess: strip leading/trailing whitespace, filter comments\n  const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('%%'))\n\n  switch (diagramType) {\n    case 'sequence': {\n      const diagram = parseSequenceDiagram(lines)\n      const positioned = layoutSequenceDiagram(diagram, options)\n      return renderSequenceSvg(positioned, colors, font, transparent)\n    }\n    case 'class': {\n      const diagram = parseClassDiagram(lines)\n      const positioned = await layoutClassDiagram(diagram, options)\n      return renderClassSvg(positioned, colors, font, transparent)\n    }\n    case 'er': {\n      const diagram = parseErDiagram(lines)\n      const positioned = await layoutErDiagram(diagram, options)\n      return renderErSvg(positioned, colors, font, transparent)\n    }\n    case 'flowchart':\n    default: {\n      // Flowchart + state diagram pipeline (original)\n      const graph = parseMermaid(text)\n      const positioned = await layoutGraph(graph, options)\n      return renderSvg(positioned, colors, font, transparent)\n    }\n  }\n}\n"]}